theory Algebras_of_Cells
imports Padic_Cells
begin

(**************************************************************************************************)
(**************************************************************************************************)
section\<open>Algebras Generated by Cells with a Common Center\<close>
(**************************************************************************************************)
(**************************************************************************************************)

(**************************************************************************************************)
(**************************************************************************************************)
subsection\<open>Basic Combinatorial Fact about Intervals\<close>
(**************************************************************************************************)
(**************************************************************************************************)
text\<open>An important combinatorial property of $p$-adic cells is that the intersection of two $p$-adic 
cells with the same center is again a $p$-adic cell, and that sets which can be decomposed into 
$p$-adic cells form a boolean algebra. In order to reason about boolean combinations of cells, we 
need to be able to understand boolean combinations of intervals over the value group. This theory 
establishes the basic properties of those boolean combinations.\<close>
context padic_fields
begin

lemma closed_interval_memE:
  assumes "x \<in> closed_interval \<alpha> \<beta>"
  shows "\<alpha> \<le> x"
        "x \<le> \<beta>"
  unfolding closed_interval_def
  using assms closed_interval_def apply blast
  using assms closed_interval_def by blast

lemma closed_interval_memI:
  assumes "\<alpha> \<le> x"
  assumes "x \<le> \<beta>"
  shows "x \<in> closed_interval \<alpha> \<beta>"
  using assms unfolding closed_interval_def  by blast 

lemma left_closed_interval_memE:
  assumes "x \<in> left_closed_interval \<alpha> \<beta>"
  shows "\<alpha> \<le> x"
        "x < \<beta>"
  using assms left_closed_interval_def apply blast
  using assms left_closed_interval_def by blast

lemma left_closed_interval_memI:
  assumes "\<alpha> \<le> x"
  assumes "x < \<beta>"
  shows "x \<in> left_closed_interval \<alpha> \<beta>"
  using assms unfolding left_closed_interval_def  by blast 

lemma closed_ray_memE:
  assumes "x \<in> closed_ray \<alpha> \<beta>"
  shows  "x \<le> \<beta>"
  using assms closed_ray_def[of \<alpha> \<beta>] by blast

lemma closed_ray_memI:
  assumes "x \<le> \<beta>"
  shows "x \<in> closed_ray \<alpha> \<beta>"
  using assms unfolding closed_ray_def  by blast 

lemma open_ray_memE:
  assumes "x \<in> open_ray \<alpha> \<beta>"
  shows  "x < \<beta>"
  using assms open_ray_def[of \<alpha> \<beta>] by blast

lemma open_ray_memI:
  assumes "x < \<beta>"
  shows "x \<in> open_ray \<alpha> \<beta>"
  using assms unfolding open_ray_def by blast 

(**************************************************************************************************)
(**************************************************************************************************)
subsubsection\<open>Intersecting Convex Sets\<close>
(**************************************************************************************************)
(**************************************************************************************************)
text\<open>This section is a library of formulas for intersections of intervals. \<close>

lemma closed_interval_intersection:
"closed_interval (\<alpha>::eint) \<beta> \<inter> closed_interval \<gamma> \<delta> = closed_interval (max \<alpha> \<gamma>) (min \<beta> \<delta>)"
  apply(rule equalityI')
  unfolding mem_Collect_eq 
   apply (simp add: max_def min_def closed_interval_def )
proof- fix x assume A: "x \<in> closed_interval (max \<alpha> \<gamma>) (min \<beta> \<delta>)"
  have B: "(max \<alpha> \<gamma>) \<le> x"
    using A closed_interval_memE(1) by blast
  have C: "x \<le> (min \<beta> \<delta>)"
    using A closed_interval_memE(2) by blast 
  have 0: "\<alpha> \<le> x"
    using B  max.bounded_iff by blast
  have 1: "\<gamma> \<le> x"
    using B  by simp
  have 2: "x \<le> \<beta>"
    using C by simp
  have 3: "x \<le> \<delta>"
    using C by simp
  show "x \<in> I[\<alpha> \<beta>] \<inter> I[\<gamma> \<delta>]"
    using "0" "1" "2" "3" closed_interval_memI by blast
qed

lemma closed_interval_as_left_closed_interval:
  assumes "\<beta> \<noteq> \<infinity>"
  shows "closed_interval (\<alpha>::eint) \<beta>  = left_closed_interval \<alpha>  (\<beta> + 1)"
  apply(rule equalityI')
  apply(rule left_closed_interval_memI)  
  using closed_interval_memE(1) apply blast
proof-
  show "\<And>x. x \<in> I[\<alpha> \<beta>] \<Longrightarrow> x < \<beta> + 1"
  proof- fix x assume A: "x \<in> I[\<alpha> \<beta>]"
    then have "x \<le> \<beta>"
      using closed_interval_memE(2) by blast
    then have "x < \<beta> + 1"
      using assms 
      by (metis add.commute eSuc_eint eint.exhaust eint_ord_code(2) less_add_one order_trans_rules(21) top_eint_def)
    then show "x < \<beta> + 1 "
      by blast
  qed
  show "\<And>x. x \<in> left_closed_interval \<alpha> (\<beta> + 1) \<Longrightarrow> x \<in> I[\<alpha> \<beta>]"
    apply(rule closed_interval_memI)
    using left_closed_interval_memE(1) apply blast
    using eSuc_ile_mono ileI1 left_closed_interval_memE(2) by blast
qed

lemma closed_interval_left_closed_interval_intersection:
"closed_interval (\<alpha>::eint) \<beta> \<inter> left_closed_interval \<gamma> \<delta> = left_closed_interval (max \<alpha> \<gamma>) (min (\<beta>+1) \<delta>)"   
  apply(rule equalityI')
  apply(rule left_closed_interval_memI)
  using closed_interval_memE(1) left_closed_interval_memE(1) max.bounded_iff apply blast
proof-
  show " \<And>x. x \<in> I[\<alpha> \<beta>] \<inter> left_closed_interval \<gamma> \<delta> \<Longrightarrow> x < min (\<beta> + 1) \<delta>"
    apply(cases "\<beta> \<noteq> \<infinity>")
    using closed_interval_as_left_closed_interval[of \<beta> \<alpha>]
          left_closed_interval_memE 
    apply (metis mem_simps(4) min_less_iff_conj)
     by (metis eSuc_infinity left_closed_interval_memE(2) mem_simps(4) min_eint_simps(3))
  show "\<And>x. x \<in> left_closed_interval (max \<alpha> \<gamma>) (min (\<beta> + 1) \<delta>) \<Longrightarrow> x \<in> I[\<alpha> \<beta>] \<inter> left_closed_interval \<gamma> \<delta>"
     apply(rule IntI)
      apply(rule closed_interval_memI)
     using left_closed_interval_memE(1) max.bounded_iff apply blast
     using left_closed_interval_memE[of "(max \<alpha> \<gamma>)" "(min (\<beta> + 1) \<delta>)"]
      apply (meson ileI1 left_closed_interval_memE(2) min_le_iff_disj not_le)
     by (meson left_closed_interval_memE(1) left_closed_interval_memE(2) left_closed_interval_memI max.bounded_iff min_less_iff_conj)
qed

lemma closed_interval_closed_ray_intersection:
"closed_interval (\<alpha>::eint) \<beta> \<inter> closed_ray \<gamma> \<delta> = closed_interval \<alpha> (min \<beta> \<delta>)"   
  apply(rule equalityI')
  apply(rule closed_interval_memI) 
  using closed_interval_memE(1) apply blast
  apply (meson IntD1 IntD2 closed_interval_memE(2) closed_ray_memE min.bounded_iff)
  apply(rule IntI)
  apply(rule closed_interval_memI) 
  using closed_interval_memE(1) apply blast
  using closed_interval_memE(2) min.bounded_iff apply blast
  by (meson closed_interval_memE(2) closed_ray_memI min.boundedE)

lemma closed_interval_open_ray_intersection:
"closed_interval (\<alpha>::eint) \<beta> \<inter> open_ray \<gamma> \<delta> = left_closed_interval \<alpha> (min (\<beta>+1) \<delta>)"   
  apply(rule equalityI')
  apply(rule left_closed_interval_memI)
  using closed_interval_memE(1) left_closed_interval_memE(1) max.bounded_iff apply blast
proof-
  show "\<And>x. x \<in> I[\<alpha> \<beta>] \<inter> open_ray \<gamma> \<delta> \<Longrightarrow> x < min (\<beta> + 1) \<delta>"
    apply(cases "\<beta> \<noteq> \<infinity>")
  proof-
    show " \<And>x. x \<in> I[\<alpha> \<beta>] \<inter> open_ray \<gamma> \<delta> \<Longrightarrow> \<beta> \<noteq> \<infinity> \<Longrightarrow> x < min (\<beta> + 1) \<delta>" 
    proof- fix x assume A: " x \<in> I[\<alpha> \<beta>] \<inter> open_ray \<gamma> \<delta>" then show "x < min (\<beta> + 1) \<delta>" 
    using closed_interval_as_left_closed_interval[of \<beta> \<alpha>]
          left_closed_interval_memE[of x \<alpha> "\<beta> + 1"] open_ray_memE[of x \<gamma> \<delta>] IntE[of x]
    by (metis min_eint_simps(2) min_less_iff_conj plus_eint_simps(2))
    qed
    show "\<And>x. x \<in> I[\<alpha> \<beta>] \<inter> open_ray \<gamma> \<delta> \<Longrightarrow> \<not> \<beta> \<noteq> \<infinity> \<Longrightarrow> x < min (\<beta> + 1) \<delta>"
      by (metis mem_simps(4) min_eint_simps(3) open_ray_memE plus_eint_simps(2))
  qed
  show "\<And>x. x \<in> left_closed_interval \<alpha> (min (\<beta> + 1) \<delta>) \<Longrightarrow> x \<in> I[\<alpha> \<beta>] \<inter> open_ray \<gamma> \<delta>"
    apply(rule IntI) apply(rule closed_interval_memI) 
    using left_closed_interval_memE(1) apply blast
    using eSuc_ile_mono ileI1 left_closed_interval_memE(2) min.bounded_iff apply blast
    by (meson left_closed_interval_memE(2) min_less_iff_conj open_rayE)
qed  

lemma left_closed_interval_intersection:
"left_closed_interval (\<alpha>::eint) \<beta> \<inter> left_closed_interval \<gamma> \<delta> = left_closed_interval (max \<alpha> \<gamma>) (min \<beta> \<delta>)"   
  apply(rule equalityI')
  apply(rule left_closed_interval_memI) 
  apply (meson left_closed_interval_memE(1) max.bounded_iff mem_simps(4))
  apply (meson IntD1 IntD2 left_closed_interval_memE(2) min_less_iff_conj)
  apply(rule IntI) 
  apply (meson left_closed_interval_memE(1) left_closed_interval_memE(2) left_closed_interval_memI max.bounded_iff min_less_iff_conj)
  by (meson left_closed_interval_memE(1) left_closed_interval_memE(2) left_closed_interval_memI max.bounded_iff min_less_iff_conj)
  
lemma left_closed_interval_closed_ray_intersection:
"left_closed_interval (\<alpha>::eint) \<beta> \<inter> closed_ray \<gamma> \<delta> = left_closed_interval \<alpha> (min \<beta> (\<delta>+1))"   
  apply(rule equalityI')
  apply (metis closed_interval_closed_ray_intersection closed_interval_open_ray_intersection mem_simps(4) min.commute min_eint_simps(3) plus_eint_simps(2))
  by (metis closed_interval_closed_ray_intersection closed_interval_left_closed_interval_intersection closed_interval_open_ray_intersection mem_simps(4) min.commute min_eint_simps(3))

lemma left_closed_interval_open_ray_intersection:
"left_closed_interval (\<alpha>::eint) \<beta> \<inter> open_ray \<gamma> \<delta> = left_closed_interval \<alpha> (min \<beta> \<delta>)"   
  apply(rule equalityI')
  apply (meson left_closed_interval_memE(1) left_closed_interval_memE(2) left_closed_interval_memI mem_simps(4) min_less_iff_conj open_ray_memE)
  by (meson left_closed_interval_memE(1) left_closed_interval_memE(2) left_closed_interval_memI mem_simps(4) min_less_iff_conj open_rayE)

lemma closed_ray_intersection:
"closed_ray (\<alpha>::eint) (\<beta>::eint) \<inter> closed_ray (\<gamma>::eint) \<delta> = closed_ray \<alpha> (min \<beta> \<delta>)"  
  apply(rule equalityI')
  apply(rule closed_ray_memI)  
  apply (metis IntD1 IntD2 closed_ray_memE min_def)
  apply(rule IntI) 
   apply(rule closed_ray_memI)  
proof-
  show "\<And>x::eint . x \<in> closed_ray \<alpha> (min \<beta> \<delta>) \<Longrightarrow> x \<le> \<beta>" proof- fix x assume A: "x \<in> closed_ray \<alpha> (min \<beta> \<delta>)"
    then show "x \<le> \<beta>"
      using closed_ray_memE[of x \<alpha> "min \<beta> \<delta>"] min.bounded_iff[of "x::eint" \<beta> \<delta>] by blast 
  qed
  show "\<And>x. x \<in> closed_ray \<alpha> (min \<beta> \<delta>) \<Longrightarrow> x \<in> closed_ray \<gamma> \<delta>"
  proof- fix x assume A: "x \<in> closed_ray \<alpha> (min \<beta> \<delta>)"
    then show "x \<in> closed_ray \<gamma> \<delta>"
    using closed_ray_memE 
    by (metis closed_ray_memI min.bounded_iff)
  qed
qed

lemma closed_ray_open_ray_intersection:
"closed_ray (\<alpha>::eint) \<beta> \<inter> open_ray \<gamma> \<delta> = open_ray \<alpha> (min (\<beta>+1) \<delta> )"
  apply(rule equalityI')
   apply(rule open_ray_memI)  
proof-
  show "\<And>x. x \<in> closed_ray \<alpha> \<beta> \<inter> open_ray \<gamma> \<delta> \<Longrightarrow> x < min (\<beta> + 1) \<delta>"
  proof- fix x assume A: "x \<in> closed_ray \<alpha> \<beta> \<inter> open_ray \<gamma> \<delta>"
    have 0: "x \<le> \<beta>"
      by (meson A IntD1 closed_ray_memE)
    have 1: "x < \<delta>"
      by (meson A mem_simps(4) open_ray_memE)
    show "x < min (\<beta> + 1) \<delta>"
    proof(cases "\<beta> \<noteq> \<infinity>")
      case True
      then show ?thesis 
        by (metis "0" "1" closed_interval_as_left_closed_interval closed_interval_memI left_closed_interval_memE(2) min_less_iff_conj order_refl)
    next
      case False
      then show ?thesis 
        by (simp add: "1")
    qed
  qed
  show "\<And>x. x \<in> open_ray \<alpha> (min (\<beta> + 1) \<delta>) \<Longrightarrow> x \<in> closed_ray \<alpha> \<beta> \<inter> open_ray \<gamma> \<delta>"
    apply(rule IntI)
     apply (meson closed_ray_memI eSuc_ile_mono ileI1 min_less_iff_conj open_ray_memE)
    by (meson min.strict_boundedE open_ray_memE open_ray_memI)
qed

lemma open_ray_intersection:
"open_ray (\<alpha>::eint) (\<beta>::eint) \<inter> open_ray (\<gamma>::eint) \<delta> = open_ray \<alpha> (min \<beta> \<delta>)"  
  apply(rule equalityI')
  apply (meson IntD1 IntD2 min_less_iff_conj open_rayE open_ray_memE)
  by (meson mem_simps(4) min_less_iff_conj open_rayE open_ray_memE)

lemma notin_closed:
"(\<not> ((c::eint) \<le> x \<and> x \<le> d)) = (x < c \<or> d < x)" 
  by auto

(**************************************************************************************************)
(**************************************************************************************************)
subsubsection\<open>Set Differences of Convex Sets\<close>
(**************************************************************************************************)
(**************************************************************************************************)

lemma minus_left_closed_interval:
  assumes "d \<noteq> \<infinity>"
  shows "A -  left_closed_interval c d = (A \<inter> open_ray c c) \<union> (A \<inter> closed_interval d \<infinity>)"
  apply(intro equalityI', 
        unfold Int_iff Un_iff Diff_iff open_ray_def  closed_interval_def mem_Collect_eq 
          left_closed_interval_def)
  by auto 

lemma minus_closed_ray:
  assumes "(d::eint) \<noteq> \<infinity>"
  shows "A - closed_ray c d = (A \<inter> closed_interval (d+1) \<infinity>)"
proof(rule equalityI')  
  obtain m where m_def: "d = eint m"
    using assms by blast 
  have 0: "d+1 = eint (m+1)"
    using eSuc_eint_iff m_def by blast
  show "\<And>x. x \<in> A - closed_ray c d \<Longrightarrow> x \<in> A \<inter> I[d + 1 \<infinity>]"
    unfolding closed_ray_def closed_interval_def unfolding m_def
    apply(rule IntI) apply blast
  proof- fix x assume A: "x \<in> A - {a. a \<le> eint m}" 
    show "x \<in> {a. eint m + 1 \<le> a \<and> a \<le> \<infinity>}" using A apply (rule DiffE)
    unfolding mem_Collect_eq 
    by (metis "0" add.commute eSuc_eint eSuc_mono eint_ord_simps(4) eint_ord_simps(6) iless_Suc_eq m_def notin_closed plus_eint_def)
  qed
  show "\<And>x. x \<in> A \<inter> I[d + 1 \<infinity>] \<Longrightarrow> x \<in> A - closed_ray c d"
    unfolding closed_ray_def closed_interval_def 0 apply(rule DiffI) apply blast 
  proof fix x assume A: "x \<in> A \<inter> {a. eint (m + 1) \<le> a \<and> a \<le> \<infinity>}" "x \<in> {a. a \<le> d} "
    then have 0: "x \<in> {a. eint (m + 1) \<le> a \<and> a \<le> \<infinity>}"
      by blast 
    show False using 0  A(2) unfolding mem_Collect_eq m_def   
      by (metis eSuc_eint eint_ile iless_Suc_eq leD)
  qed
qed

lemma minus_open_ray:
  assumes "(d::eint) \<noteq> \<infinity>"
  shows "A - open_ray c d = (A \<inter> closed_interval d \<infinity>)"
proof(rule equalityI')  
  obtain m where m_def: "d = eint m"
    using assms by blast 
  show " \<And>x. x \<in> A - open_ray c d \<Longrightarrow> x \<in> A \<inter> I[d \<infinity>]"
    unfolding closed_ray_def closed_interval_def unfolding m_def
    apply(rule IntI) apply blast 
    unfolding open_ray_def mem_Collect_eq 
    by (meson Diff_iff eint_ord_simps(6) mem_Collect_eq notin_closed)
  show "\<And>x. x \<in> A \<inter> I[d \<infinity>] \<Longrightarrow> x \<in> A - open_ray c d"
    unfolding open_ray_def closed_interval_def apply(rule DiffI) apply blast 
    by (metis Int_iff mem_Collect_eq notin_closed)
qed

lemma minus_left_closed_interval':
  assumes "d = \<infinity>"
  shows "A -  left_closed_interval c d = (A \<inter> open_ray c c) \<union> (A \<inter> closed_interval \<infinity> \<infinity>)"
  by(intro equalityI', 
        unfold open_ray_def  closed_interval_def Diff_iff Int_iff Un_iff assms
              left_closed_interval_def mem_Collect_eq, auto )

lemma minus_closed_ray':
  assumes "(d::eint) = \<infinity>"
  shows "A - closed_ray c d = {}"
  unfolding closed_ray_def assms  
  using eint_ord_simps(3) by blast

lemma minus_closed_interval:
  assumes "d \<noteq> \<infinity>"
  shows "A -  closed_interval c d = (A \<inter> open_ray c c) \<union> (A \<inter> closed_interval (d+1) \<infinity>)"
proof(rule equalityI')
  obtain m where m_def: "d = eint m"
    using assms by blast 
  have 0: "d+1 = eint (m+1)"
    using eSuc_eint_iff m_def by blast
  show " \<And>x. x \<in> A - I[c d] \<Longrightarrow> x \<in> A \<inter> open_ray c c \<union> A \<inter> I[d + 1 \<infinity>]"
    unfolding open_ray_def  closed_interval_def 0 unfolding m_def
    by (metis (no_types, lifting) DiffD2 Diff_iff Int_iff UnI1 UnI2 eSuc_eint_iff eint_ord_simps(3) eint_ord_simps(6) ileI1 m_def mem_Collect_eq notin_closed val_p_int_pow)
  show "\<And>x. x \<in> A \<inter> open_ray c c \<union> A \<inter> I[d + 1 \<infinity>] \<Longrightarrow> x \<in> A - I[c d] "
    apply(rule DiffI) apply blast 
  proof fix x::eint assume A: "x \<in> A \<inter> open_ray (c::eint) c \<union> A \<inter> I[d + 1 \<infinity>]" " x \<in> I[c d]"
    show False
      apply(cases "x \<in> A \<inter> {a. a < c}")
      using A(2) unfolding open_ray_def  closed_interval_def 0 unfolding m_def mem_Collect_eq 
       apply (meson Int_iff mem_Collect_eq notin_closed)
    proof-
      assume "x \<notin> A \<inter> {a. a < c}"
      then have 1: "x \<in> I[d + 1 \<infinity>]"
      using A unfolding open_ray_def  closed_interval_def 0 unfolding m_def mem_Collect_eq
      by blast 
      thus False 
       using A(2) unfolding open_ray_def  closed_interval_def 0 unfolding m_def mem_Collect_eq
      by (metis "0" Int_iff add.commute assms dual_order.trans eSuc_eint eSuc_infinity eint.inject eint2_cases eint_iless eint_ord_Suc eint_ord_code(4) eint_ord_simps(3) eint_ord_simps(4) eint_ord_simps(5) eint_ord_simps(6) ex_val_less ile_eSuc infinity_ne_i1 int.lless_eq less_infinityE m_def mem_Collect_eq not_eint_eq notin_closed order.trans order_class.order.antisym sum_infinity_imp_summand_infinity top_eint_def zless_add1_eq)
  qed
qed
qed

lemma minus_closed_interval':
  assumes "d = \<infinity>"
  shows "A -  closed_interval c d = (A \<inter> open_ray c c)"
proof(rule equalityI')
  show "\<And>x. x \<in> A - I[c d] \<Longrightarrow> x \<in> A \<inter> open_ray c c"
    unfolding assms open_ray_def closed_interval_def 
    by (metis Diff_iff Int_iff eint_ord_code(3) inf_set_def mem_Collect_eq notin_closed)
  show "\<And>x. x \<in> A \<inter> open_ray c c \<Longrightarrow> x \<in> A - I[c d] "
    unfolding assms open_ray_def closed_interval_def 
  by (metis DiffI IntD1 IntD2 mem_Collect_eq notin_closed)
qed

lemma closed_interval_minus_closed_interval:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = closed_interval a b"
  assumes "J = closed_interval c d"
  shows "(I::eint set) - J = left_closed_interval a (min (b+1) c) \<union> closed_interval (max a (d+1)) b" 
proof(rule equalityI)
  show "(I::eint set) - J \<subseteq> left_closed_interval a (min (b+1) c) \<union> closed_interval (max a (d+1)) b" 
  proof 
    fix x::eint assume A: "x \<in> I - J" 
    show "x \<in> left_closed_interval a (min (b+1) c) \<union> I[(max a (d+1)) b] "
    proof assume A': " x \<notin> I[(max a (d+1)) b]"
      show " x \<in> left_closed_interval a (min (b+1) c)"
        apply(rule left_closed_interval_memI)         
        using A A'
        unfolding assms closed_interval_def left_closed_interval_def mem_Collect_eq 
        using  Extended_Int.ileI1 
         apply blast
        using A apply(rule DiffE)
                using A'
        unfolding assms closed_interval_def left_closed_interval_def mem_Collect_eq  notin_closed
        apply(cases "x < b+1")
         using ileI1 leD apply auto[1]         
        by (metis A' antisym closed_interval_as_left_closed_interval closed_interval_memI eSuc_inject eint_add_left_cancel eint_ord_code(3) iadd_Suc_right ile_eSuc left_closed_interval_memE(2) min.absorb1 min.assoc min.commute min.left_commute min.orderI min.strict_order_iff min_le_iff_disj neqE notin_closed)
    qed
  qed
  obtain m where m_def: "d = eint m"
    using assms(1) by blast
  show "left_closed_interval a (min (b + 1) c) \<union> I[(max a (d+1)) b] \<subseteq> I - J"
    apply(intro subsetI, 
          unfold left_closed_interval_def closed_interval_def mem_Collect_eq Un_iff Int_iff Diff_iff
                  m_def assms, intro conjI)
      apply auto[1]
    using Extended_Int.eSuc_ile_mono Extended_Int.ileI1 min.bounded_iff apply blast 
    by (meson Extended_Int.iless_Suc_eq dual_order.eq_iff max.bounded_iff min_less_iff_conj 
              not_less order_trans_rules(22))
qed

lemma closed_interval_minus_closed_interval':
  assumes "d = \<infinity>"
  assumes "(I::eint set) = closed_interval a b"
  assumes "J = closed_interval c d"
  shows "(I::eint set) - J = left_closed_interval a (min (b+1) c)" 
  using minus_closed_interval'[of d I c] unfolding assms closed_interval_open_ray_intersection by blast 

lemma closed_interval_minus_left_closed_interval:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = closed_interval a b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = left_closed_interval a (min (b + 1) c) \<union> I[(max a d) b]"
proof-
  have "(I::eint set) - J = (I \<inter> open_ray c c) \<union> (I \<inter> closed_interval d \<infinity>)"
    unfolding assms 
    by (simp add: assms(1) minus_left_closed_interval)
  thus "I - J = left_closed_interval a (min (b + 1) c) \<union> I[(max a d) b]"
    unfolding assms closed_interval_open_ray_intersection[of a b c c] closed_interval_intersection[of a b d \<infinity>]
    by simp
qed

lemma closed_interval_minus_left_closed_interval':
  assumes "(I::eint set) = closed_interval a b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = left_closed_interval a (min (b + 1) c) \<union> I[(max a d) b]"
proof(cases "d = \<infinity>")
  case True
    have "(I::eint set) - J = (I \<inter> open_ray c c) \<union> (I \<inter> closed_interval \<infinity> \<infinity>)"
    unfolding assms 
    by (simp add: True assms(1) minus_left_closed_interval')
  thus "I - J = left_closed_interval a (min (b + 1) c) \<union> I[(max a d) b]"
    unfolding assms closed_interval_open_ray_intersection[of a b c c] closed_interval_intersection[of a b d \<infinity>]
    by (simp add: True closed_interval_intersection)
next
  case False
  then show ?thesis 
    by (simp add: assms(1) assms(2) closed_interval_minus_left_closed_interval)
qed

lemma closed_interval_minus_closed_ray:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = closed_interval a b"
  assumes "J = closed_ray c d"
  shows "(I::eint set) - J = closed_interval (max a (d + 1)) (min b \<infinity>)"
proof-
  obtain m where m_def: "d = eint m"
    using assms(1) by blast
  have 0: "d+1 = eint (m+1)"
    using eSuc_eint_iff m_def by blast
  have "I - J = I \<inter> closed_interval (d+1) \<infinity>"
    apply(rule equalityI')
    apply(rule IntI) 
    unfolding 0 assms closed_interval_def closed_ray_def unfolding m_def
     apply blast
    using assms minus_closed_ray[of d] unfolding mem_Collect_eq closed_interval_def closed_ray_def 0
    using m_def apply blast
    apply(rule DiffI) unfolding mem_Collect_eq 
     apply blast 
  proof fix x assume A: "x \<in> {aa. a \<le> aa \<and> aa \<le> b} \<inter> {a. eint (m + 1) \<le> a \<and> a \<le> \<infinity>}" "x \<le> eint m"
    then have "eint (m + 1) \<le> x" by blast  
    thus False using A(2) 0 dual_order.antisym dual_order.trans eint.inject ile_eSuc
      unfolding  m_def 
      by (simp add: Extended_Int.Suc_ile_eq)
  qed
  thus ?thesis unfolding assms closed_interval_intersection by blast   
qed

lemma closed_interval_minus_closed_ray':
  assumes "d = \<infinity>"
  assumes "(I::eint set) = closed_interval a b"
  assumes "J = closed_ray c d"
  shows "(I::eint set) - J = {}"
  by (simp add: assms(1) assms(3) minus_closed_ray')

lemma closed_interval_minus_open_ray:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = closed_interval a b"
  assumes "J = open_ray c d"
  shows "(I::eint set) - J = closed_interval (max a d) b"
proof- 
  obtain m where m_def: "d = eint m"
    using assms(1) by blast
  have "I - J = I \<inter> closed_interval d \<infinity>"
    apply(intro equalityI', 
          unfold Un_iff Diff_iff Int_iff closed_interval_def mem_Collect_eq m_def assms open_ray_def, 
          intro conjI)
    using assms by auto 
  thus ?thesis unfolding assms closed_interval_intersection
    by simp
qed

lemma closed_interval_minus_open_ray':
  assumes "(I::eint set) = closed_interval a b"
  assumes "J = open_ray c d"
  shows "(I::eint set) - J = closed_interval (max a d) b"
proof(cases "d = \<infinity>")
  case True
  have 0: "max a \<infinity> = \<infinity>" 
    by simp
  show ?thesis 
    apply(intro equalityI', 
          unfold Diff_iff closed_interval_def mem_Collect_eq True 0 assms open_ray_def)
    by auto 
next
  case False
  then show ?thesis 
    by (simp add: assms(1) assms(2) closed_interval_minus_open_ray)
qed

lemma left_closed_interval_minus_closed_interval:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = closed_interval c d"
  shows "(I::eint set) - J =  left_closed_interval a (min b c) \<union> left_closed_interval (max a (d + 1)) b"
proof-
  have 0: "I - J = I \<inter> open_ray c c \<union> (I \<inter> I[d + 1 \<infinity>])"
    using minus_closed_interval[of d I c] assms by blast 
  have 1: "I \<inter> I[d + 1 \<infinity>] =  left_closed_interval (max (d + 1) a) (min (\<infinity> + 1) b)"
  unfolding assms left_closed_interval_open_ray_intersection[of a b c c]
    using   closed_interval_left_closed_interval_intersection[of "d+1" \<infinity> a b ] assms unfolding Int_commute[of "I[d + 1 \<infinity>] "] 
    by blast
  have 2: " I \<inter> open_ray c c =  left_closed_interval a (min b c)"
    using left_closed_interval_open_ray_intersection[of a b c c] unfolding assms by blast 
  show ?thesis    
    using 0 unfolding 1 2  
  by (simp add: max.commute)  
qed

lemma left_closed_interval_minus_closed_interval':
  assumes "d = \<infinity>"
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = closed_interval c d"
  shows "(I::eint set) - J =  left_closed_interval a (min b c)"
  using minus_closed_interval'[of d I c] unfolding assms left_closed_interval_open_ray_intersection by blast 

lemma left_closed_interval_minus_left_closed_interval:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = left_closed_interval a (min b c) \<union> left_closed_interval a b \<inter> I[d \<infinity>]"
proof-
  have 0: "(I::eint set) - J = left_closed_interval a b \<inter> open_ray c c \<union> left_closed_interval a b \<inter> I[d \<infinity>]"
    using assms minus_left_closed_interval[of d I c] unfolding assms 
    by blast 
  show ?thesis 
    using 0  unfolding left_closed_interval_open_ray_intersection using closed_interval_left_closed_interval_intersection
    unfolding Int_commute[of "I[d \<infinity>]"]
    by blast 
qed

lemma left_closed_interval_minus_left_closed_interval':
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = left_closed_interval a (min b c) \<union> left_closed_interval a b \<inter> I[d \<infinity>]"
proof(cases "d = \<infinity>")
  case True 
  have 0: "(I::eint set) - J = left_closed_interval a b \<inter> open_ray c c \<union> left_closed_interval a b \<inter> I[\<infinity> \<infinity>]"
    using True  assms minus_left_closed_interval'[of d I c] unfolding assms 
    by blast 
  show ?thesis 
    using 0  unfolding True left_closed_interval_open_ray_intersection using closed_interval_left_closed_interval_intersection
    unfolding Int_commute[of "I[d \<infinity>]"]
    by blast 
next
  case False
  then show ?thesis 
    by (simp add: assms(1) assms(2) left_closed_interval_minus_left_closed_interval)
qed

lemma left_closed_interval_minus_left_closed_interval'':
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = left_closed_interval a (min b c) \<union> left_closed_interval (max d a) b"
  using closed_interval_left_closed_interval_intersection[of d \<infinity> a b]
        left_closed_interval_minus_left_closed_interval' assms 
  by (simp add: Int_commute)

lemma left_closed_interval_minus_closed_ray:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = closed_ray c d"
  shows "(I::eint set) - J = left_closed_interval (max (d + 1) a) (min (\<infinity> + 1) b)"
proof-
  have 0: "I - J =  left_closed_interval a b \<inter> I[d + 1 \<infinity>]"
    using assms minus_closed_ray[of d I c] unfolding assms 
    by blast 
  thus ?thesis using closed_interval_left_closed_interval_intersection[of "d+1" \<infinity> a b] 
    unfolding Int_commute[of "I[d + 1 \<infinity>]"] by blast 
qed

lemma left_closed_interval_minus_closed_ray':
  assumes "d = \<infinity>"
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = closed_ray c d"
  shows "(I::eint set) - J = {}"
  by (simp add: assms(1) assms(3) minus_closed_ray')

lemma left_closed_interval_minus_open_ray:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = open_ray c d"
  shows "(I::eint set) - J = left_closed_interval (max d a) b"
proof-
  have 0: "I - J =  left_closed_interval a b \<inter> I[d \<infinity>]"
    using assms minus_open_ray[of d I c] unfolding assms 
    by blast 
  thus ?thesis using closed_interval_left_closed_interval_intersection[of "d" \<infinity>  a b  ] 
    unfolding Int_commute[of "I[d \<infinity>]"] 
    by simp
qed

lemma left_closed_interval_minus_open_ray':
  assumes "(I::eint set) = left_closed_interval a b"
  assumes "J = open_ray c d"
  shows "(I::eint set) - J = left_closed_interval (max d a) b"
proof(cases "d = \<infinity>")
  case True
  have 0: "max d a = \<infinity>"
    by (simp add: True)
  show ?thesis
    by(rule equalityI', 
       unfold Diff_iff Un_iff Int_iff left_closed_interval_def assms mem_Collect_eq open_ray_def True, 
       auto)
next
  case False
  then show ?thesis 
    by (simp add: assms(1) assms(2) left_closed_interval_minus_open_ray)
qed

lemma closed_ray_minus_closed_interval:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = closed_ray (a::eint) b"
  assumes "J = closed_interval c d"
  shows "(I::eint set) - J = open_ray a (min (b + 1) c) \<union> I[d + 1 b]"
proof-
  have 0: "I - J = I \<inter> open_ray c c \<union> I \<inter> I[d + 1 \<infinity>]"
    using assms minus_closed_interval[of d I c] unfolding assms 
    by blast 
  have 1: "I \<inter> open_ray c c = open_ray a (min (b + 1) c)"
    unfolding closed_ray_open_ray_intersection assms by blast 
  have 2: "I \<inter> I[d + 1 \<infinity>] = I[d + 1 b]"
    using closed_interval_closed_ray_intersection[of "d+1" \<infinity> a b] unfolding assms 
    by (simp add: Int_commute)
  show ?thesis using 0 unfolding 1 2 by blast 
qed

lemma closed_ray_minus_closed_interval':
  assumes "d = \<infinity>"
  assumes "(I::eint set) = closed_ray (a::eint) b"
  assumes "J = closed_interval (c::eint) d"
  shows "(I::eint set) - J = open_ray a (min (b + 1) c)"
proof(cases "b = \<infinity>")
  case True 
  show ?thesis
    by(rule equalityI', 
       unfold Diff_iff Un_iff Int_iff closed_interval_def assms mem_Collect_eq open_ray_def True 
              closed_ray_def,  auto)
next
  case False
  obtain m where m_def: "b = eint m"
    using False by blast
  show ?thesis 
    apply(intro equalityI', 
        unfold Diff_iff Un_iff Int_iff closed_interval_def assms mem_Collect_eq open_ray_def m_def 
              closed_ray_def)
     apply (metis Extended_Int.iless_Suc_eq eint_ord_simps(3) min_less_iff_conj not_eint_eq notin_closed)
    by (metis Extended_Int.ileI1 min.strict_boundedE notin_closed)
qed

lemma closed_ray_minus_left_closed_interval:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = closed_ray (a::eint) b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = open_ray a (min (b + 1) c) \<union> I[d b]"
proof-
  have 0: "I - J =  I \<inter> open_ray c c \<union> I \<inter> I[d \<infinity>]"
    using assms minus_left_closed_interval[of d I c] unfolding assms 
    by blast 
  have 1: "I \<inter> open_ray c c = open_ray a (min (b + 1) c)"
    unfolding closed_ray_open_ray_intersection assms by blast 
  have 2: "I \<inter> I[d  \<infinity>] = I[d  b]"
    using closed_interval_closed_ray_intersection[of "d" \<infinity> a b] unfolding assms 
    by (simp add: Int_commute)
  show ?thesis using 0 unfolding 1 2 by blast 
qed

lemma closed_ray_minus_left_closed_interval':
  assumes "(I::eint set) = closed_ray (a::eint) b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = open_ray a (min (b + 1) c) \<union> I[d b]"
proof(cases "d = \<infinity>")
  case True
  have 0: "I - J =  I \<inter> open_ray c c \<union> I \<inter> I[d \<infinity>]"
    using True assms minus_left_closed_interval'[of d I c] unfolding assms 
    by blast 
  have 1: "I \<inter> open_ray c c = open_ray a (min (b + 1) c)"
    unfolding closed_ray_open_ray_intersection assms by blast 
  have 2: "I \<inter> I[d  \<infinity>] = I[d  b]"
    using closed_interval_closed_ray_intersection[of "d" \<infinity> a b] unfolding assms 
    by (simp add: Int_commute)
  show ?thesis using 0 unfolding 1 2 by blast 
next
  case False
  then show ?thesis 
    by (simp add: assms(1) assms(2) closed_ray_minus_left_closed_interval)
qed

lemma closed_ray_minus_closed_ray:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = closed_ray a b"
  assumes "J = closed_ray c d"
  shows "(I::eint set) - J = I[(d + 1) b]"
proof-
  have "I - J = I \<inter> I[d + 1 \<infinity>]"
    using minus_closed_ray[of d I c] assms by blast 
  thus ?thesis unfolding assms  closed_interval_closed_ray_intersection
    using closed_interval_closed_ray_intersection[of "d+1" \<infinity> a b] 
    by (simp add: Int_commute)
qed

lemma closed_ray_minus_closed_ray':
  assumes "d = \<infinity>"
  assumes "(I::eint set) = closed_ray a b"
  assumes "J = closed_ray c d"
  shows "(I::eint set) - J = {}"
  unfolding assms closed_ray_def 
  by simp

lemma closed_ray_minus_open_ray:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = closed_ray a b"
  assumes "J = open_ray c d"
  shows "(I::eint set) - J =  I[d b]"
proof-
  have "I - J = I \<inter> I[d  \<infinity>]"
    using minus_open_ray[of d I c] assms by blast 
  thus ?thesis unfolding assms 
    using  closed_interval_closed_ray_intersection[of d \<infinity> a b]
    by (simp add: Int_commute)
qed

lemma closed_ray_minus_open_ray':
  assumes "(I::eint set) = closed_ray (a::eint) b"
  assumes "J = open_ray (c::eint) d"
  shows "(I::eint set) - J = I[d b]"
proof(cases "d = \<infinity>")
  case True
  then show ?thesis unfolding assms True closed_ray_def open_ray_def closed_interval_def 
    by fastforce
next
  case False
  then show ?thesis 
    by (simp add: assms(1) assms(2) closed_ray_minus_open_ray)
qed

lemma minus_open_ray':
  assumes "(d::eint) = \<infinity>"
  shows "(A::eint set) - open_ray c d = (A \<inter> closed_interval (\<infinity>::eint) (\<infinity>::eint))"
proof(rule equalityI')  
  show " \<And>x. x \<in> A - open_ray c d \<Longrightarrow> x \<in> A \<inter> closed_interval \<infinity> \<infinity>"
    unfolding assms open_ray_def closed_ray_def 
    by (metis DiffD1 DiffD2 DiffI Diff_Diff_Int mem_Collect_eq minus_closed_interval' open_ray_memE)
  show "\<And>x. x \<in> A \<inter> I[\<infinity> \<infinity>] \<Longrightarrow> x \<in> A - open_ray c d"
       unfolding assms open_ray_def closed_ray_def 
       by (metis DiffI IntD1 IntD2 closed_interval_memE(1) closed_interval_memE(2) mem_Collect_eq notin_closed)
qed

lemma open_ray_minus_closed_interval:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = open_ray a b"
  assumes "J = closed_interval c d"
  shows "(I::eint set) - J = open_ray a (min b c) \<union> left_closed_interval (d + 1) b"
proof-
  have 0: "I - J = I \<inter> open_ray c c \<union> I \<inter> I[d + 1 \<infinity>]"
    using assms minus_closed_interval[of d I c] unfolding assms 
    by blast 
  have 1: "I \<inter> open_ray c c = open_ray a (min b c)"
    unfolding assms open_ray_intersection assms by blast 
  have 2: "I \<inter> I[d + 1 \<infinity>] = left_closed_interval (d + 1) b"
    using closed_interval_open_ray_intersection[of "d+1" \<infinity> a b] unfolding assms 
    by (simp add: Int_commute)
  show ?thesis using 0 unfolding 1 2 by blast 
qed

lemma open_ray_minus_closed_interval':
  assumes "d = \<infinity>"
  assumes "(I::eint set) = open_ray a b"
  assumes "J = closed_interval c d"
  shows "(I::eint set) - J = open_ray a (min b c)"
  unfolding assms open_ray_def closed_interval_def 
  by force

lemma open_ray_minus_left_closed_interval:
  assumes "d \<noteq> \<infinity>"
  assumes "(I::eint set) = open_ray a b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = open_ray a (min b c) \<union> left_closed_interval d b"
proof-
  have 0: "I - J =  I \<inter> open_ray c c \<union> I \<inter> I[d \<infinity>]"
    using assms minus_left_closed_interval[of d I c] unfolding assms 
    by blast 
  have 1: "I \<inter> open_ray c c = open_ray a (min b c)"
    unfolding open_ray_intersection assms by blast 
  have 2: "I \<inter> I[d  \<infinity>] = left_closed_interval d b"
    using closed_interval_open_ray_intersection[of "d" \<infinity> a b] unfolding assms 
    by (simp add: Int_commute)
  show ?thesis using 0 unfolding 1 2 by blast 
qed

lemma open_ray_minus_left_closed_interval':
  assumes "(I::eint set) = open_ray a b"
  assumes "J = left_closed_interval c d"
  shows "(I::eint set) - J = open_ray a (min b c) \<union> left_closed_interval d b"
proof(cases "d = \<infinity>")
case True
  show ?thesis apply(rule equalityI') 
    unfolding assms True open_ray_def left_closed_interval_def 
    apply (metis Diff_iff True Un_iff assms(2) eint_ord_simps(6) left_closed_interval_def left_closed_interval_memI mem_Collect_eq min_less_iff_conj notin_closed)
    by (metis Diff_iff True Un_commute Un_iff eint_ord_code(3) mem_Collect_eq min.commute min_less_iff_conj notin_closed)
next
  case False 
  then show ?thesis 
    by (simp add: assms(1) assms(2) open_ray_minus_left_closed_interval) 
qed

lemma open_ray_minus_closed_ray:
  assumes "d \<noteq>\<infinity>"
  assumes "(I::eint set) = open_ray a b"
  assumes "J = closed_ray c d"
  shows "(I::eint set) - J =left_closed_interval (d + 1) b"
proof-
  have "I - J = I \<inter> I[d + 1 \<infinity>]"
    using minus_closed_ray[of d I c] assms by blast 
  thus ?thesis unfolding assms using closed_interval_open_ray_intersection[of "d+1" \<infinity> a b]
  by (simp add: Int_commute)
qed

lemma open_ray_minus_closed_ray':
  assumes "d =\<infinity>"
  assumes "(I::eint set) = open_ray a b"
  assumes "J = closed_ray c d"
  shows "(I::eint set) - J = {}"
  unfolding assms open_ray_def closed_ray_def 
  by simp

lemma open_ray_minus_open_ray:
  assumes "d \<noteq>\<infinity>"
  assumes "(I::eint set) = open_ray a b"
  assumes "J = open_ray c d"
  shows "(I::eint set) - J = left_closed_interval d b"
proof-
  have "I - J = I \<inter> I[d  \<infinity>]"
    using minus_open_ray[of d I c] assms by blast 
  thus ?thesis unfolding assms using closed_interval_open_ray_intersection[of d \<infinity> a b]
  by (simp add: Int_commute)
qed

lemma open_ray_minus_open_ray':
  assumes "(I::eint set) = open_ray a b"
  assumes "J = open_ray c d"
  shows "(I::eint set) - J = left_closed_interval d b"
proof(cases "d = \<infinity>")
  case True
  show ?thesis apply(rule equalityI') 
    unfolding True assms left_closed_interval_def using 
Diff_eq_empty_iff assms(1) assms(2) eint_ord_simps(4) eint_ord_simps(6) left_closed_interval_memE(2)
   left_closed_interval_minus_open_ray' max_eint_simps(3) open_rayE open_ray_memE subset_iff 
     apply (metis DiffD1 DiffD2 DiffI True max.strict_order_iff mem_Collect_eq minus_open_ray' notin_closed)
  by (metis eint_ord_simps(5) eint_ord_simps(6) mem_Collect_eq)
next
  case False
  then show ?thesis 
    by (simp add: assms(1) assms(2) open_ray_minus_open_ray)
qed
end

(**************************************************************************************************)
(**************************************************************************************************)
subsection\<open>Intersections of Cells with the Same Center\<close>
(**************************************************************************************************)
(**************************************************************************************************)

context padic_fields
begin

lemma cell_intersection_bounds:
  assumes "a1 \<in> carrier (SA m)"
  assumes "a1' \<in> carrier (SA m)"
  shows "\<exists> a1'' \<in> carrier (SA m). \<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a1'' x) = max (val (a1 x)) (val (a1' x))"
proof- 
  obtain S where S_def: "S = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a1 x)  < val (a1' x)}"
    by blast 
  have S_semialg: "is_semialgebraic m S"
    unfolding S_def using assms semialg_val_strict_ineq_set_is_semialg by blast
  obtain a1'' where  a1''_def: "a1'' = fun_glue m S a1' a1"
    by blast 
  have a1''_semialg: "a1'' \<in> carrier (SA m)"
    unfolding a1''_def using assms S_semialg fun_glue_closed by blast
  have "\<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a1'' x) = max (val (a1 x)) (val (a1' x))"
  proof fix x assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    show " val (a1'' x) = max (val (a1 x)) (val (a1' x))"
    proof(cases "x \<in> S")
      case True
      then have T0: "max (val (a1 x)) (val (a1' x)) = val (a1' x)"
        unfolding S_def using max.commute max.strict_order_iff mem_Collect_eq by auto 
      have T1: "(if x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (a1 x) < val (a1' x) then a1' x else a1 x) = a1' x "
        using True A unfolding S_def mem_Collect_eq  by presburger 
      have T2: "a1'' x = (if x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (a1 x) < val (a1' x) then a1' x else a1 x)"
        unfolding a1''_def fun_glue_def S_def mem_Collect_eq restrict_def using A by presburger 
      show ?thesis
        using A True unfolding T0 S_def T2 T1 by blast 
    next
      case False
      then show ?thesis         
        using A unfolding S_def a1''_def fun_glue_def mem_Collect_eq restrict_def max_def
        by (auto simp: basic_trans_rules(17)) 
    qed
  qed
  thus ?thesis using a1''_semialg 
    by blast
qed

lemma cell_intersection_bounds':
  assumes "a1 \<in> carrier (SA m)"
  assumes "a1' \<in> carrier (SA m)"
  shows "\<exists> a1'' \<in> carrier (SA m). \<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a1'' x) = min (val (a1 x)) (val (a1' x))"
proof- 
  obtain S where S_def: "S = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a1' x)  < val (a1 x)}"
    by blast 
  have S_semialg: "is_semialgebraic m S"
    unfolding S_def using assms semialg_val_strict_ineq_set_is_semialg by blast
  obtain a1'' where  a1''_def: "a1'' = fun_glue m S a1' a1"
    by blast 
  have a1''_semialg: "a1'' \<in> carrier (SA m)"
    unfolding a1''_def using assms S_semialg fun_glue_closed by blast
  have "\<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a1'' x) = min (val (a1 x)) (val (a1' x))"
  proof fix x assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    show " val (a1'' x) = min (val (a1 x)) (val (a1' x))"
    proof(cases "x \<in> S")
      case True
      then have T0: "min (val (a1 x)) (val (a1' x)) = val (a1' x)"
        unfolding S_def using  min.commute min.strict_order_iff mem_Collect_eq by auto 
      have T1: "(if x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (a1' x) < val (a1 x) then a1' x else a1 x) = a1' x "
        using True A unfolding S_def mem_Collect_eq  by presburger 
      have T2: "a1'' x = (if x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (a1' x) < val (a1 x) then a1' x else a1 x)"
        unfolding a1''_def fun_glue_def S_def mem_Collect_eq restrict_def using A by presburger 
      show ?thesis
        using A True unfolding T0 S_def T2 T1 by blast 
    next
      case False
      then have F0: " min (val (a1 x)) (val (a1' x)) = val (a1 x)"
        using A unfolding S_def mem_Collect_eq by auto 
      show ?thesis         
        using A False unfolding F0 S_def a1''_def fun_glue_def mem_Collect_eq restrict_def
        by presburger        
    qed
  qed
  thus ?thesis using a1''_semialg 
    by blast
qed

lemma convex_intersection:
  assumes "is_convex A"
  assumes "is_convex B"
  shows "is_convex (A \<inter> B)"
  apply(rule is_convexI)
  using assms is_convexE[of A] is_convexE[of B]
  by blast

lemma convex_condition_intersection:
  assumes "is_convex_condition I"
  assumes "is_convex_condition I'"
  assumes "a1 \<in> carrier (SA m)"
  assumes "a1' \<in> carrier (SA m)"
  assumes "a2 \<in> carrier (SA m)"
  assumes "a2' \<in> carrier (SA m)"
  shows "\<exists> l u J. is_convex_condition J \<and> l \<in> carrier (SA m) \<and> u \<in> carrier (SA m) \<and>
               (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). (J (val (l x)) (val (u x)) = I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x))))"
proof-
  obtain l where l_def: "l \<in> carrier (SA m) \<and> (\<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (l x) = max (val (a1 x)) (val (a1' x)))"
    using assms by (metis (no_types, opaque_lifting) cell_intersection_bounds)
  obtain u where u_def: "u \<in> carrier (SA m) \<and> (\<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (u x) = min (val (a2 x)) (val (a2' x)))"
    using assms by (metis (no_types, opaque_lifting) cell_intersection_bounds')
  obtain u' where u'_def: "u' \<in> carrier (SA m) \<and> (\<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (u' x) = min (val (a2 x)) (val ((\<pp>\<odot>\<^bsub>SA m\<^esub>a2') x)))"
    using assms 
    by (metis (no_types, opaque_lifting) Qp.int_inc_closed SA_smult_closed cell_intersection_bounds')
  obtain u'' where u''_def: "u'' \<in> carrier (SA m) \<and> (\<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (u'' x) = min (val ((\<pp>\<odot>\<^bsub>SA m\<^esub>a2) x)) (val ((a2') x)))"
    using assms 
    by (metis (no_types, opaque_lifting) Qp.int_inc_closed SA_smult_closed cell_intersection_bounds')
  have 0: "(\<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (u'' x) = min (val ((a2 x)) + 1) (val ((a2') x)))"
    using u''_def by (metis assms(5) p_mult_function_val)
  have 1: "(\<forall> x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (u' x) = min (val (a2 x)) (val ((a2' x)) + 1) )"
    using u''_def  by (metis assms(6) p_mult_function_val u'_def)
  show ?thesis
  proof(cases "I = closed_interval")
  case True
  show ?thesis
  proof(cases "I' = closed_interval")
    case T: True
    have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = I (val (l x)) (val (u x))"
      unfolding True T using l_def u_def 
      by (metis closed_interval_intersection)
    show ?thesis 
      using \<open>\<forall>x\<in>carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = I (val (l x)) (val (u x))\<close> assms(1) l_def u_def 
      by blast    
  next
    case False
    show ?thesis 
     proof(cases "I' = left_closed_interval")
       case T: True
       have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = left_closed_interval (val (l x)) (val (u'' x))"
         unfolding True T using l_def u''_def 1 by (metis "0" closed_interval_left_closed_interval_intersection)
      then show ?thesis 
        using T assms(2) l_def u''_def by blast
    next
      case F0: False
      show ?thesis
        proof(cases "I' = closed_ray")
          case T: True
          have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = closed_interval (val (a1 x)) (val (u x))"
            unfolding True T using u_def by (metis closed_interval_closed_ray_intersection)
          then show ?thesis using l_def u_def  True eval_hom_def is_convex_condition_def assms(3) 
            by metis
        next
          case F1: False
          have F10: "I' = open_ray"
            using assms False F0 F1 unfolding is_convex_condition_def by blast 
          have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = left_closed_interval (val (a1 x)) (val (u'' x))"
            unfolding True F10 using u''_def 0 closed_interval_open_ray_intersection[of ] by metis
              then show ?thesis using assms l_def u''_def  by (metis eval_hom_def is_convex_condition_def)
     qed
    qed
  qed
next
  case False
  show ?thesis 
    proof(cases "I = left_closed_interval")
      case True
      show ?thesis
      proof(cases "I' = closed_interval")
        case T: True
        have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = I (val (l x)) (val (u' x))"
          unfolding True T using min.commute l_def u'_def 1 closed_interval_left_closed_interval_intersection
          by (metis inf_sup_aci(1) max.commute)
        thus ?thesis 
          using assms(1) assms l_def u'_def   by blast
      next
        case False
        show ?thesis 
        proof(cases "I' = left_closed_interval")
          case T: True
          have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = left_closed_interval (val (l x)) (val (u x))"
            unfolding True T using l_def u_def 
            by (metis left_closed_interval_intersection)
          then show ?thesis 
            using T assms(2) assms l_def u_def  by blast
        next
          case F0: False
          show ?thesis
          proof(cases "I' = closed_ray")
            case T: True
            have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = left_closed_interval (val (a1 x)) (val (u' x))"
              unfolding True T using u'_def 1 left_closed_interval_closed_ray_intersection by metis
            then show ?thesis 
              using True assms l_def u'_def assms(1) by blast
          next
            case F1: False
            have F10: "I' = open_ray"
              using assms False F0 F1 unfolding is_convex_condition_def by blast 
            have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = left_closed_interval (val (a1 x)) (val (u x))"
              unfolding True F10 using u_def 0 left_closed_interval_open_ray_intersection[of ] by metis
            then show ?thesis using assms l_def u_def 
              by (metis eval_hom_def is_convex_condition_def)
          qed
        qed
      qed
    next
      case F0: False
      show ?thesis
        proof(cases "I = closed_ray")
          case True
          show ?thesis 
          proof(cases "I' = closed_interval")
            case T: True
            have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = I' (val (a1' x)) (val (u x))"
              unfolding True T using min.commute l_def u_def closed_interval_closed_ray_intersection
              by (metis (no_types, lifting) inf_sup_aci(1))    
            thus ?thesis 
              using assms l_def u_def assms by blast
          next
            case False
            show ?thesis 
            proof(cases "I' = left_closed_interval")
              case T: True
              have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = left_closed_interval (val (a1' x)) (val (u'' x))"
                unfolding True T using 0  left_closed_interval_closed_ray_intersection min.commute 
                by (metis inf_sup_aci(1))
              then show ?thesis 
                using T assms(2) assms l_def u''_def  by blast
            next
              case F0: False
              show ?thesis
              proof(cases "I' = closed_ray")
                case T: True
                have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = closed_ray (val (a1 x)) (val (u x))"
                  unfolding True T using u_def 1 closed_ray_intersection by metis
                then show ?thesis 
                  using True assms(1) assms l_def u_def  by blast
              next
                case F1: False
                have F10: "I' = open_ray"
                  using assms False F0 F1 unfolding is_convex_condition_def by blast 
                have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = open_ray (val (a1 x)) (val (u'' x))"
                  unfolding True F10 using u'_def 1 closed_ray_open_ray_intersection[of ] min.commute 
                  by (metis "0")            
                then show ?thesis using assms l_def u''_def 
                  by (metis eval_hom_def is_convex_condition_def)
              qed
            qed
          qed
          next
          case F1: False
          have True: "I = open_ray"
            using assms False F0 F1 unfolding is_convex_condition_def by blast 
          then show ?thesis 
          proof(cases "I' = closed_interval")
            case T: True
            have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = left_closed_interval (val (a1' x)) (val (u' x))"
              unfolding True T using 1 min.commute closed_interval_open_ray_intersection
              by (metis inf_sup_aci(1))            
                thus ?thesis 
                  using assms assms l_def u'_def 
                  by (metis eval_hom_def is_convex_condition_def)                
              next
                case False
                show ?thesis 
                proof(cases "I' = left_closed_interval")
                  case T: True
                  have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = left_closed_interval (val (a1' x)) (val (u x))"
                    unfolding True T using u_def  left_closed_interval_open_ray_intersection min.commute 
                    by (metis inf_sup_aci(1))
                  then show ?thesis 
                    using T assms(2) assms l_def u_def  by blast
                next
                  case F0: False
                  show ?thesis
                  proof(cases "I' = closed_ray")
                    case T: True
                    have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = open_ray (val (a1' x)) (val (u' x))"
                      unfolding True T using 1 closed_ray_open_ray_intersection 
                      by (metis inf_commute min.commute)
                    then show ?thesis 
                      using assms l_def u'_def True assms(1) by blast
                  next
                    case F1: False
                    have F10: "I' = open_ray"
                      using assms False F0 F1 unfolding is_convex_condition_def by blast 
                    have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x)) = open_ray (val (a1 x)) (val (u x))"
                      unfolding True F10 using u_def 1 open_ray_intersection[of ] min.commute 
                      by (metis "0")            
                    then show ?thesis using assms l_def u_def 
                      by (metis eval_hom_def is_convex_condition_def)
                  qed
                qed
              qed
            qed
          qed
        qed
qed

lemma cell_intersection_same_center:
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  assumes "\<C> = Cond m C c a1 a2 I"
  assumes "\<C>' = Cond m C' c a1' a2' I'"
  shows "\<exists> \<C>''. is_cell_condition \<C>'' \<and> arity \<C>' = m \<and> center \<C>' = c 
                \<and> condition_to_set \<C>'' = condition_to_set \<C> \<inter> condition_to_set \<C>'"
proof-
  obtain l u J where luJ_def: " is_convex_condition J \<and> l \<in> carrier (SA m) \<and> u \<in> carrier (SA m) \<and>
               (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). (J (val (l x)) (val (u x)) = I (val (a1 x)) (val (a2 x)) \<inter> I' (val (a1' x)) (val (a2' x))))"
    using convex_condition_intersection[of I I' a1 m a1' a2 a2'] assms[of ] 
    by (metis (mono_tags, lifting) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5))
  obtain \<C>'' where def: "\<C>'' = Cond m (C \<inter> C') c l u J"
    by blast 
  have 0:"is_cell_condition \<C>''"
    apply(rule is_cell_conditionI)
    using assms
    unfolding def assms fibre_set.simps arity.simps center.simps l_bound.simps u_bound.simps boundary_condition.simps
        apply (meson is_cell_conditionE(1) padic_fields.intersection_is_semialg padic_fields_axioms)
    using assms padic_fields.is_cell_conditionE(2) padic_fields_axioms apply blast
    using assms luJ_def apply blast 
    using assms luJ_def apply blast 
    using assms luJ_def by blast 
  have 1: "condition_to_set \<C>'' = condition_to_set \<C> \<inter> condition_to_set \<C>'"
    unfolding assms def condition_to_set.simps 
    apply(rule equalityI')
     apply(rule IntI)
    apply(rule cell_memI) using cell_memE 
    apply blast
    using cell_memE(2) apply blast
  proof- 
    show " \<And>x. x \<in> cell m (C \<inter> C') c l u J \<Longrightarrow> val (lead_coeff x \<ominus> c (tl x)) \<in> I (val (a1 (tl x))) (val (a2 (tl x)))"
    proof-  fix x assume A: " x \<in> cell m (C \<inter> C') c l u J"
      have 0: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using A cell_memE 
        by (meson Qp_pow_ConsE(1))
      have 1: " J (val (l (tl x))) (val (u (tl x))) = I (val (a1 (tl x))) (val (a2 (tl x))) \<inter> I' (val (a1' (tl x))) (val (a2' (tl x)))"
        using "0" luJ_def by blast
      have 2: "val (lead_coeff x \<ominus> c (tl x)) \<in> I (val (a1 (tl x))) (val (a2 (tl x))) \<inter> I' (val (a1' (tl x))) (val (a2' (tl x)))"
        using luJ_def cell_memE[of x m "C \<inter> C'" c l u J] IntE unfolding 1
        using A by blast
      thus "val (lead_coeff x \<ominus> c (tl x)) \<in> I (val (a1 (tl x))) (val (a2 (tl x)))"
        by blast 
    qed
    show "\<And>x. x \<in> cell m (C \<inter> C') c l u J \<Longrightarrow> x \<in> cell m C' c a1' a2' I'"
      apply(rule cell_memI)
      using cell_memE(1) apply blast
      using cell_memE(2) apply blast
    proof- 
    show " \<And>x. x \<in> cell m (C \<inter> C') c l u J \<Longrightarrow> val (lead_coeff x \<ominus> c (tl x)) \<in> I' (val (a1' (tl x))) (val (a2' (tl x)))"
    proof-  fix x assume A: " x \<in> cell m (C \<inter> C') c l u J"
      have 0: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using A cell_memE 
        by (meson Qp_pow_ConsE(1))
      have 1: " J (val (l (tl x))) (val (u (tl x))) = I (val (a1 (tl x))) (val (a2 (tl x))) \<inter> I' (val (a1' (tl x))) (val (a2' (tl x)))"
        using "0" luJ_def by blast
      have 2: "val (lead_coeff x \<ominus> c (tl x)) \<in> I (val (a1 (tl x))) (val (a2 (tl x))) \<inter> I' (val (a1' (tl x))) (val (a2' (tl x)))"
        using luJ_def cell_memE[of x m "C \<inter> C'" c l u J] IntE unfolding 1
        using A by blast
      thus "val (lead_coeff x \<ominus> c (tl x)) \<in> I' (val (a1' (tl x))) (val (a2' (tl x)))"
        by blast 
    qed
    qed
    show "\<And>x. x \<in> cell m C c a1 a2 I \<inter> cell m C' c a1' a2' I' \<Longrightarrow> x \<in> cell m (C \<inter> C') c l u J"
      apply(rule cell_memI)
        apply (meson Int_iff cell_memE(1))
      using cell_memE(2) apply blast
    proof- 
      fix x assume A: "x \<in> cell m C c a1 a2 I \<inter> cell m C' c a1' a2' I'"
      then have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        by (meson basic_trans_rules(31) cell_subset inf_le1)
      have 0:" J (val (l (tl x))) (val (u (tl x))) = I (val (a1 (tl x))) (val (a2 (tl x))) \<inter> I' (val (a1' (tl x))) (val (a2' (tl x)))"
        using luJ_def x_closed Qp_pow_ConsE(1) by blast
      show "val (lead_coeff x \<ominus> c (tl x)) \<in> J (val (l (tl x))) (val (u (tl x)))"
        unfolding 0 using A cell_memE[of x m C' c a1' a2' I'] cell_memE[of x m C c a1 a2 I] 
        by (metis Int_iff Qp_pow_ConsE(1) luJ_def)
    qed
  qed
  show "\<exists>\<C>''. is_cell_condition \<C>'' \<and> arity \<C>' = m \<and> center \<C>' = c \<and> condition_to_set \<C>'' = condition_to_set \<C> \<inter> condition_to_set \<C>'"
    by (metis (mono_tags, opaque_lifting) "0" "1" arity.elims assms(4) cell_condition.simps(1) center.simps padic_fields.cell_condition.exhaust padic_fields.cell_condition.simps(1) padic_fields.condition_decomp' padic_fields_axioms)
qed
end

(**************************************************************************************************)
(**************************************************************************************************)
subsection\<open>Formalizing a Remark of Denef\<close>
(**************************************************************************************************)
(**************************************************************************************************)

text\<open>This section works for formalize the important remark at the beginning of Denef's proof of cell 
decomposition $II$: "We will often use without mentioning the trivial fact that a boolean 
combination of cells with the same center $c(x)$ can be partitioned into a finite number of cells 
with the same center $c(x)$."

Our proof of this fact is somewhat artificially long because it tediously proves various results in 
cases for the four different types of convexity conditions we have chosen to consider. A reworking 
of this could likely bring the line count down considerably. Denef's trivial fact is the content of 
the theorem \texttt{c\_decomposable\_is\_gen\_boolean\_algebra}. \<close>

context padic_fields
begin

lemma cell_cond_semialg:
  assumes "is_convex_condition I"
  assumes "f \<in> carrier (SA m)"
  assumes "a1 \<in> carrier (SA m)"
  assumes "a2 \<in> carrier (SA m)"
  shows "is_semialgebraic m ({a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> I (val (a1 a)) (val (a2 a))})"
proof-

  obtain \<phi> where varphi_def: "\<phi> =  (function_tuple_eval Q\<^sub>p m [a1,f,  a2])"
    by blast 
  have 0: "length [a1,f,  a2] = 3"
    by auto 
  have varphi_is_semialg_map: "is_semialg_map m 3 \<phi>"
    unfolding varphi_def apply(rule semialg_function_tuple_is_semialg_map)
    apply(rule is_semialg_function_tupleI) using assms 
    apply (metis SA_imp_semialg list.distinct(1) list.set_cases set_ConsD)
    using 0 by blast 
  show ?thesis 
  proof(rule convex_condition_induct)
    show "is_convex_condition I"
      using assms by blast 
    show " is_semialgebraic m {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_interval (val (a1 a)) (val (a2 a))}"
    proof-
      have  1: "{a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_interval (val (a1 a)) (val (a2 a))} = \<phi>  \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!0) \<le> val (as!1) \<and> val (as!1) \<le> val (as!2)}"
      proof(rule equalityI')
        show " \<And>x. x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_interval (val (a1 a)) (val (a2 a))} \<Longrightarrow> x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!0) \<le> val (as!1) \<and> val (as!1) \<le> val (as!2)}"
        proof- fix x assume A: "x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_interval (val (a1 a)) (val (a2 a))}"
          have 0: "\<phi> x = [a1 x, f x,  a2 x]"
        using A unfolding mem_Collect_eq assms varphi_def function_tuple_eval_def 
        by auto
       have 1: "\<phi> x ! 0  = a1 x"
        unfolding 0 using nth.simps 
        by (metis nth_Cons_0)
       have 2: "\<phi> x ! 1  = f x"
        unfolding 0 using nth.simps 
        by (metis cancel_comm_monoid_add_class.diff_cancel not_gr_zero nth_Cons_0 nth_Cons_pos zero_neq_one_class.one_neq_zero)
        have 00: "2 = Suc 1"
        by auto 
       have 3: "\<phi> x ! 2  = a2 x"
        unfolding 0 00 using nth.simps 
        by (metis One_nat_def nth_Cons_0 nth_Cons_Suc)
       have varphi_closed: "\<phi> x \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>)"
        using varphi_is_semialg_map A unfolding mem_Collect_eq 
        by (metis (mono_tags) PiE is_semialg_map_closed)
        have 4: "\<phi> x \<in> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!0) \<le> val (as!1) \<and> val (as!1) \<le> val (as!2)}"
        using A varphi_closed unfolding mem_Collect_eq 1 2 3 closed_interval_def by blast 
       thus "x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 0) \<le> val (as ! 1) \<and> val (as ! 1) \<le> val (as ! 2)}"
        unfolding evimage_def using A by blast
       qed
      show "\<And>x. x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 0) \<le> val (as ! 1) \<and> val (as ! 1) \<le> val (as ! 2)} \<Longrightarrow>
         x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_interval (val (a1 a)) (val (a2 a))}"
      proof fix x assume A: " x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 0) \<le> val (as ! 1) \<and> val (as ! 1) \<le> val (as ! 2)}"
      have 0: "\<phi> x = [a1 x, f x,  a2 x]"
        using A unfolding mem_Collect_eq assms varphi_def function_tuple_eval_def 
        by auto 
      have 1: "\<phi> x ! 0  = a1 x"
        unfolding 0 using nth.simps 
        by (metis nth_Cons_0)
      have 2: "\<phi> x ! 1  = f x"
        unfolding 0 using nth.simps 
        by (metis cancel_comm_monoid_add_class.diff_cancel not_gr_zero nth_Cons_0 nth_Cons_pos zero_neq_one_class.one_neq_zero)
      have 00: "2 = Suc 1"
        by auto 
      have 3: "\<phi> x ! 2  = a2 x"
        unfolding 0 00 using nth.simps 
        by (metis One_nat_def nth_Cons_0 nth_Cons_Suc)
      show "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (f x) \<in> closed_interval (val (a1 x)) (val (a2 x))"
        using A 0 1 2 3unfolding mem_Collect_eq evimage_def  
        by (metis (no_types, lifting) A closed_interval_memI evimage_eq mem_Collect_eq)
      qed
      qed
      show ?thesis unfolding 1 
        using semialg_map_evimage_is_semialg triple_val_ineq_set_semialg varphi_is_semialg_map by blast
    qed
    show "is_semialgebraic m {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> left_closed_interval (val (a1 a)) (val (a2 a))}"
    proof-
      have  1: "{a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> left_closed_interval (val (a1 a)) (val (a2 a))} = \<phi>  \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!0) \<le> val (as!1) \<and> val (as!1) < val (as!2)}"
      proof(rule equalityI')
        show " \<And>x. x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> left_closed_interval (val (a1 a)) (val (a2 a))} \<Longrightarrow> x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!0) \<le> val (as!1) \<and> val (as!1) < val (as!2)}"
        proof- fix x assume A: "x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> left_closed_interval (val (a1 a)) (val (a2 a))}"
          have 0: "\<phi> x = [a1 x, f x,  a2 x]"
        using A unfolding mem_Collect_eq assms varphi_def function_tuple_eval_def 
        by auto 
       have 1: "\<phi> x ! 0  = a1 x"
        unfolding 0 using nth.simps 
        by (metis nth_Cons_0)
       have 2: "\<phi> x ! 1  = f x"
        unfolding 0 using nth.simps 
        by (metis cancel_comm_monoid_add_class.diff_cancel not_gr_zero nth_Cons_0 nth_Cons_pos zero_neq_one_class.one_neq_zero)
        have 00: "2 = Suc 1"
        by auto 
       have 3: "\<phi> x ! 2  = a2 x"
        unfolding 0 00 using nth.simps 
        by (metis One_nat_def nth_Cons_0 nth_Cons_Suc)
       have varphi_closed: "\<phi> x \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>)"
        using varphi_is_semialg_map A unfolding mem_Collect_eq 
        by (metis (mono_tags) PiE is_semialg_map_closed)
        have 4: "\<phi> x \<in> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!0) \<le> val (as!1) \<and> val (as!1) < val (as!2)}"
        using A varphi_closed unfolding mem_Collect_eq 1 2 3 left_closed_interval_def by blast 
       thus "x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 0) \<le> val (as ! 1) \<and> val (as ! 1) <val (as ! 2)}"
        unfolding evimage_def using A by blast
       qed
      show "\<And>x. x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 0) \<le> val (as ! 1) \<and> val (as ! 1) < val (as ! 2)} \<Longrightarrow>
         x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> left_closed_interval (val (a1 a)) (val (a2 a))}"
      proof fix x assume A: " x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 0) \<le> val (as ! 1) \<and> val (as ! 1) < val (as ! 2)}"
      have 0: "\<phi> x = [a1 x, f x,  a2 x]"
        using A unfolding mem_Collect_eq assms varphi_def function_tuple_eval_def 
        by auto
      have 1: "\<phi> x ! 0  = a1 x"
        unfolding 0 using nth.simps 
        by (metis nth_Cons_0)
      have 2: "\<phi> x ! 1  = f x"
        unfolding 0 using nth.simps 
        by (metis cancel_comm_monoid_add_class.diff_cancel not_gr_zero nth_Cons_0 nth_Cons_pos zero_neq_one_class.one_neq_zero)
      have 00: "2 = Suc 1"
        by auto 
      have 3: "\<phi> x ! 2  = a2 x"
        unfolding 0 00 using nth.simps 
        by (metis One_nat_def nth_Cons_0 nth_Cons_Suc)
      show "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (f x) \<in> left_closed_interval (val (a1 x)) (val (a2 x))"
        using A 0 1 2 3 unfolding mem_Collect_eq evimage_def  
        by (metis (no_types, lifting) A left_closed_interval_memI evimage_eq mem_Collect_eq)
      qed
      qed
      show ?thesis unfolding 1 
        using semialg_map_evimage_is_semialg triple_val_ineq_set_semialg' varphi_is_semialg_map by blast
    qed
    show "is_semialgebraic m {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_ray (val (a1 a)) (val (a2 a))}"
        proof-
      have  1: "{a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_ray (val (a1 a)) (val (a2 a))} = \<phi>  \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!1) \<le> val (as!2)}"
      proof(rule equalityI')
        show " \<And>x. x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_ray (val (a1 a)) (val (a2 a))} \<Longrightarrow> x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!1) \<le> val (as!2)}"
        proof- fix x assume A: "x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_ray (val (a1 a)) (val (a2 a))}"
          have 0: "\<phi> x = [a1 x, f x,  a2 x]"
        using A unfolding mem_Collect_eq assms varphi_def function_tuple_eval_def 
        by auto 
       have 1: "\<phi> x ! 0  = a1 x"
        unfolding 0 using nth.simps 
        by (metis nth_Cons_0)
       have 2: "\<phi> x ! 1  = f x"
        unfolding 0 using nth.simps 
        by (metis cancel_comm_monoid_add_class.diff_cancel not_gr_zero nth_Cons_0 nth_Cons_pos zero_neq_one_class.one_neq_zero)
        have 00: "2 = Suc 1"
        by auto 
       have 3: "\<phi> x ! 2  = a2 x"
        unfolding 0 00 using nth.simps 
        by (metis One_nat_def nth_Cons_0 nth_Cons_Suc)
       have varphi_closed: "\<phi> x \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>)"
        using varphi_is_semialg_map A unfolding mem_Collect_eq 
        by (metis (mono_tags) PiE is_semialg_map_closed)
        have 4: "\<phi> x \<in> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!1) \<le>  val (as!2)}"
        using A varphi_closed unfolding mem_Collect_eq 1 2 3 closed_ray_def by blast 
       thus "x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 1) \<le> val (as ! 2)}"
        unfolding evimage_def using A by blast
        qed
      show "\<And>x. x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 1) \<le> val (as ! 2)} \<Longrightarrow>
         x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> closed_ray (val (a1 a)) (val (a2 a))}"
      proof fix x assume A: " x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 1) \<le> val (as ! 2)}"
      have 0: "\<phi> x = [a1 x, f x,  a2 x]"
        using A unfolding mem_Collect_eq assms varphi_def function_tuple_eval_def 
        by auto 
      have 1: "\<phi> x ! 0  = a1 x"
        unfolding 0 using nth.simps 
        by (metis nth_Cons_0)
      have 2: "\<phi> x ! 1  = f x"
        unfolding 0 using nth.simps 
        by (metis cancel_comm_monoid_add_class.diff_cancel not_gr_zero nth_Cons_0 nth_Cons_pos zero_neq_one_class.one_neq_zero)
      have 00: "2 = Suc 1"
        by auto 
      have 3: "\<phi> x ! 2  = a2 x"
        unfolding 0 00 using nth.simps 
        by (metis One_nat_def nth_Cons_0 nth_Cons_Suc)
      show "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (f x) \<in> closed_ray (val (a1 x)) (val (a2 x))"
        using A 0 1 2 3 unfolding mem_Collect_eq evimage_def  
        by (metis (no_types, lifting) A closed_ray_memI evimage_eq mem_Collect_eq)
      qed
      qed
      show ?thesis unfolding 1
        using semialg_map_evimage_is_semialg reverse_val_relation_set_semialg  varphi_is_semialg_map triple_val_ineq_set_semialg''' by blast
    qed
    show "is_semialgebraic m {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> open_ray (val (a1 a)) (val (a2 a))}"
        proof-
      have  1: "{a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> open_ray (val (a1 a)) (val (a2 a))} = \<phi>  \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!1) < val (as!2)}"
      proof(rule equalityI')
        show " \<And>x. x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> open_ray (val (a1 a)) (val (a2 a))} \<Longrightarrow> x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!1) < val (as!2)}"
        proof- fix x assume A: "x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> open_ray (val (a1 a)) (val (a2 a))}"
          have 0: "\<phi> x = [a1 x, f x,  a2 x]"
        using A unfolding mem_Collect_eq assms varphi_def function_tuple_eval_def 
        by auto 
       have 1: "\<phi> x ! 0  = a1 x"
        unfolding 0 using nth.simps 
        by (metis nth_Cons_0)
       have 2: "\<phi> x ! 1  = f x"
        unfolding 0 using nth.simps 
        by (metis cancel_comm_monoid_add_class.diff_cancel not_gr_zero nth_Cons_0 nth_Cons_pos zero_neq_one_class.one_neq_zero)
        have 00: "2 = Suc 1"
        by auto 
       have 3: "\<phi> x ! 2  = a2 x"
        unfolding 0 00 using nth.simps 
        by (metis One_nat_def nth_Cons_0 nth_Cons_Suc)
       have varphi_closed: "\<phi> x \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>)"
        using varphi_is_semialg_map A unfolding mem_Collect_eq 
        by (metis (mono_tags) PiE is_semialg_map_closed)
        have 4: "\<phi> x \<in> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as!1) <  val (as!2)}"
        using A varphi_closed unfolding mem_Collect_eq 1 2 3 open_ray_def by blast 
       thus "x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 1) < val (as ! 2)}"
        unfolding evimage_def using A by blast
        qed
      show "\<And>x. x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 1) < val (as ! 2)} \<Longrightarrow>
         x \<in> {a \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f a) \<in> open_ray (val (a1 a)) (val (a2 a))}"
      proof fix x assume A: " x \<in> \<phi> \<inverse>\<^bsub>m\<^esub> {as \<in> carrier (Q\<^sub>p\<^bsup>3\<^esup>). val (as ! 1) < val (as ! 2)}"
      have 0: "\<phi> x = [a1 x, f x,  a2 x]"
        using A unfolding mem_Collect_eq assms varphi_def function_tuple_eval_def 
        by auto 
      have 1: "\<phi> x ! 0  = a1 x"
        unfolding 0 using nth.simps 
        by (metis nth_Cons_0)
      have 2: "\<phi> x ! 1  = f x"
        unfolding 0 using nth.simps 
        by (metis cancel_comm_monoid_add_class.diff_cancel not_gr_zero nth_Cons_0 nth_Cons_pos zero_neq_one_class.one_neq_zero)
      have 00: "2 = Suc 1"
        by auto 
      have 3: "\<phi> x ! 2  = a2 x"
        unfolding 0 00 using nth.simps 
        by (metis One_nat_def nth_Cons_0 nth_Cons_Suc)
      show "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (f x) \<in> open_ray (val (a1 x)) (val (a2 x))"
        using A 0 1 2 3 unfolding mem_Collect_eq evimage_def  
        by (metis (no_types, lifting) A open_ray_memI evimage_eq mem_Collect_eq)
      qed
      qed
      show ?thesis unfolding 1 
        using semialg_map_evimage_is_semialg triple_val_ineq_set_semialg'' varphi_is_semialg_map by blast
    qed
  qed
qed

lemma condition_to_set_is_semialgebraic:
  assumes "is_cell_condition \<C>"
  shows "is_semialgebraic (Suc (arity \<C>)) (condition_to_set \<C>)"  
proof-
  obtain m C c a1 a2 I where conds: "\<C> = Cond m C c a1 a2 I"
    using arity.cases by blast
  have 0: "are_cell_condition_params m C c a1 a2 I"
    using assms conds by blast
  have 1: "(condition_to_set \<C>) = {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> C \<and> val (hd as \<ominus> c (tl as)) \<in> I (val (a1 (tl as))) (val (a2 (tl as)))}"
    using 0 
    unfolding conds condition_to_set.simps unfolding cell_def by blast 
  have c_closed: "c \<in> carrier (SA m)"
    using 0 assms conds is_cell_condition.simps by blast
  have a1_closed: "a1 \<in> carrier (SA m)"
    using 0 assms conds is_cell_condition.simps by blast
  have a2_closed: "a2 \<in> carrier (SA m)"
    using 0 assms conds is_cell_condition.simps by blast
  have 2: "(\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). c (tl x)) \<in> carrier (SA (Suc m))"
  proof-
    have 20:"(\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). c (tl x)) = restrict (c \<circ> tl) (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
      by (metis o_def)
    show ?thesis unfolding 20 
      using c_closed tl_is_semialg_map[of m] 
      by (metis SA_car padic_fields.SA_car_memE(1) padic_fields_axioms restrict_in_semialg_functions semialg_function_comp_closed tl_is_semialg_map)
  qed  
  obtain f where f_def: "f = ext_hd (Suc m) \<ominus>\<^bsub>SA (Suc m)\<^esub> (\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). c (tl x))"
    by blast 
  have f_closed: "f \<in> carrier (SA (Suc m))"
    unfolding f_def using 2 ext_hd_closed[of "Suc m"] 
    by blast
  have f_eval: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> f x = hd x \<ominus> c (tl x)"
  proof- fix x assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
    have "(ext_hd (Suc m) \<ominus>\<^bsub>SA (Suc m)\<^esub> (\<lambda>x\<in>carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). c (tl x))) x = ext_hd (Suc m) x \<ominus> (\<lambda>x\<in>carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). c (tl x)) x"
    unfolding f_def using A ext_hd_closed[of "Suc m"] 2   SA_minus_eval[of "ext_hd (Suc m)" "Suc m" "(\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). c (tl x))" x]
    by blast
    then show "f x = hd x \<ominus> c (tl x)"
    unfolding f_def using A ext_hd_closed[of "Suc m"] 2   SA_minus_eval[of "ext_hd (Suc m)" "Suc m" "(\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). c (tl x))" x]
    unfolding ext_hd_def restrict_def 
    by presburger
  qed

  have 2: "(condition_to_set \<C>) = {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> C \<and> val (f as) \<in> I (val (a1 (tl as))) (val (a2 (tl as)))}"
    using 1 f_eval by auto 
  obtain b1 where b1_def: "b1 = (\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). a1 (tl x))"
    by blast 
  have b1_closed: "b1 \<in> carrier (SA (Suc m))"
  proof-
    have 20:"(\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). a1 (tl x)) = restrict (a1 \<circ> tl) (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
      by (metis o_def)
    show ?thesis unfolding 20 
      using 20 tl_is_semialg_map[of m] a1_closed unfolding b1_def  using tl_comp_in_SA by blast
  qed
  obtain b2 where b2_def: "b2 = (\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). a2 (tl x))"
    by blast 
  have b2_closed: "b2 \<in> carrier (SA (Suc m))"
  proof-
    have 20:"(\<lambda>x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). a2 (tl x)) = restrict (a2 \<circ> tl) (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
      by (metis o_def)
    show ?thesis unfolding 20 
      using 20 tl_is_semialg_map[of m] a2_closed unfolding b2_def  using tl_comp_in_SA by blast
  qed
  have 2: "(condition_to_set \<C>) = {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> C \<and> val (f as) \<in> I (val (b1 as)) (val (b2 as))}"
    using 2 b1_closed b2_closed b1_def b2_def unfolding restrict_def  
    by auto 
  have 3: "(condition_to_set \<C>) = {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> C} \<inter> {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). val (f as) \<in> I (val (b1 as)) (val (b2 as))}"
    unfolding 2 by blast
  have 4: "is_semialgebraic (Suc m) {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> C}"
  proof-
    have 40: "{as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> C} = tl  \<inverse>\<^bsub>Suc m\<^esub> C"
      by(unfold evimage_def, auto )
    have 41: "is_semialgebraic m C"
      using 0  is_cell_conditionE''(1) by blast
    show ?thesis 
      unfolding 40 using  41  tl_is_semialg_map[of m] semialg_map_evimage_is_semialg by blast
  qed
  have 5: "is_convex_condition I"
    using 0  is_cell_conditionE(5) by blast
  have 6: "arity \<C> = m"
    using 0  arity.simps conds by blast    
  have 5: "is_semialgebraic (Suc m) {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). val (f as) \<in> I (val (b1 as)) (val (b2 as))}"
    using cell_cond_semialg[of I f "Suc m" b1 b2] "5" b1_closed b2_closed f_closed by blast
  show ?thesis unfolding 3 6 using  4 5 intersection_is_semialg by blast  
qed

text\<open>This predicate identifies those subsets of $\mathbb{Q}_p^{m+1}$ which can be decomposed into 
cells, all with the common center $c$.\<close>
definition is_c_decomposable where
"is_c_decomposable m c Y = (\<exists>S. S \<noteq> {} \<and> is_cell_decomp m S Y \<and> (\<forall>C. C \<in> S \<longrightarrow>  center C = c))"

lemma is_c_decomposableE:
  assumes "is_c_decomposable m c Y"
  shows "\<exists>S. S \<noteq> {}  \<and>  is_cell_decomp m S Y \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
        "c \<in> carrier (SA m)"
        "is_semialgebraic (Suc m) Y"
  using assms is_c_decomposable_def apply blast
proof- 
  obtain S where S_def: "S \<noteq> {} \<and> is_cell_decomp m S Y \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
  by (meson assms is_c_decomposable_def)
  obtain C where C_def: "C \<in> S"
    using S_def 
    by blast
  have "center C \<in> carrier (SA m)"
    by (metis C_def S_def is_cell_conditionE''(5) is_cell_decompE(4) padic_fields.condition_decomp' padic_fields.is_cell_decompE(3) padic_fields_axioms)
  have "\<And>C. C \<in> S \<Longrightarrow> is_semialgebraic (Suc m) (condition_to_set C)"
    using S_def is_cell_decompE(3)[of m S Y] is_cell_conditionE 
    by (metis condition_to_set_is_semialgebraic padic_fields.is_cell_decompE(4) padic_fields_axioms)
  hence 0: "is_semialgebraic (Suc m) (\<Union> C \<in> S. condition_to_set C)"
    by (meson S_def finite_union_is_semialgebraic'' is_cell_decompE(1))     
  have 1: "\<Union> (condition_to_set ` S) = Y"
    using S_def is_cell_decompE(2)[of m S Y] is_partitionE(2)[of "condition_to_set ` S" Y] by blast 
  then show "is_semialgebraic (Suc m) Y"
    using 0 unfolding 1 by blast 
  show "c \<in> carrier (SA m)"
  proof-
    have "c = center C"
      using C_def  S_def by blast
    then show ?thesis 
      using \<open>center C \<in> carrier (SA m)\<close> by blast
  qed
qed

lemma is_c_decomposableI:
  assumes "S \<noteq> {}"
  assumes "is_cell_decomp m S Y \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
  shows "is_c_decomposable m c Y"
  unfolding is_c_decomposable_def using assms 
  by blast

definition is_c_cell where
"is_c_cell m c Y =  (\<exists>\<C>. is_cell_condition \<C> \<and> arity \<C> = m \<and> center \<C> = c \<and> Y = condition_to_set \<C>)"

definition c_cells ("Cells\<^bsub>_, _\<^esub>(_)") where 
"c_cells m c C = {Y. is_c_cell m c Y \<and> Y \<subseteq> C}"

definition c_decomposables where 
"c_decomposables m c C = {Y. is_c_decomposable m c Y \<and> Y \<subseteq> C}"

lemma c_decomposables_closed: 
  assumes "A \<in> c_decomposables m c C"
  shows "A \<subseteq> C"
  using assms unfolding c_decomposables_def is_c_decomposable_def 
  by blast 

lemma c_cell_is_c_decomposable:
  assumes "is_cell_condition (Cond m C c a b I)"
  shows "is_c_decomposable m c (condition_to_set (Cond m C c a b I))"
  apply(rule is_c_decomposableI[of "{(Cond m C c a b I)}"]) 
   apply blast 
proof
  show "is_cell_decomp m {Cond m C c a b I} (condition_to_set (Cond m C c a b I))"
    apply(rule is_cell_decompI) 
    apply blast
       apply(rule is_partitionI) 
    apply(rule disjointI) 
    apply blast
    apply blast
    using arity.simps assms apply blast
    unfolding condition_to_set.simps cell_def apply blast 
    by blast 
  show "\<forall>Ca. Ca \<in> {Cond m C c a b I} \<longrightarrow> center Ca = c"
    using center.simps by blast 
qed

lemma boolean_algebra_alt_induct:
assumes " A \<in> gen_boolean_algebra S B"
assumes "P S"
assumes "\<And>A. A \<in> B \<Longrightarrow> P (A \<inter> S)"
assumes "\<And> A C.  A \<in> gen_boolean_algebra S B \<Longrightarrow> C \<in> gen_boolean_algebra S B \<Longrightarrow> P A \<Longrightarrow> P C \<Longrightarrow> A \<inter> C = {} \<Longrightarrow>  P (A \<union> C)"
assumes "\<And> A C.  A \<in> gen_boolean_algebra S B \<Longrightarrow> C \<in> gen_boolean_algebra S B \<Longrightarrow> P A \<Longrightarrow> P C \<Longrightarrow> P (A - C)"
shows "P A"
  apply(rule gen_boolean_algebra.induct[of A S B])
  using assms apply blast 
  using assms apply blast 
  using assms apply blast 
proof- 
  show "\<And>A C. A \<in> gen_boolean_algebra S B \<Longrightarrow> P A \<Longrightarrow> C \<in> gen_boolean_algebra S B \<Longrightarrow> P C \<Longrightarrow> P (A \<union> C)"
  proof- fix A C assume A: "A \<in> gen_boolean_algebra S B" "P A" "C \<in> gen_boolean_algebra S B" "P C"
    show " P (A \<union> C)"
    proof- 
      have 0: "P (S - A)"
        using assms(5)[of S A] assms  A(1) A(2) gen_boolean_algebra.simps by blast
      have 1: "P (S - C)"
        by (simp add: A(3) A(4) assms(2) assms(5) gen_boolean_algebra.intros(1))
      have 2: "P ((S - A) \<union> (A - C))"
        apply(rule assms(4)) 
        using A(1) gen_boolean_algebra.intros(4) apply blast
        using A(1) A(3) gen_boolean_algebra_diff apply blast
        apply (simp add: "0")
        apply (simp add: A(1) A(2) A(3) A(4) assms(5))
        by blast   
      have 3: "P (S - ((S - A) \<union> (A - C)))"
        using 2 assms(5)[of S "(S - A \<union> (A - C))"] 
        by (meson A(1) A(3) assms(2) gen_boolean_algebra.simps gen_boolean_algebra_diff)
      have 4: "A \<subseteq> S"
        using A(1) gen_boolean_algebra_subset by blast
      have 5: "C \<subseteq> S"
        using A(3) gen_boolean_algebra_subset by blast
      have 6: "S - ((S - A) \<union> (A - C)) = S - ((S - A) \<union> (S - C))" 
        using 4 5 by blast 
      have 7: "S - ((S - A) \<union> (A - C)) = A \<inter> C" unfolding 6 using 4 5 by blast 
      have 8: "P (A \<inter> C)" using 3 unfolding 7 by blast 
      have 9: "P ((A \<inter> C) \<union> ((A - C) \<union> (C - A)))"
        apply(rule assms(4)) 
        using A(1) A(3) gen_boolean_algebra_intersect apply blast
           apply(rule gen_boolean_algebra.intros(3)[of "A - C" S B "C - A"])
        using A A(1) A(3) gen_boolean_algebra_diff apply blast
        using A A(1) A(3) gen_boolean_algebra_diff apply blast
        using 8 apply blast 
         apply(rule assms(4)) 
        using A A(1) A(3) gen_boolean_algebra_diff apply blast
        using A A(1) A(3) gen_boolean_algebra_diff apply blast
        using assms A A(1) A(3) gen_boolean_algebra_diff apply blast
        using assms A A(1) A(3) gen_boolean_algebra_diff apply blast
        apply blast 
        by blast 
      have 10: "((A \<inter> C) \<union> ((A - C) \<union> (C - A))) = A \<union> C"
        by blast 
      show ?thesis using 9 unfolding 10 by blast 
    qed
  qed
  show "\<And>A. A \<in> gen_boolean_algebra S B \<Longrightarrow> P A \<Longrightarrow> P (S - A)"
    using assms(2) assms(5) gen_boolean_algebra.intros(1) by blast
qed

lemma empty_in_cells:
  assumes "is_semialgebraic m C"
  assumes "c \<in> carrier (SA m)"
  shows "{} \<in> Cells\<^bsub>m,c\<^esub>(C)"
proof- 
  obtain a where a_def: "a \<in> carrier (SA m)"
    by blast 
  obtain \<C> where \<C>_def: "\<C> = Cond m C c a a left_closed_interval"
    by blast 
  have 0: "is_cell_condition \<C>" unfolding \<C>_def 
    apply(rule is_cell_conditionI') 
        apply (simp add: assms(1))
      using assms(2) apply linarith
      using a_def apply blast
      using a_def apply blast
      unfolding is_convex_condition_def by blast 
  have 1: "condition_to_set \<C> = {}"
    unfolding \<C>_def condition_to_set.simps cell_def left_closed_interval_def 
    apply(rule equalityI') unfolding mem_Collect_eq 
    using notin_closed apply blast
    by blast 
  show ?thesis unfolding c_cells_def is_c_cell_def using 0 1 \<C>_def 
    by (metis (mono_tags, lifting) arity.simps center.simps empty_subsetI mem_Collect_eq)
qed

lemma SA_min_fun:
  assumes "a \<in> carrier (SA m)"
  assumes "b \<in> carrier (SA m)"
  shows "\<exists>c \<in> carrier (SA m). (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (c x) = min (val (a x)) (val (b x)))"
proof- 
  obtain c where c_def: "c = fun_glue m {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) < val (b x)} a b"
    by blast 
  have "c \<in> carrier (SA m)"
    unfolding c_def apply(rule fun_glue_closed)
    using assms apply blast 
    using assms apply blast 
    using assms semialg_val_strict_ineq_set_is_semialg by blast
  have "\<forall>x\<in>carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (c x) = min (val (a x)) (val (b x))"
  proof fix x assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    show "val (c x) = min (val (a x)) (val (b x))"
    proof(cases "x \<in>  {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) < val (b x)}")
      case True
      then show ?thesis 
        unfolding c_def mem_Collect_eq 
        using fun_glueE[of a m b "{x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) < val (b x)}" x] 
      proof -
        assume a1: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (a x) < val (b x)"
        have "fun_glue m {rs \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a rs) < val (b rs)} a b x = a x"
          using True \<open>\<lbrakk>a \<in> carrier (SA m); b \<in> carrier (SA m); {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) < val (b x)} \<subseteq> carrier (Q\<^sub>p\<^bsup>m\<^esup>); x \<in> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) < val (b x)}\<rbrakk> \<Longrightarrow> fun_glue m {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) < val (b x)} a b x = a x\<close> assms(1) assms(2) by blast
        then show "val (fun_glue m {rs \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a rs) < val (b rs)} a b x) = min (val (a x)) (val (b x))"
          using a1 by (metis min.strict_order_iff)
      qed
    next
      case False
      then have F0: "val (b x) \<le> val (a x)"
        unfolding mem_Collect_eq using A not_le by blast
      hence " fun_glue m {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) < val (b x)} a b x = b x"
        using assms False A fun_glueE'[of a m b "{x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) < val (b x)}" x]
        unfolding c_def  
        by blast
      thus ?thesis using F0   
        by (metis c_def min.absorb2)
    qed
  qed
  thus ?thesis 
    using \<open>c \<in> carrier (SA m)\<close> by blast
qed

lemma SA_max_fun:
  assumes "a \<in> carrier (SA m)"
  assumes "b \<in> carrier (SA m)"
  shows "\<exists>c \<in> carrier (SA m). (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (c x) = max (val (a x)) (val (b x)))"
proof- 
  obtain c where c_def: "c = fun_glue m {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) > val (b x)} a b"
    by blast 
  have "c \<in> carrier (SA m)"
    unfolding c_def apply(rule fun_glue_closed)
    using assms apply blast 
    using assms apply blast 
    using assms semialg_val_strict_ineq_set_is_semialg by blast
  have "\<forall>x\<in>carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (c x) = max (val (a x)) (val (b x))"
  proof fix x assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    show "val (c x) = max (val (a x)) (val (b x))"
    proof(cases "x \<in>  {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) > val (b x)}")
      case True
      then show ?thesis 
        unfolding c_def mem_Collect_eq 
        using fun_glueE[of a m b "{x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) > val (b x)}" x] 
      proof -
        assume a1: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<and> val (a x) >val (b x)"
        have "fun_glue m {rs \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a rs) >val (b rs)} a b x = a x"
          using True \<open>\<lbrakk>a \<in> carrier (SA m); b \<in> carrier (SA m); {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) > val (b x)} \<subseteq> carrier (Q\<^sub>p\<^bsup>m\<^esup>); x \<in> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) > val (b x)}\<rbrakk> \<Longrightarrow> fun_glue m {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) > val (b x)} a b x = a x\<close> assms(1) assms(2) by blast
        then show "val (fun_glue m {rs \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a rs) > val (b rs)} a b x) = max (val (a x)) (val (b x))"
          using a1 by (metis max.strict_order_iff)
      qed
    next
      case False
      then have F0: "val (b x) \<ge> val (a x)"
        unfolding mem_Collect_eq using A not_le by blast
      hence " fun_glue m {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) > val (b x)} a b x = b x"
        using assms False A fun_glueE'[of a m b "{x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (a x) > val (b x)}" x]
        unfolding c_def  
        by blast
      thus ?thesis using F0   
        by (metis c_def max.absorb2)
    qed
  qed
  thus ?thesis 
    using \<open>c \<in> carrier (SA m)\<close> by blast
qed

lemma SA_Suc_fun:
  assumes "a \<in> carrier (SA m)"
  shows "\<exists>b \<in> carrier (SA m). (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (b x) = val (a x) + 1)"
  using assms p_mult_function_val[of a m]  
  using Qp.int_inc_closed SA_smult_closed by blast

lemma c_decomposable_disjoint_union:
  assumes "is_c_decomposable m c A"
  assumes "is_c_decomposable m c B"
  assumes "A \<inter> B = {}"
  shows "is_c_decomposable m c (A \<union> B)"
proof-
          obtain S where S_def: "S \<noteq> {} \<and> is_cell_decomp m S A \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
            using assms unfolding mem_Collect_eq using is_c_decomposableE[of m c A] 
            by blast
          obtain S' where S'_def: "S' \<noteq> {} \<and>is_cell_decomp m S' B \<and> (\<forall>C. C \<in> S' \<longrightarrow> center C = c)"
            using assms unfolding c_decomposables_def mem_Collect_eq using is_c_decomposableE[of m c B] 
            by blast
          have 0: "A \<union> B - A = B"
            using assms by blast 
          have 1: "is_cell_decomp m (S \<union> S') (A \<union> B)"
            apply(rule cell_decomp_union[of "A"]) 
               apply blast 
            using assms 0 apply (meson S'_def S_def Un_subset_iff is_cell_decompE(6))
            using S_def apply blast
            using S'_def unfolding 0 by blast 
          show "is_c_decomposable m c (A \<union> B)"
            apply(rule is_c_decomposableI[of "S \<union> S'"])
            using  S_def apply blast 
            using 1 S_def S'_def by blast 
qed

lemma change_of_fibres:
  assumes "is_cell_condition (Cond m C c a b I)"
  assumes "is_semialgebraic m A"
  shows "is_cell_condition (Cond m A c a b I)"
  apply(rule is_cell_conditionI')
  using assms apply blast 
  using assms is_cell_conditionE apply blast 
  using assms is_cell_conditionE apply blast 
  using assms is_cell_conditionE apply meson
  using assms is_cell_conditionE by meson

lemma disjoint_fibres:
  assumes "is_cell_condition (Cond m C c a b I)"
  assumes "is_cell_condition (Cond m A c' d e J)"
  assumes "C \<inter> A = {}"
  shows "condition_to_set (Cond m C c a b I) \<inter> condition_to_set (Cond m A c' d e J) = {}"
  unfolding condition_to_set.simps cell_def  using assms by blast 

lemma union_fibres:
  assumes "is_cell_condition (Cond m C c a b I)"
  assumes "is_cell_condition (Cond m A c a b I)"
  shows "condition_to_set (Cond m (C \<union> A) c a b I) = condition_to_set (Cond m C c a b I) \<union> condition_to_set (Cond m A c a b I)"
  unfolding condition_to_set.simps cell_def by blast 
 
lemma closed_interval_minus_left_closed_interval_cell_diff0:
  assumes "\<C> = Cond m A cent a b closed_interval"
  assumes "\<C>' = Cond m B cent c d left_closed_interval"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  assumes "\<forall>x \<in> B. val (c x) \<le> val (d x)"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof-
  have a_closed: "a \<in> carrier (SA m)"
    using assms is_cell_conditionE 
    by meson
  have b_closed: "b \<in> carrier (SA m)"
    using assms is_cell_conditionE 
    by meson
  have c_closed: "c \<in> carrier (SA m)"
    using assms is_cell_conditionE 
    by meson
  have d_closed: "d \<in> carrier (SA m)"
    using assms is_cell_conditionE 
    by meson
  obtain b' where b'_def: "b' \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (b' x) = val (b x) + 1)"
    using b_closed SA_Suc_fun 
    by metis
  obtain mi where mi_def: "mi \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (mi x) = min (val (b' x)) (val (c x)))"
    using b'_def c_closed SA_min_fun 
    by (metis (no_types, lifting))
  have mi_val: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<Longrightarrow> val (mi x) = min (val (b x) + 1) (val (c x))"
    using mi_def b'_def c_closed  
    by metis
  obtain ma where ma_def: "ma \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (ma x) = max (val (a x)) (val (d x)))"
    using a_closed d_closed SA_max_fun 
    by (metis (no_types, opaque_lifting))
  have ma_val: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<Longrightarrow> val (ma x) = max (val (a x)) (val (d x))"
    using ma_def a_closed b_closed  
    by blast
  have 0: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<Longrightarrow> 
  closed_interval (val (a x)) (val (b x)) - left_closed_interval (val (c x)) (val (d x)) = left_closed_interval (val (a x)) (min (val (b x) + 1) (val (c x))) \<union> closed_interval (max (val (a x)) (val (d x))) (val (b x))"
  proof- fix x assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)" 
    then show "closed_interval (val (a x)) (val (b x)) - left_closed_interval (val (c x)) (val (d x)) = left_closed_interval (val (a x)) (min (val (b x) + 1) (val (c x))) \<union> closed_interval (max (val (a x)) (val (d x))) (val (b x))"
    using closed_interval_minus_left_closed_interval'[of _ "val (a x)" "val (b x)" _ "val (c x)" "val (d x)"] 
    by blast 
  qed
  have 1: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<Longrightarrow> 
  closed_interval (val (a x)) (val (b x)) - left_closed_interval (val (c x)) (val (d x)) = left_closed_interval (val (a x)) (val (mi x)) \<union> closed_interval (val (ma x)) (val (b x))"
  proof- fix x  assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)" 
    have 10: " val (ma x) = max (val (a x)) (val (d x))"
      using A  ma_val by blast 
    have 11: "val (mi x) = min (val (b x) + 1) (val (c x))"
      using A mi_val by blast 
    show " closed_interval (val (a x)) (val (b x)) - left_closed_interval (val (c x)) (val (d x)) = left_closed_interval (val (a x)) (val (mi x)) \<union> closed_interval (val (ma x)) (val (b x))"
      using A 0[of  x] unfolding 10 11 by blast    
  qed
  have 2: "is_semialgebraic m A"
    using assms is_cell_conditionE by blast 
  have 3: "is_semialgebraic m B"
    using assms is_cell_conditionE by blast
  obtain C0 where C0_def: "C0 = Cond m (A \<inter> B) cent a mi left_closed_interval"
    by blast
  obtain C1 where C1_def: "C1 = Cond m (A \<inter> B) cent ma b closed_interval"
    by blast
  obtain C2 where C2_def: "C2 = Cond m (A - B) cent a b closed_interval"
    by blast
  have 4: "is_cell_condition C0" unfolding C0_def 
    apply(rule is_cell_conditionI')  
    using 2 3 intersection_is_semialg apply blast
    using assms is_cell_conditionE apply blast
    using a_closed apply blast 
    using mi_def apply blast 
    unfolding is_convex_condition_def by blast 
  have 5: "is_cell_condition C1" unfolding C1_def 
    apply(rule is_cell_conditionI')  
    using 2 3 intersection_is_semialg apply blast
    using assms is_cell_conditionE apply blast
    using ma_def apply blast 
    using b_closed apply blast 
    unfolding is_convex_condition_def by blast 
  have 6: "is_cell_condition C2" unfolding C2_def 
    apply(rule is_cell_conditionI')  
    using 2 3 diff_is_semialgebraic apply blast
    using assms is_cell_conditionE apply blast
    using a_closed apply blast 
    using b_closed apply blast 
    unfolding is_convex_condition_def by blast 
  have 7: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set C0 \<union> condition_to_set C1 \<union> condition_to_set C2"
  proof(rule equalityI')
    show "\<And>x. x \<in> condition_to_set \<C> - condition_to_set \<C>' \<Longrightarrow> x \<in> condition_to_set C0 \<union> condition_to_set C1 \<union> condition_to_set C2"
    proof fix x assume A: "x \<in> condition_to_set \<C> - condition_to_set \<C>'" "x \<notin> condition_to_set C2"
      show " x \<in> condition_to_set C0 \<union> condition_to_set C1"
      proof assume  B: "x \<notin> condition_to_set C1" 
        show "x \<in> condition_to_set C0"
        proof- 
          have 7: "tl x \<in> A"
            using A condition_to_set_memE unfolding assms cell_def 
            using assms(1) assms(5) by blast
          have 8: "val (hd x \<ominus> (cent (tl x))) \<in> closed_interval (val (a (tl x))) (val (b (tl x)))"
            using assms  A condition_to_set_memE(2) unfolding assms cell_def 
            using assms by blast
          have 9: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
            using A unfolding assms condition_to_set.simps cell_def 
            by (metis (no_types, lifting) Diff_iff cartesian_power_tail mem_Collect_eq)
          have 10: "tl x \<notin> (A  - B)"
            using 8 9 1[of "tl x"] A unfolding  condition_to_set.simps cell_def  
            by (metis C2_def Diff_iff assms(1) assms(5) cell_condition_set_memE(1) cell_condition_set_memI)
          then have 11: "tl x \<in> B"
            using 7 by blast 
          have 12: "val (hd x \<ominus> (cent (tl x))) \<notin> left_closed_interval (val (c (tl x))) (val (d (tl x)))"
            using A 11 unfolding condition_to_set.simps cell_def assms by blast 
          hence 13: "val (hd x \<ominus> (cent (tl x))) \<in> closed_interval (val (a (tl x))) (val (b (tl x))) - left_closed_interval (val (c (tl x))) (val (d (tl x)))"
            using 8  by blast 
          hence 14: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x))) \<union> closed_interval (val (ma (tl x))) (val (b (tl x)))"
            using 8  1[of "tl x"] 9 by blast 
          have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
            using A  unfolding assms condition_to_set.simps cell_def by blast 
          have 15: "tl x \<in> A \<inter> B"
            using "11" "7" by blast
          hence 16: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x)))"
            using 15 14 B 11 7 x_closed unfolding C1_def assms  condition_to_set.simps cell_def mem_Collect_eq 
            by blast
          show "x \<in> condition_to_set C0"
            unfolding condition_to_set.simps C0_def apply(rule cell_memI) 
            using x_closed apply linarith
            using "15" apply blast
            using "16" by blast
        qed
      qed
    qed
    show "\<And>x. x \<in> condition_to_set C0 \<union> condition_to_set C1 \<union> condition_to_set C2 \<Longrightarrow> x \<in> condition_to_set \<C> - condition_to_set \<C>'"
    proof- fix x assume A: "x \<in> condition_to_set C0 \<union> condition_to_set C1 \<union> condition_to_set C2"
      have  0: " closed_interval (val (a (tl x))) (val (b (tl x))) - left_closed_interval (val (c (tl x))) (val (d (tl x))) = left_closed_interval (val (a (tl x))) (val (mi (tl x))) \<union> closed_interval (val (ma (tl x))) (val (b (tl x)))"
        using 1 A unfolding C0_def C1_def C2_def condition_to_set.simps cell_def 
        using Qp_pow_ConsE(1) by blast
      show "x \<in> condition_to_set \<C> - condition_to_set \<C>'"
      proof 
        show "x \<in> condition_to_set \<C>"
          apply(cases "x \<in> condition_to_set C0")
          unfolding C0_def condition_to_set.simps assms 
           apply(rule cell_memI) 
          using cell_memE apply blast 
          using cell_memE apply blast
          using 0 cell_memE 
          apply (metis Diff_iff Int_iff inf_sup_absorb)
          unfolding C0_def condition_to_set.simps assms 
          apply(cases "x \<in> condition_to_set C1")
           apply(rule cell_memI) 
          using 1 A unfolding C0_def C1_def C2_def condition_to_set.simps cell_def apply blast 
          using cell_memE A unfolding mem_Collect_eq apply blast
          using 0 cell_memE apply blast
        proof- 
          assume A' : " \<not> (x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<and> tl x \<in> A \<inter> B \<and> val (hd x \<ominus> cent (tl x)) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x))))"
                      " \<not> (x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<and> tl x \<in> A \<inter> B \<and> val (hd x \<ominus> cent (tl x)) \<in> I[val (ma (tl x)) val (b (tl x))])"
          then have 00: "x \<in> condition_to_set C2"
            using A  unfolding condition_to_set.simps C0_def C1_def cell_def C2_def by blast 
          have 01: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
            using 00 unfolding condition_to_set.simps C2_def cell_def by blast 
          have 02: "tl x \<in> A" 
            using 00 unfolding condition_to_set.simps C2_def cell_def by blast 
          have 03: "val (hd x \<ominus> cent (tl x)) \<in> I[val (a (tl x)) val (b (tl x))]"
            using 00 unfolding condition_to_set.simps C2_def cell_def by blast 
          show " x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<and> tl x \<in> A \<and> val (hd x \<ominus> cent (tl x)) \<in> I[val (a (tl x)) val (b (tl x))] "
            using 01 02 03 by blast 
        qed
        have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
          using A unfolding C0_def C1_def C2_def  condition_to_set.simps cell_def by blast 
        have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
          using x_closed Qp_pow_ConsE(1) by blast
        show "x \<notin> condition_to_set \<C>'"
        proof(cases "x \<in> condition_to_set C0")
          case True
          have 0: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x))) \<union> closed_interval (val (ma (tl x))) (val (b (tl x)))"
            using True unfolding C0_def condition_to_set.simps cell_def mem_Collect_eq by blast 
          hence 1: "val (hd x \<ominus> (cent (tl x))) \<in> closed_interval (val (a (tl x))) (val (b (tl x))) - left_closed_interval (val (c (tl x))) (val (d (tl x)))"
            using 1[of "tl x"] True tl_x_closed by blast 
          show "x \<notin> condition_to_set \<C>'"
            unfolding condition_to_set.simps cell_def mem_Collect_eq assms 
            using  x_closed True condition_to_set_memE unfolding C0_def 
            using "1" by blast
        next
          case False
          show ?thesis
          proof(cases "x \<in> condition_to_set C1")
          case  True
          have 0: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x))) \<union> closed_interval (val (ma (tl x))) (val (b (tl x)))"
            using True unfolding C1_def condition_to_set.simps cell_def mem_Collect_eq by blast 
          hence 1: "val (hd x \<ominus> (cent (tl x))) \<in> closed_interval (val (a (tl x))) (val (b (tl x))) - left_closed_interval (val (c (tl x))) (val (d (tl x)))"
            using 1[of "tl x"] True tl_x_closed by blast 
          show "x \<notin> condition_to_set \<C>'"
            unfolding condition_to_set.simps cell_def mem_Collect_eq assms 
            using  x_closed True condition_to_set_memE unfolding C0_def 
            using "1" by blast
        next 
          case F: False 
          then have True: "x \<in> condition_to_set C2"
            using False A by blast 
          then have "tl x  \<notin> B"
            unfolding C2_def condition_to_set.simps cell_def by blast 
          then show "x \<notin> condition_to_set \<C>'"
            unfolding assms condition_to_set.simps cell_def by blast 
        qed
      qed
    qed
  qed
  qed
  have d0:  "condition_to_set C0 \<inter> condition_to_set C1 = {}"
  proof(rule equalityI') 
    show "\<And>x. x \<in> condition_to_set C0 \<inter> condition_to_set C1 \<Longrightarrow> x \<in> {}"
    proof fix x assume A: "x \<in> condition_to_set C0 \<inter> condition_to_set C1"
      have 00: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x)))"
        using A unfolding C0_def condition_to_set.simps cell_def by blast  
      have 01: "val (hd x \<ominus> (cent (tl x))) \<in> closed_interval (val (ma (tl x))) (val (b (tl x)))"
        using A unfolding C1_def condition_to_set.simps cell_def by blast  
      have 02: "val (mi (tl x)) = min (val (b (tl x)) + 1) (val (c (tl x)))"
        using mi_val[of "tl x"] A  unfolding C0_def condition_to_set.simps cell_def 
        by (metis (no_types, lifting) Int_iff Qp_pow_ConsE(1) mem_Collect_eq mi_val)
      have 03: "val (ma (tl x)) = max (val (a (tl x))) (val (d (tl x)))"
        using ma_val[of "tl x"] A
        unfolding C0_def condition_to_set.simps cell_def
        by (metis (no_types, lifting) Int_iff Qp_pow_ConsE(1) mem_Collect_eq mi_val)
      have 04: "tl x \<in> B"
        using A unfolding C0_def condition_to_set.simps cell_def by blast  
      have 05: "val (c (tl x)) \<le> val (d (tl x))"
        using assms(7) 04 by blast 
      show "x \<in> {}"
        using 00 01 05 unfolding 02 03 left_closed_interval_def closed_interval_def  mem_Collect_eq 
        by fastforce
      show "\<And>x. x \<in> condition_to_set C0 \<inter> condition_to_set C1 \<Longrightarrow> {} \<subseteq> {}"
        by blast 
    qed
    show "\<And>x. x \<in> {} \<Longrightarrow> x \<in> condition_to_set C0 \<inter> condition_to_set C1"
      by blast 
  qed
  have d1: "condition_to_set C0 \<inter> condition_to_set C2 = {}"
    unfolding C0_def C2_def condition_to_set.simps cell_def by blast 
  have d2: "condition_to_set C1 \<inter> condition_to_set C2 = {}"
    unfolding C1_def C2_def condition_to_set.simps cell_def by blast 
  obtain S where S_def: "S = {C0, C1, C2}"
    by blast 
  have 8: "disjoint (condition_to_set ` {C0, C1, C2})"
    unfolding disjoint_def using d0 d1 d2 
    by blast
  have 9: "is_cell_decomp m S (condition_to_set \<C> - condition_to_set \<C>')"
    apply(rule is_cell_decompI) 
    unfolding S_def apply blast 
    apply(rule is_partitionI) 
    using 8 apply blast 
    using 7 apply blast 
    using 4 5 6 unfolding C0_def C1_def  C2_def 
    using condition_decomp(1) apply blast
    unfolding assms condition_to_set.simps cell_def apply blast 
    using 8 disjointE unfolding C0_def C1_def  C2_def  
    using C0_def C1_def C2_def d0 d1 d2 by blast
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    apply(rule is_c_decomposableI[of S]) 
    unfolding S_def apply blast 
    unfolding C0_def C1_def C2_def 
    using "9" C0_def C1_def C2_def S_def center.simps by blast
qed    

lemma closed_interval_minus_left_closed_interval_cell_diff:
  assumes "\<C> = Cond m A cent a b closed_interval"
  assumes "\<C>' = Cond m B cent c d left_closed_interval"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof-
  obtain B' where B'_def: "B' = B \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (c x) \<le> val (d x)}"
    by blast 
  have c_closed: "c \<in> carrier (SA m)"
    using assms is_cell_conditionE(3) by blast
  have d_closed : "d \<in> carrier (SA m)"
    using assms is_cell_conditionE(4) by blast
  have B'_semialg: "is_semialgebraic m B'"
    unfolding B'_def 
    apply(rule intersection_is_semialg)
    using assms is_cell_conditionE(1) apply blast
    using c_closed d_closed semialg_val_ineq_set_is_semialg by blast 
  have 0: "condition_to_set \<C>' = condition_to_set (Cond m B' cent c d left_closed_interval)"
  proof(rule equalityI')
    show " \<And>x. x \<in> condition_to_set \<C>' \<Longrightarrow> x \<in> condition_to_set (Cond m B' cent c d left_closed_interval)"
    proof- fix x assume a: "x \<in> condition_to_set \<C>'"
      have 0: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using a assms unfolding assms condition_to_set.simps cell_def 
        using Qp_pow_ConsE(1) by blast
      have  1: "tl x \<in> B'"
        unfolding B'_def using 0 a le_less basic_trans_rules(21)[of "val (c (tl x))" "val (hd x \<ominus> cent (tl x))" "val (d (tl x))"] unfolding assms condition_to_set.simps cell_def mem_Collect_eq left_closed_interval_def  
        by blast    
      show "x \<in> condition_to_set (Cond m B' cent c d left_closed_interval)"
        using a unfolding assms condition_to_set.simps assms cell_def left_closed_interval_def mem_Collect_eq B'_def 
        using "1" B'_def by blast
    qed
    show "\<And>x. x \<in> condition_to_set (Cond m B' cent c d left_closed_interval) \<Longrightarrow> x \<in> condition_to_set \<C>'"
      unfolding assms  condition_to_set.simps B'_def cell_def by blast 
  qed
  have 1: "is_cell_condition (Cond m B' cent c d left_closed_interval)"
    apply(rule is_cell_conditionI') 
    using B'_semialg apply blast 
    using assms is_cell_conditionE apply blast 
      using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE[of m B cent c d left_closed_interval] apply blast 
    using assms is_cell_conditionE[of m B cent c d left_closed_interval] by blast 
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 0  apply(rule closed_interval_minus_left_closed_interval_cell_diff0[of _ _ A _ a b _ B' c d  C])
    using assms B'_def 1  apply blast
         apply blast 
    using assms apply blast 
    using assms B'_def 1 apply blast 
    using assms apply blast 
    using 1  apply blast 
    unfolding B'_def by blast 
qed

lemma left_closed_interval_minus_left_closed_interval_cell_diff0:
  assumes "\<C> = Cond m A cent a b left_closed_interval"
  assumes "\<C>' = Cond m B cent c d left_closed_interval"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  assumes "\<forall>x \<in> B. val (c x) \<le> val (d x)"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof-
  have a_closed: "a \<in> carrier (SA m)"
    using assms is_cell_conditionE 
    by meson
  have b_closed: "b \<in> carrier (SA m)"
    using assms is_cell_conditionE 
    by meson
  have c_closed: "c \<in> carrier (SA m)"
    using assms is_cell_conditionE 
    by meson
  have d_closed: "d \<in> carrier (SA m)"
    using assms is_cell_conditionE 
    by meson
  obtain mi where mi_def: "mi \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (mi x) = min (val (b x)) (val (c x)))"
    using b_closed c_closed SA_min_fun 
    by (metis (no_types, lifting))
  have mi_val: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<Longrightarrow> val (mi x) = min (val (b x)) (val (c x))"
    using mi_def  c_closed  
    by metis
  obtain ma where ma_def: "ma \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (ma x) = max (val (a x)) (val (d x)))"
    using a_closed d_closed SA_max_fun 
    by (metis (no_types, opaque_lifting))
  have ma_val: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<Longrightarrow> val (ma x) = max (val (a x)) (val (d x))"
    using ma_def a_closed b_closed  
    by blast
  have 0: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<Longrightarrow> 
  left_closed_interval (val (a x)) (val (b x)) - left_closed_interval (val (c x)) (val (d x)) = left_closed_interval (val (a x)) (min (val (b x)) (val (c x))) \<union> left_closed_interval (max (val (a x)) (val (d x))) (val (b x))"
  proof- fix x assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)" 
    then show "left_closed_interval (val (a x)) (val (b x)) - left_closed_interval (val (c x)) (val (d x)) = left_closed_interval (val (a x)) (min (val (b x)) (val (c x))) \<union> left_closed_interval (max (val (a x)) (val (d x))) (val (b x))"
    using max.commute left_closed_interval_minus_left_closed_interval''[of _ "val (a x)" "val (b x)" _ "val (c x)" "val (d x)"] 
    by metis  
  qed
  have 1: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>) \<Longrightarrow> 
  left_closed_interval (val (a x)) (val (b x)) - left_closed_interval (val (c x)) (val (d x)) = left_closed_interval (val (a x)) (val (mi x)) \<union> left_closed_interval (val (ma x)) (val (b x))"
  proof- fix x  assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)" 
    have 10: " val (ma x) = max (val (a x)) (val (d x))"
      using A  ma_val by blast 
    have 11: "val (mi x) = min (val (b x)) (val (c x))"
      using A mi_val by blast 
    show " left_closed_interval (val (a x)) (val (b x)) - left_closed_interval (val (c x)) (val (d x)) = left_closed_interval (val (a x)) (val (mi x)) \<union> left_closed_interval (val (ma x)) (val (b x))"
      using A 0[of  x] unfolding 10 11 by blast    
  qed
  have 2: "is_semialgebraic m A"
    using assms is_cell_conditionE by blast 
  have 3: "is_semialgebraic m B"
    using assms is_cell_conditionE by blast
  obtain C0 where C0_def: "C0 = Cond m (A \<inter> B) cent a mi left_closed_interval"
    by blast
  obtain C1 where C1_def: "C1 = Cond m (A \<inter> B) cent ma b left_closed_interval"
    by blast
  obtain C2 where C2_def: "C2 = Cond m (A - B) cent a b left_closed_interval"
    by blast
  have 4: "is_cell_condition C0" unfolding C0_def 
    apply(rule is_cell_conditionI')  
    using 2 3 intersection_is_semialg apply blast
    using assms is_cell_conditionE apply blast
    using a_closed apply blast 
    using mi_def apply blast 
    unfolding is_convex_condition_def by blast 
  have 5: "is_cell_condition C1" unfolding C1_def 
    apply(rule is_cell_conditionI')  
    using 2 3 intersection_is_semialg apply blast
    using assms is_cell_conditionE apply blast
    using ma_def apply blast 
    using b_closed apply blast 
    unfolding is_convex_condition_def by blast 
  have 6: "is_cell_condition C2" unfolding C2_def 
    apply(rule is_cell_conditionI')  
    using 2 3 diff_is_semialgebraic apply blast
    using assms is_cell_conditionE apply blast
    using a_closed apply blast 
    using b_closed apply blast 
    unfolding is_convex_condition_def by blast 
  have 7: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set C0 \<union> condition_to_set C1 \<union> condition_to_set C2"
  proof(rule equalityI')
    show "\<And>x. x \<in> condition_to_set \<C> - condition_to_set \<C>' \<Longrightarrow> x \<in> condition_to_set C0 \<union> condition_to_set C1 \<union> condition_to_set C2"
    proof fix x assume A: "x \<in> condition_to_set \<C> - condition_to_set \<C>'" "x \<notin> condition_to_set C2"
      show " x \<in> condition_to_set C0 \<union> condition_to_set C1"
      proof assume  B: "x \<notin> condition_to_set C1" 
        show "x \<in> condition_to_set C0"
        proof- 
          have 7: "tl x \<in> A"
            using A condition_to_set_memE unfolding assms cell_def 
            using assms(1) assms(5) by blast
          have 8: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (b (tl x)))"
            using assms  A condition_to_set_memE(2) unfolding assms cell_def 
            using assms by blast
          have 9: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
            using A unfolding assms condition_to_set.simps cell_def 
            by (metis (no_types, lifting) Diff_iff cartesian_power_tail mem_Collect_eq)
          have 10: "tl x \<notin> (A  - B)"
            using 8 9 1[of "tl x"] A unfolding  condition_to_set.simps cell_def  
            by (metis C2_def Diff_iff assms(1) assms(5) cell_condition_set_memE(1) cell_condition_set_memI)
          then have 11: "tl x \<in> B"
            using 7 by blast 
          have 12: "val (hd x \<ominus> (cent (tl x))) \<notin> left_closed_interval (val (c (tl x))) (val (d (tl x)))"
            using A 11 unfolding condition_to_set.simps cell_def assms by blast 
          hence 13: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (b (tl x))) - left_closed_interval (val (c (tl x))) (val (d (tl x)))"
            using 8  by blast 
          hence 14: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x))) \<union> left_closed_interval (val (ma (tl x))) (val (b (tl x)))"
            using 8  1[of "tl x"] 9 by blast 
          have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
            using A  unfolding assms condition_to_set.simps cell_def by blast 
          have 15: "tl x \<in> A \<inter> B"
            using "11" "7" by blast
          hence 16: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x)))"
            using 15 14 B 11 7 x_closed unfolding C1_def assms  condition_to_set.simps cell_def mem_Collect_eq 
            by blast
          show "x \<in> condition_to_set C0"
            unfolding condition_to_set.simps C0_def apply(rule cell_memI) 
            using x_closed apply linarith
            using "15" apply blast
            using "16" by blast
        qed
      qed
    qed
    show "\<And>x. x \<in> condition_to_set C0 \<union> condition_to_set C1 \<union> condition_to_set C2 \<Longrightarrow> x \<in> condition_to_set \<C> - condition_to_set \<C>'"
    proof- fix x assume A: "x \<in> condition_to_set C0 \<union> condition_to_set C1 \<union> condition_to_set C2"
      have  0: "left_closed_interval (val (a (tl x))) (val (b (tl x))) - left_closed_interval (val (c (tl x))) (val (d (tl x))) = left_closed_interval (val (a (tl x))) (val (mi (tl x))) \<union> left_closed_interval (val (ma (tl x))) (val (b (tl x)))"
        using 1 A unfolding C0_def C1_def C2_def condition_to_set.simps cell_def 
        using Qp_pow_ConsE(1) by blast
      show "x \<in> condition_to_set \<C> - condition_to_set \<C>'"
      proof 
        show "x \<in> condition_to_set \<C>"
          apply(cases "x \<in> condition_to_set C0")
          unfolding C0_def condition_to_set.simps assms 
           apply(rule cell_memI) 
          using cell_memE apply blast 
          using cell_memE apply blast
          using 0 cell_memE 
          apply (metis Diff_iff Int_iff inf_sup_absorb)
          unfolding C0_def condition_to_set.simps assms 
          apply(cases "x \<in> condition_to_set C1")
           apply(rule cell_memI) 
          using 1 A unfolding C0_def C1_def C2_def condition_to_set.simps cell_def apply blast 
          using cell_memE A unfolding mem_Collect_eq apply blast
          using 0 cell_memE apply blast
        proof- 
          assume A' : " \<not> (x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<and> tl x \<in> A \<inter> B \<and> val (hd x \<ominus> cent (tl x)) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x))))"
                      " \<not> (x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<and> tl x \<in> A \<inter> B \<and> val (hd x \<ominus> cent (tl x)) \<in> left_closed_interval (val (ma (tl x))) (val (b (tl x))))"
          then have 00: "x \<in> condition_to_set C2"
            using A  unfolding condition_to_set.simps C0_def C1_def cell_def C2_def by blast 
          have 01: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
            using 00 unfolding condition_to_set.simps C2_def cell_def by blast 
          have 02: "tl x \<in> A" 
            using 00 unfolding condition_to_set.simps C2_def cell_def by blast 
          have 03: "val (hd x \<ominus> cent (tl x)) \<in> left_closed_interval (val (a (tl x))) (val (b (tl x)))"
            using 00 unfolding condition_to_set.simps C2_def cell_def by blast 
          show " x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<and> tl x \<in> A \<and> val (hd x \<ominus> cent (tl x)) \<in> left_closed_interval (val (a (tl x))) (val (b (tl x)))"
            using 01 02 03 by blast 
        qed
        have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
          using A unfolding C0_def C1_def C2_def  condition_to_set.simps cell_def by blast 
        have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
          using x_closed Qp_pow_ConsE(1) by blast
        show "x \<notin> condition_to_set \<C>'"
        proof(cases "x \<in> condition_to_set C0")
          case True
          have 0: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x))) \<union> left_closed_interval (val (ma (tl x))) (val (b (tl x)))"
            using True unfolding C0_def condition_to_set.simps cell_def mem_Collect_eq by blast 
          hence 1: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (b (tl x))) - left_closed_interval (val (c (tl x))) (val (d (tl x)))"
            using 1[of "tl x"] True tl_x_closed by blast 
          show "x \<notin> condition_to_set \<C>'"
            unfolding condition_to_set.simps cell_def mem_Collect_eq assms 
            using  x_closed True condition_to_set_memE unfolding C0_def 
            using "1" by blast
        next
          case False
          show ?thesis
          proof(cases "x \<in> condition_to_set C1")
          case  True
          have 0: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x))) \<union> left_closed_interval (val (ma (tl x))) (val (b (tl x)))"
            using True unfolding C1_def condition_to_set.simps cell_def mem_Collect_eq by blast 
          hence 1: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (b (tl x))) - left_closed_interval (val (c (tl x))) (val (d (tl x)))"
            using 1[of "tl x"] True tl_x_closed by blast 
          show "x \<notin> condition_to_set \<C>'"
            unfolding condition_to_set.simps cell_def mem_Collect_eq assms 
            using  x_closed True condition_to_set_memE unfolding C0_def 
            using "1" by blast
        next 
          case F: False 
          then have True: "x \<in> condition_to_set C2"
            using False A by blast 
          then have "tl x  \<notin> B"
            unfolding C2_def condition_to_set.simps cell_def by blast 
          then show "x \<notin> condition_to_set \<C>'"
            unfolding assms condition_to_set.simps cell_def by blast 
        qed
      qed
    qed
  qed
  qed
  have d0:  "condition_to_set C0 \<inter> condition_to_set C1 = {}"
  proof(rule equalityI') 
    show "\<And>x. x \<in> condition_to_set C0 \<inter> condition_to_set C1 \<Longrightarrow> x \<in> {}"
    proof fix x assume A: "x \<in> condition_to_set C0 \<inter> condition_to_set C1"
      have 00: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (a (tl x))) (val (mi (tl x)))"
        using A unfolding C0_def condition_to_set.simps cell_def by blast  
      have 01: "val (hd x \<ominus> (cent (tl x))) \<in> left_closed_interval (val (ma (tl x))) (val (b (tl x)))"
        using A unfolding C1_def condition_to_set.simps cell_def by blast  
      have 02: "val (mi (tl x)) = min (val (b (tl x))) (val (c (tl x)))"
        using mi_val[of "tl x"] A  unfolding C0_def condition_to_set.simps cell_def 
        by (metis (no_types, lifting) Int_iff Qp_pow_ConsE(1) mem_Collect_eq mi_val)
      have 03: "val (ma (tl x)) = max (val (a (tl x))) (val (d (tl x)))"
        using ma_val[of "tl x"] A
        unfolding C0_def condition_to_set.simps cell_def
        by (metis (no_types, lifting) Int_iff Qp_pow_ConsE(1) mem_Collect_eq mi_val)
      have 04: "tl x \<in> B"
        using A unfolding C0_def condition_to_set.simps cell_def by blast  
      have 05: "val (c (tl x)) \<le> val (d (tl x))"
        using assms(7) 04 by blast 
      show "x \<in> {}"
        using 00 01 05 unfolding 02 03 left_closed_interval_def closed_interval_def  mem_Collect_eq 
        by fastforce
      show "\<And>x. x \<in> condition_to_set C0 \<inter> condition_to_set C1 \<Longrightarrow> {} \<subseteq> {}"
        by blast 
    qed
    show "\<And>x. x \<in> {} \<Longrightarrow> x \<in> condition_to_set C0 \<inter> condition_to_set C1"
      by blast 
  qed
  have d1: "condition_to_set C0 \<inter> condition_to_set C2 = {}"
    unfolding C0_def C2_def condition_to_set.simps cell_def by blast 
  have d2: "condition_to_set C1 \<inter> condition_to_set C2 = {}"
    unfolding C1_def C2_def condition_to_set.simps cell_def by blast 
  obtain S where S_def: "S = {C0, C1, C2}"
    by blast 
  have 8: "disjoint (condition_to_set ` {C0, C1, C2})"
    unfolding disjoint_def using d0 d1 d2 
    by blast
  have 9: "is_cell_decomp m S (condition_to_set \<C> - condition_to_set \<C>')"
    apply(rule is_cell_decompI) 
    unfolding S_def apply blast 
    apply(rule is_partitionI) 
    using 8 apply blast 
    using 7 apply blast 
    using 4 5 6 unfolding C0_def C1_def  C2_def 
    using condition_decomp(1) apply blast
    unfolding assms condition_to_set.simps cell_def apply blast 
    using 8 disjointE unfolding C0_def C1_def  C2_def  
    using C0_def C1_def C2_def d0 d1 d2 by blast
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    apply(rule is_c_decomposableI[of S]) 
    unfolding S_def apply blast 
    unfolding C0_def C1_def C2_def 
    using "9" C0_def C1_def C2_def S_def center.simps by blast
qed    

lemma left_closed_interval_minus_left_closed_interval_cell_diff:
  assumes "\<C> = Cond m A cent a b left_closed_interval"
  assumes "\<C>' = Cond m B cent c d left_closed_interval"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof-
  obtain B' where B'_def: "B' = B \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (c x) \<le> val (d x)}"
    by blast 
  have c_closed: "c \<in> carrier (SA m)"
    using assms is_cell_conditionE(3) by blast
  have d_closed : "d \<in> carrier (SA m)"
    using assms is_cell_conditionE(4) by blast
  have B'_semialg: "is_semialgebraic m B'"
    unfolding B'_def 
    apply(rule intersection_is_semialg)
    using assms is_cell_conditionE(1) apply blast
    using c_closed d_closed semialg_val_ineq_set_is_semialg by blast 
  have 0: "condition_to_set \<C>' = condition_to_set (Cond m B' cent c d left_closed_interval)"
  proof(rule equalityI')
    show " \<And>x. x \<in> condition_to_set \<C>' \<Longrightarrow> x \<in> condition_to_set (Cond m B' cent c d left_closed_interval)"
    proof- fix x assume a: "x \<in> condition_to_set \<C>'"
      have 0: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using a assms unfolding assms condition_to_set.simps cell_def 
        using Qp_pow_ConsE(1) by blast
      have  1: "tl x \<in> B'"
        unfolding B'_def using 0 a le_less basic_trans_rules(21)[of "val (c (tl x))" "val (hd x \<ominus> cent (tl x))" "val (d (tl x))"] unfolding assms condition_to_set.simps cell_def mem_Collect_eq left_closed_interval_def  
        by blast    
      show "x \<in> condition_to_set (Cond m B' cent c d left_closed_interval)"
        using a unfolding assms condition_to_set.simps assms cell_def left_closed_interval_def mem_Collect_eq B'_def 
        using "1" B'_def by blast
    qed
    show "\<And>x. x \<in> condition_to_set (Cond m B' cent c d left_closed_interval) \<Longrightarrow> x \<in> condition_to_set \<C>'"
      unfolding assms  condition_to_set.simps B'_def cell_def by blast 
  qed
  have 1: "is_cell_condition (Cond m B' cent c d left_closed_interval)"
    apply(rule is_cell_conditionI') 
    using B'_semialg apply blast 
    using assms is_cell_conditionE apply blast 
      using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE[of m B cent c d left_closed_interval] apply blast 
    using assms is_cell_conditionE[of m B cent c d left_closed_interval] by blast 
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 0  apply(rule left_closed_interval_minus_left_closed_interval_cell_diff0[of _ _ A _ a b _ B' c d  C])
    using assms B'_def 1  apply blast
         apply blast 
    using assms apply blast 
    using assms B'_def 1 apply blast 
    using assms apply blast 
    using 1  apply blast 
    unfolding B'_def by blast 
qed

lemma left_closed_interval_minus_closed_interval_cell_diff:
  assumes "\<C> = Cond m A cent a b left_closed_interval"
  assumes "\<C>' = Cond m B cent c d closed_interval"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  have d_semialg: "d \<in> carrier (SA m)"
    using assms is_cell_conditionE[of m B cent c d] by blast 
  obtain d' where d'_def: "d' \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (d' x) = val (d x) + 1)"
    using d_semialg SA_Suc_fun by blast
  obtain B0 where B0_def: "B0 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x \<noteq> \<zero>} \<inter> B"
    by blast 
  have B0_semialg: "is_semialgebraic m B0"
    unfolding B0_def apply(rule intersection_is_semialg)
    using d_semialg SA_nonzero_set_is_semialg apply blast
    using assms is_cell_conditionE[of m B cent c d] by blast 
  obtain B1 where B1_def: "B1 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x = \<zero>} \<inter> B"
    by blast 
  have B1_semialg: "is_semialgebraic m B1"
    unfolding B1_def apply(rule intersection_is_semialg)
    using d_semialg SA_zero_set_is_semialg apply blast
    using assms is_cell_conditionE[of m B cent c d] by blast 
  obtain \<C>0 where \<C>0_def: "\<C>0 = Cond m B0 cent c d' left_closed_interval"
    by blast 
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B1 cent c d closed_interval"
    by blast 
  have \<C>0_cell_cond: "is_cell_condition \<C>0"
    unfolding \<C>0_def apply(rule is_cell_conditionI') 
    using B0_semialg apply blast
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    using d'_def apply blast 
    by (simp add: is_convex_condition_def)
  have \<C>1_cell_cond: "is_cell_condition \<C>1"
    unfolding \<C>1_def apply(rule is_cell_conditionI') 
    using B1_semialg apply blast
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    by (simp add: is_convex_condition_def)
  have 0: "condition_to_set \<C>' = condition_to_set \<C>0 \<union> condition_to_set \<C>1"
  proof
    show "condition_to_set \<C>' \<subseteq> condition_to_set \<C>0 \<union> condition_to_set \<C>1"
    proof fix x assume A: "x \<in> condition_to_set \<C>'"
      have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        using A unfolding assms using assms cell_condition_set_memE(1) by blast
    have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
      using Qp_pow_ConsE(1) x_closed by blast
    show "x \<in> condition_to_set \<C>0 \<union> condition_to_set \<C>1"
    proof(cases "d (tl x) = \<zero>")
        case True
        have "tl x \<in> B1"
          unfolding B1_def using tl_x_closed assms A condition_to_set_memE(1)[of \<C>' m B cent c d closed_interval x] True 
          by blast 
        then show ?thesis 
          using A unfolding assms \<C>1_def condition_to_set.simps B1_def cell_def 
          by blast 
      next
        case False
        have F0: "tl x \<in> B0"
          unfolding B0_def using tl_x_closed assms A condition_to_set_memE(1)[of \<C>' m B cent c d closed_interval x] False 
          by blast   
        have F1: "val (d' (tl x)) =  val (d (tl x)) + 1"
          using d'_def tl_x_closed by blast 
        have F2: "val (d (tl x)) \<noteq> \<infinity>"
        proof-
          have "d (tl x) \<in> carrier (Q\<^sub>p)"
            using tl_x_closed d_semialg function_ring_car_closed SA_car semialg_functions_memE(2) by metis 
        thus ?thesis 
          using F0  tl_x_closed d_semialg unfolding B0_def 
          by (metis (no_types, opaque_lifting) False eint_ord_code(3) val_ineq)
        qed
        have F3: "left_closed_interval (val (c (tl x))) (val (d' (tl x))) = closed_interval (val (c (tl x))) (val (d (tl x))) "
          unfolding left_closed_interval_def closed_interval_def unfolding F1 
          apply(rule equalityI')
          unfolding mem_Collect_eq 
          using eSuc_ile_mono ileI1 apply blast
          using F2 F0  
          by (metis F1 add.commute add.left_commute basic_trans_rules(18) basic_trans_rules(21) basic_trans_rules(22) basic_trans_rules(24) closed_interval_as_left_closed_interval closed_interval_memI eSuc_ile_mono eSuc_infinity eSuc_mono eint_add_left_cancel ile_eSuc infinity_ne_i1 left_closed_interval_memE(2) notin_closed order_eq_iff plus_eint_simps(2) plus_eint_simps(3))
        then show ?thesis 
          using F0 F1 A unfolding assms \<C>0_def condition_to_set.simps B0_def cell_def 
          by blast 
    qed
    qed
    show "condition_to_set \<C>0 \<union> condition_to_set \<C>1 \<subseteq> condition_to_set \<C>'"
    proof fix x assume a: "x \<in> condition_to_set \<C>0 \<union> condition_to_set \<C>1"
      have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        using a unfolding assms using assms cell_condition_set_memE(1) 
        by (metis Un_iff \<C>0_def \<C>1_def cell_memE(1) condition_to_set.simps)
    have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
      using Qp_pow_ConsE(1) x_closed by blast
    show "x \<in> condition_to_set \<C>'"
    proof(cases "x \<in> condition_to_set \<C>0")
      case True
        have F0: "tl x \<in> B0"
          unfolding B0_def using tl_x_closed assms True condition_to_set_memE(1)[of \<C>0 m B0 cent c d closed_interval x]  
          B0_def \<C>0_cell_cond \<C>0_def cell_condition_set_memE(2) 
          by (meson padic_fields.cell_condition_set_memE(2) padic_fields_axioms) 
        have F1: "val (d' (tl x)) =  val (d (tl x)) + 1"
          using d'_def tl_x_closed by blast 
        have F2: "val (d (tl x)) \<noteq> \<infinity>"
        proof-
          have "d (tl x) \<in> carrier (Q\<^sub>p)"
            using tl_x_closed d_semialg function_ring_car_closed SA_car semialg_functions_memE(2) by metis 
        thus ?thesis 
          using F0  tl_x_closed  unfolding val_def unfolding B0_def 
          by (metis (mono_tags, lifting) Int_iff eint.simps(2) mem_Collect_eq)
        qed
        have F3: "left_closed_interval (val (c (tl x))) (val (d' (tl x))) = closed_interval (val (c (tl x))) (val (d (tl x))) "
          unfolding left_closed_interval_def closed_interval_def unfolding F1 
          apply(rule equalityI')
          unfolding mem_Collect_eq 
          using eSuc_ile_mono ileI1 apply blast
          using F2 F0  
          by (metis F1 add.commute add.left_commute basic_trans_rules(18) basic_trans_rules(21) basic_trans_rules(22) basic_trans_rules(24) closed_interval_as_left_closed_interval closed_interval_memI eSuc_ile_mono eSuc_infinity eSuc_mono eint_add_left_cancel ile_eSuc infinity_ne_i1 left_closed_interval_memE(2) notin_closed order_eq_iff plus_eint_simps(2) plus_eint_simps(3))
        show ?thesis
             using True 
             unfolding assms \<C>0_def condition_to_set.simps B0_def cell_def mem_Collect_eq F3 by blast 
    next
           case False
           then show ?thesis
             using a unfolding assms \<C>1_def condition_to_set.simps cell_def B1_def by blast 
    qed
    qed
  qed
  have 1: "condition_to_set \<C>0 \<inter> condition_to_set \<C>1 = {}"
    unfolding \<C>0_def \<C>1_def condition_to_set.simps B1_def B0_def cell_def by blast 
  obtain A0 where A0_def: "A0 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x \<noteq> \<zero>} \<inter> A"
    by blast 
  have A0_semialg: "is_semialgebraic m A0"
    unfolding A0_def apply(rule intersection_is_semialg)
    using d_semialg SA_nonzero_set_is_semialg apply blast
    using assms is_cell_conditionE[of m A cent a b] by blast 
  obtain A1 where A1_def: "A1 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x = \<zero>} \<inter> A"
    by blast 
  have A1_semialg: "is_semialgebraic m A1"
    unfolding A1_def apply(rule intersection_is_semialg)
    using d_semialg SA_zero_set_is_semialg apply blast
    using assms is_cell_conditionE[of m A cent a b] by blast 
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m A0 cent a b left_closed_interval"
    by blast 
  obtain \<C>3 where \<C>3_def: "\<C>3 = Cond m A1 cent a b left_closed_interval"
    by blast 
  have \<C>2_is_cell_cond: "is_cell_condition \<C>2"
    unfolding \<C>2_def using assms change_of_fibres A0_semialg by blast
  have \<C>3_is_cell_cond: "is_cell_condition \<C>3"
    unfolding \<C>3_def using assms change_of_fibres A1_semialg by blast
  have disjoint: "condition_to_set \<C>2 \<inter> condition_to_set \<C>3 = {}"
    unfolding \<C>2_def \<C>3_def apply(rule disjoint_fibres) 
    using \<C>2_is_cell_cond unfolding \<C>2_def apply blast 
    using \<C>3_is_cell_cond unfolding \<C>3_def apply blast 
    unfolding A1_def A0_def by blast 
  have A_closed: "A \<subseteq> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    using assms is_cell_conditionE(1) is_semialgebraic_closed by blast
  have 2: "A = A0 \<union> A1"
    using A_closed unfolding   A0_def A1_def by blast 
  have union: "condition_to_set \<C> = condition_to_set \<C>2 \<union> condition_to_set \<C>3"
    unfolding assms \<C>2_def \<C>3_def 2 apply(rule union_fibres) 
    using \<C>2_is_cell_cond unfolding \<C>2_def apply blast 
    using \<C>3_is_cell_cond unfolding \<C>3_def by blast 
  have 3: "condition_to_set \<C>2 \<inter> condition_to_set \<C>1 = {}"
    unfolding \<C>2_def \<C>1_def apply(rule disjoint_fibres)  unfolding \<C>2_def \<C>1_def 
    using \<C>2_def \<C>2_is_cell_cond apply blast
    using \<C>1_cell_cond \<C>1_def apply blast
    unfolding A0_def B1_def by blast 
  have 4: "condition_to_set \<C>3 \<inter> condition_to_set \<C>0 = {}"
    unfolding \<C>3_def \<C>0_def apply(rule disjoint_fibres)  unfolding \<C>3_def \<C>0_def 
    using \<C>3_def \<C>3_is_cell_cond apply blast
    using \<C>0_cell_cond \<C>0_def apply blast
    unfolding A1_def B0_def by blast 
  have 5: "condition_to_set \<C> - condition_to_set \<C>' = 
          (condition_to_set \<C>2 - condition_to_set \<C>0) \<union> (condition_to_set \<C>3 - condition_to_set \<C>1)"
    using union 3 4 disjoint 0 by blast 
  have 6: "is_c_decomposable m cent (condition_to_set \<C>2 - condition_to_set \<C>0)"
    apply (rule left_closed_interval_minus_left_closed_interval_cell_diff[of _ _ A0 _ a b _ B0 c d' "A0 \<union> B0"])
    unfolding \<C>2_def \<C>0_def 
    apply blast apply blast apply blast apply blast 
    using \<C>2_def \<C>2_is_cell_cond apply blast
    using \<C>0_cell_cond \<C>0_def by blast
  have 7: "condition_to_set \<C>3 - condition_to_set \<C>1 = condition_to_set \<C>3 - condition_to_set (Cond m B1 cent c d left_closed_interval)"
  proof
    show "condition_to_set \<C>3 - condition_to_set \<C>1 \<subseteq> condition_to_set \<C>3 - condition_to_set (Cond m B1 cent c d left_closed_interval)"
    proof fix x assume A: "x \<in>  condition_to_set \<C>3 - condition_to_set \<C>1"
      have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        using A using \<C>3_is_cell_cond unfolding \<C>3_def 
        by (meson Diff_iff cell_condition_set_memE(1))
      have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using Qp_pow_ConsE(1) x_closed by blast
      have dx: "d (tl x) = \<zero> "
        using A unfolding \<C>3_def condition_to_set.simps cell_def A1_def 
        unfolding  \<C>3_def \<C>1_def using closed_interval_def left_closed_interval_def
        by blast 
      have val_dx: "val (d (tl x)) = \<infinity>"
        using dx  local.val_zero by presburger
      have 70: "closed_interval (val (c (tl x))) (val (d (tl x))) = {\<infinity>} \<union> left_closed_interval (val (c (tl x))) (val (d (tl x)))"
        unfolding val_dx left_closed_interval_def closed_interval_def 
        apply(rule equalityI')
         apply (metis Un_commute Un_iff eint_ord_simps(4) mem_Collect_eq singletonI)
        by (metis (no_types, lifting) Un_commute Un_iff eint_ord_code(3) emptyE insert_iff mem_Collect_eq)
      have 71: "val (hd x \<ominus> cent (tl x)) \<noteq> \<infinity>"
        using A unfolding \<C>3_def condition_to_set.simps cell_def left_closed_interval_def 
        using Diff_iff eint_ord_simps(6) mem_Collect_eq 
        by (metis (no_types, lifting))
      show " x \<in> condition_to_set \<C>3 - condition_to_set (Cond m B1 cent c d left_closed_interval)"
        using A 71 70 unfolding condition_to_set.simps cell_def \<C>1_def by blast
    qed
    show "condition_to_set \<C>3 - condition_to_set (Cond m B1 cent c d left_closed_interval) \<subseteq> condition_to_set \<C>3 - condition_to_set \<C>1"
    proof fix x assume A: "x \<in> condition_to_set \<C>3 - condition_to_set (Cond m B1 cent c d left_closed_interval)"
      have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        using A using \<C>3_is_cell_cond unfolding \<C>3_def 
        by (meson Diff_iff cell_condition_set_memE(1))
      have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using Qp_pow_ConsE(1) x_closed by blast
      have dx: "d (tl x) = \<zero> "
        using A unfolding \<C>3_def condition_to_set.simps cell_def A1_def 
        unfolding  \<C>3_def \<C>1_def using closed_interval_def left_closed_interval_def
        by blast 
      have val_dx: "val (d (tl x)) = \<infinity>"
        using dx  local.val_zero by presburger
      have 70: "closed_interval (val (c (tl x))) (val (d (tl x))) = {\<infinity>} \<union> left_closed_interval (val (c (tl x))) (val (d (tl x)))"
        unfolding val_dx left_closed_interval_def closed_interval_def 
        apply(rule equalityI')
         apply (metis Un_commute Un_iff eint_ord_simps(4) mem_Collect_eq singletonI)
        by (metis (no_types, lifting) Un_commute Un_iff eint_ord_code(3) emptyE insert_iff mem_Collect_eq)
      have 71: "val (hd x \<ominus> cent (tl x)) \<noteq> \<infinity>"
        using A unfolding \<C>3_def condition_to_set.simps cell_def left_closed_interval_def 
        by force        
      show "x \<in> condition_to_set \<C>3 - condition_to_set \<C>1"
        using A 71 70 unfolding condition_to_set.simps cell_def \<C>1_def  
        by (metis (no_types, lifting) Diff_iff Un_iff empty_iff insert_iff mem_Collect_eq)
    qed
  qed
  have 8: "is_c_decomposable m cent (condition_to_set \<C>3 - condition_to_set \<C>1)"
    unfolding 7 unfolding \<C>3_def apply(rule left_closed_interval_minus_left_closed_interval_cell_diff[of _ _ A1 _ a b _ B1 c d "A1 \<union> B1"])
         apply auto[1]  apply simp apply blast apply blast 
          using \<C>3_def \<C>3_is_cell_cond apply blast
          by (metis (no_types, lifting) B1_semialg assms(1) assms(2) assms(5) assms(6) is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) is_cell_conditionI')
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 5  apply (rule   c_decomposable_disjoint_union)
    using 6 apply blast 
    using 8 apply blast 
    unfolding \<C>2_def \<C>3_def condition_to_set.simps cell_def A0_def A1_def by blast 
qed

lemma closed_interval_minus_closed_interval_cell_diff:
  assumes "\<C> = Cond m A cent a b closed_interval"
  assumes "\<C>' = Cond m B cent c d closed_interval"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C>' - condition_to_set \<C>)"
proof-
  have d_semialg: "d \<in> carrier (SA m)"
    using assms is_cell_conditionE[of m B cent c d] by blast 
  obtain d' where d'_def: "d' \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (d' x) = val (d x) + 1)"
    using d_semialg SA_Suc_fun by blast
  obtain B0 where B0_def: "B0 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x \<noteq> \<zero>} \<inter> B"
    by blast 
  have B0_semialg: "is_semialgebraic m B0"
    unfolding B0_def apply(rule intersection_is_semialg)
    using d_semialg SA_nonzero_set_is_semialg apply blast
    using assms is_cell_conditionE[of m B cent c d] by blast 
  obtain B1 where B1_def: "B1 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x = \<zero>} \<inter> B"
    by blast 
  have B1_semialg: "is_semialgebraic m B1"
    unfolding B1_def apply(rule intersection_is_semialg)
    using d_semialg SA_zero_set_is_semialg apply blast
    using assms is_cell_conditionE[of m B cent c d] by blast 
  obtain \<C>0 where \<C>0_def: "\<C>0 = Cond m B0 cent c d' left_closed_interval"
    by blast 
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B1 cent c d closed_interval"
    by blast 
  have \<C>0_cell_cond: "is_cell_condition \<C>0"
    unfolding \<C>0_def apply(rule is_cell_conditionI') 
    using B0_semialg apply blast
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    using d'_def apply blast 
    by (simp add: is_convex_condition_def)
  have \<C>1_cell_cond: "is_cell_condition \<C>1"
    unfolding \<C>1_def apply(rule is_cell_conditionI') 
    using B1_semialg apply blast
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    using assms is_cell_conditionE[of m B cent c d] apply  blast 
    by (simp add: is_convex_condition_def)
  have 0: "condition_to_set \<C>' = condition_to_set \<C>0 \<union> condition_to_set \<C>1"
  proof
    show "condition_to_set \<C>' \<subseteq> condition_to_set \<C>0 \<union> condition_to_set \<C>1"
    proof fix x assume A: "x \<in> condition_to_set \<C>'"
      have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        using A unfolding assms using assms cell_condition_set_memE(1) by blast
    have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
      using Qp_pow_ConsE(1) x_closed by blast
    show "x \<in> condition_to_set \<C>0 \<union> condition_to_set \<C>1"
    proof(cases "d (tl x) = \<zero>")
        case True
        have "tl x \<in> B1"
          unfolding B1_def using tl_x_closed assms A condition_to_set_memE(1)[of \<C>' m B cent c d closed_interval x] True 
          by blast 
        then show ?thesis 
          using A unfolding assms \<C>1_def condition_to_set.simps B1_def cell_def 
          by blast 
      next
        case False
        have F0: "tl x \<in> B0"
          unfolding B0_def using tl_x_closed assms A condition_to_set_memE(1)[of \<C>' m B cent c d closed_interval x] False 
          by blast   
        have F1: "val (d' (tl x)) =  val (d (tl x)) + 1"
          using d'_def tl_x_closed by blast 
        have F2: "val (d (tl x)) \<noteq> \<infinity>"
        proof-
          have "d (tl x) \<in> carrier (Q\<^sub>p)"
            using tl_x_closed d_semialg function_ring_car_closed SA_car semialg_functions_memE(2) by metis 
        thus ?thesis 
          using F0  tl_x_closed d_semialg unfolding B0_def 
          by (metis (no_types, opaque_lifting) False eint_ord_code(3) val_ineq)
        qed
        have F3: "left_closed_interval (val (c (tl x))) (val (d' (tl x))) = closed_interval (val (c (tl x))) (val (d (tl x))) "
          unfolding left_closed_interval_def closed_interval_def unfolding F1 
          apply(rule equalityI')
          unfolding mem_Collect_eq 
          using eSuc_ile_mono ileI1 apply blast
          using F2 F0  
          by (metis F1 add.commute add.left_commute basic_trans_rules(18) basic_trans_rules(21) basic_trans_rules(22) basic_trans_rules(24) closed_interval_as_left_closed_interval closed_interval_memI eSuc_ile_mono eSuc_infinity eSuc_mono eint_add_left_cancel ile_eSuc infinity_ne_i1 left_closed_interval_memE(2) notin_closed order_eq_iff plus_eint_simps(2) plus_eint_simps(3))
        then show ?thesis 
          using F0 F1 A unfolding assms \<C>0_def condition_to_set.simps B0_def cell_def 
          by blast 
    qed
    qed
    show "condition_to_set \<C>0 \<union> condition_to_set \<C>1 \<subseteq> condition_to_set \<C>'"
    proof fix x assume a: "x \<in> condition_to_set \<C>0 \<union> condition_to_set \<C>1"
      have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        using a unfolding assms using assms cell_condition_set_memE(1) 
        by (metis Un_iff \<C>0_def \<C>1_def cell_memE(1) condition_to_set.simps)
    have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
      using Qp_pow_ConsE(1) x_closed by blast
    show "x \<in> condition_to_set \<C>'"
    proof(cases "x \<in> condition_to_set \<C>0")
      case True
        have F0: "tl x \<in> B0"
          unfolding B0_def using tl_x_closed assms True condition_to_set_memE(1)[of \<C>0 m B0 cent c d closed_interval x]  
          B0_def \<C>0_cell_cond \<C>0_def cell_condition_set_memE(2) 
          by (meson padic_fields.cell_condition_set_memE(2) padic_fields_axioms) 
        have F1: "val (d' (tl x)) =  val (d (tl x)) + 1"
          using d'_def tl_x_closed by blast 
        have F2: "val (d (tl x)) \<noteq> \<infinity>"
        proof-
          have "d (tl x) \<in> carrier (Q\<^sub>p)"
            using tl_x_closed d_semialg function_ring_car_closed SA_car semialg_functions_memE(2) by metis 
        thus ?thesis 
          using F0  tl_x_closed  unfolding val_def unfolding B0_def 
          by (metis (mono_tags, lifting) Int_iff eint.simps(2) mem_Collect_eq)
        qed
        have F3: "left_closed_interval (val (c (tl x))) (val (d' (tl x))) = closed_interval (val (c (tl x))) (val (d (tl x))) "
          unfolding left_closed_interval_def closed_interval_def unfolding F1 
          apply(rule equalityI')
          unfolding mem_Collect_eq 
          using eSuc_ile_mono ileI1 apply blast
          using F2 F0  
          by (metis F1 add.commute add.left_commute basic_trans_rules(18) basic_trans_rules(21) basic_trans_rules(22) basic_trans_rules(24) closed_interval_as_left_closed_interval closed_interval_memI eSuc_ile_mono eSuc_infinity eSuc_mono eint_add_left_cancel ile_eSuc infinity_ne_i1 left_closed_interval_memE(2) notin_closed order_eq_iff plus_eint_simps(2) plus_eint_simps(3))
        show ?thesis
             using True 
             unfolding assms \<C>0_def condition_to_set.simps B0_def cell_def mem_Collect_eq F3 by blast 
    next
           case False
           then show ?thesis
             using a unfolding assms \<C>1_def condition_to_set.simps cell_def B1_def by blast 
    qed
    qed
  qed
  have 1: "condition_to_set \<C>' - condition_to_set \<C> 
        = (condition_to_set \<C>0 - condition_to_set \<C>) \<union> (condition_to_set \<C>1 - condition_to_set \<C>)"
    unfolding 0 by blast 
  have 2: "condition_to_set \<C>0 \<inter> condition_to_set \<C>1 = {}"
    unfolding \<C>0_def \<C>1_def condition_to_set.simps B1_def B0_def cell_def by blast 
  show "is_c_decomposable m cent (condition_to_set \<C>' - condition_to_set \<C>)"
    unfolding 1 apply(rule c_decomposable_disjoint_union)
    apply(rule left_closed_interval_minus_closed_interval_cell_diff[of _ _ B0 _ c d' _ A a b "A \<union> B0"])
    unfolding  \<C>0_def assms apply blast apply blast apply blast apply blast
    using \<C>0_cell_cond \<C>0_def apply blast
    using assms(1) assms(5) apply blast
  proof-
    have b_semialg: "b \<in> carrier (SA m)"
    using assms is_cell_conditionE[of m A cent a b] by blast 
  obtain b' where b'_def: "b' \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (b' x) = val (b x) + 1)"
    using b_semialg SA_Suc_fun by blast
  obtain A0 where A0_def: "A0 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). b x \<noteq> \<zero>} \<inter> A"
    by blast 
  have A0_semialg: "is_semialgebraic m A0"
    unfolding A0_def apply(rule intersection_is_semialg)
    using b_semialg SA_nonzero_set_is_semialg apply blast
    using assms is_cell_conditionE[of m A cent a b] by blast 
  obtain A1 where A1_def: "A1 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). b x = \<zero>} \<inter> A"
    by blast 
  have A1_semialg: "is_semialgebraic m A1"
    unfolding A1_def apply(rule intersection_is_semialg)
    using b_semialg SA_zero_set_is_semialg apply blast
    using assms is_cell_conditionE[of m A cent a b] by blast 
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m A0 cent a b' left_closed_interval"
    by blast 
  obtain \<C>3 where \<C>3_def: "\<C>3 = Cond m A1 cent a b closed_interval"
    by blast 
  have \<C>2_cell_cond: "is_cell_condition \<C>2"
    unfolding \<C>2_def apply(rule is_cell_conditionI') 
    using A0_semialg apply blast
    using assms is_cell_conditionE[of m A cent a b] apply  blast 
    using assms is_cell_conditionE[of m A cent a b] apply  blast 
    using b'_def apply blast 
    by (simp add: is_convex_condition_def)
  have \<C>3_cell_cond: "is_cell_condition \<C>3"
    unfolding \<C>3_def apply(rule is_cell_conditionI') 
    using A1_semialg apply blast
    using assms is_cell_conditionE[of m A cent a b] apply  blast 
    using assms is_cell_conditionE[of m A cent a b] apply  blast 
    using assms is_cell_conditionE[of m A cent a b] apply  blast 
    by (simp add: is_convex_condition_def)
  have 0: "condition_to_set \<C> = condition_to_set \<C>2 \<union> condition_to_set \<C>3"
  proof
    show "condition_to_set \<C> \<subseteq> condition_to_set \<C>2 \<union> condition_to_set \<C>3"
    proof fix x assume A: "x \<in> condition_to_set \<C>"
      have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        using A unfolding assms using assms cell_condition_set_memE(1) by blast
    have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
      using Qp_pow_ConsE(1) x_closed by blast
    show "x \<in> condition_to_set \<C>2 \<union> condition_to_set \<C>3"
    proof(cases "b (tl x) = \<zero>")
        case True
        have "tl x \<in> A1"
          unfolding A1_def using tl_x_closed assms A condition_to_set_memE(1)[of \<C> m A cent a b closed_interval x] True 
          by blast 
        then show ?thesis 
          using A unfolding assms \<C>3_def condition_to_set.simps A1_def cell_def 
          by blast 
      next
        case False
        have F0: "tl x \<in> A0"
          unfolding A0_def using tl_x_closed assms A condition_to_set_memE(1)[of \<C> m A cent a b closed_interval x] False 
          by blast   
        have F1: "val (b' (tl x)) =  val (b (tl x)) + 1"
          using b'_def tl_x_closed by blast 
        have F2: "val (b (tl x)) \<noteq> \<infinity>"
        proof-
          have "b (tl x) \<in> carrier (Q\<^sub>p)"
            using tl_x_closed b_semialg function_ring_car_closed SA_car semialg_functions_memE(2) by metis 
        thus ?thesis 
          using F0  tl_x_closed b_semialg unfolding A0_def 
          by (metis (no_types, opaque_lifting) False eint_ord_code(3) val_ineq)
        qed
        have F3: "left_closed_interval (val (a (tl x))) (val (b' (tl x))) = closed_interval (val (a (tl x))) (val (b (tl x))) "
          unfolding left_closed_interval_def closed_interval_def unfolding F1 
          apply(rule equalityI')
          unfolding mem_Collect_eq 
          using eSuc_ile_mono ileI1 apply blast
          using F2 F0  
          by (metis F1 add.commute add.left_commute basic_trans_rules(18) basic_trans_rules(21) basic_trans_rules(22) basic_trans_rules(24) closed_interval_as_left_closed_interval closed_interval_memI eSuc_ile_mono eSuc_infinity eSuc_mono eint_add_left_cancel ile_eSuc infinity_ne_i1 left_closed_interval_memE(2) notin_closed order_eq_iff plus_eint_simps(2) plus_eint_simps(3))
        then show ?thesis 
          using F0 F1 A unfolding assms \<C>2_def condition_to_set.simps A0_def cell_def 
          by blast 
      qed
    qed
    show "condition_to_set \<C>2 \<union> condition_to_set \<C>3 \<subseteq> condition_to_set \<C>"
    proof fix x assume a: "x \<in> condition_to_set \<C>2 \<union> condition_to_set \<C>3"
      have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
        using a unfolding assms using assms cell_condition_set_memE(1) 
        by (metis Un_iff \<C>2_def \<C>3_def cell_memE(1) condition_to_set.simps)
    have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
      using Qp_pow_ConsE(1) x_closed by blast
    show "x \<in> condition_to_set \<C>"
    proof(cases "x \<in> condition_to_set \<C>2")
      case True
        have F0: "tl x \<in> A0"
          unfolding A0_def using tl_x_closed assms True condition_to_set_memE(1)[of \<C>2 m A0 cent a b closed_interval x]  
          A0_def \<C>2_cell_cond \<C>2_def cell_condition_set_memE(2) 
          by (meson padic_fields.cell_condition_set_memE(2) padic_fields_axioms) 
        have F1: "val (b' (tl x)) =  val (b (tl x)) + 1"
          using b'_def tl_x_closed by blast 
        have F2: "val (b (tl x)) \<noteq> \<infinity>"
        proof-
          have "b (tl x) \<in> carrier (Q\<^sub>p)"
            using tl_x_closed b_semialg function_ring_car_closed SA_car semialg_functions_memE(2) by metis 
        thus ?thesis 
          using F0  tl_x_closed  unfolding val_def unfolding A0_def 
          by (metis (mono_tags, lifting) Int_iff eint.simps(2) mem_Collect_eq)
        qed
        have F3: "left_closed_interval (val (a (tl x))) (val (b' (tl x))) = closed_interval (val (a (tl x))) (val (b (tl x))) "
          unfolding left_closed_interval_def closed_interval_def unfolding F1 
          apply(rule equalityI')
          unfolding mem_Collect_eq 
          using eSuc_ile_mono ileI1 apply blast
          using F2 F0  
          by (metis F1 add.commute add.left_commute basic_trans_rules(18) basic_trans_rules(21) basic_trans_rules(22) basic_trans_rules(24) closed_interval_as_left_closed_interval closed_interval_memI eSuc_ile_mono eSuc_infinity eSuc_mono eint_add_left_cancel ile_eSuc infinity_ne_i1 left_closed_interval_memE(2) notin_closed order_eq_iff plus_eint_simps(2) plus_eint_simps(3))
        show ?thesis
             using True 
             unfolding assms \<C>2_def condition_to_set.simps A0_def cell_def mem_Collect_eq F3 by blast 
    next
           case False
           then show ?thesis
             using a unfolding assms \<C>3_def condition_to_set.simps cell_def A1_def by blast 
    qed
    qed
  qed
  obtain C0 where C0_def: "C0 = B1 \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). b x = \<zero>}"
    by blast 
  have C0_semialg: "is_semialgebraic m C0"
    unfolding C0_def apply(rule intersection_is_semialg) 
    using B1_semialg apply blast
    using b_semialg SA_zero_set_is_semialg by blast
  obtain C1 where C1_def: "C1 = B1 \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). b x \<noteq> \<zero>}"
    by blast 
  have C1_semialg: "is_semialgebraic m C1"
    unfolding C1_def apply(rule intersection_is_semialg) 
    using B1_semialg apply blast
    using b_semialg  SA_nonzero_set_is_semialg by blast
  obtain \<C>4 where \<C>4_def: "\<C>4 = Cond m C0 cent c d closed_interval"
    by blast 
  have 00: "is_cell_condition \<C>4"
    unfolding \<C>4_def apply(rule change_of_fibres[of _  B1]) 
    using \<C>1_cell_cond \<C>1_def apply blast 
    by (simp add: C0_semialg)
  obtain \<C>5 where \<C>5_def: "\<C>5 = Cond m C1 cent c d closed_interval"
    by blast 
  have 00: "is_cell_condition \<C>5"
    unfolding \<C>5_def apply(rule change_of_fibres[of _  B1]) 
    using \<C>1_cell_cond \<C>1_def apply blast 
    by (simp add: C1_semialg)
  have 01: "B1 = C0 \<union> C1"
    unfolding C0_def C1_def B1_def by blast 
  have 02: "condition_to_set \<C>1 = condition_to_set \<C>4 \<union> condition_to_set \<C>5"
    unfolding \<C>1_def \<C>4_def \<C>5_def 01
    apply(rule union_fibres)
    using "00" C0_semialg \<C>5_def change_of_fibres apply blast
    using "00" \<C>5_def by blast
  have 03: "condition_to_set \<C>4 \<inter> condition_to_set \<C>2 = {}"
    unfolding \<C>4_def \<C>2_def condition_to_set.simps cell_def C0_def A0_def by blast 
  have 04: "condition_to_set \<C>5 \<inter> condition_to_set \<C>3 = {}"
    unfolding \<C>5_def \<C>3_def condition_to_set.simps cell_def C1_def A1_def by blast 
  have 05: "condition_to_set \<C>1 - condition_to_set (Cond m A cent a b closed_interval) =
  (condition_to_set \<C>4 - condition_to_set \<C>3) \<union> (condition_to_set \<C>5 - condition_to_set \<C>2)"
    using 0 03 04  unfolding 02 assms by blast
  have 06: "is_c_decomposable m cent (condition_to_set \<C>4 - condition_to_set \<C>3)"
  proof-
    obtain S0 where S0_def: "S0 = C0 - A1"
      by blast 
    have S0_semialg: "is_semialgebraic m S0"
      unfolding S0_def  by (simp add: A1_semialg C0_semialg diff_is_semialgebraic)
    obtain S1 where S1_def: "S1 = C0 \<inter> A1"
      by blast 
    have S1_semialg: "is_semialgebraic m S1"
      unfolding S1_def 
      by (simp add: A1_semialg C0_semialg intersection_is_semialg)
    have  060: "C0 = S0 \<union> S1"
      unfolding S0_def S1_def by blast 
    have 061: "condition_to_set \<C>4 =
            condition_to_set (Cond m S0 cent c d closed_interval) \<union> condition_to_set (Cond m S1 cent c d closed_interval)"
      unfolding \<C>4_def 060 apply(rule  union_fibres)  
       apply(rule change_of_fibres[of _  C0]) 
      using "00" C0_semialg \<C>5_def change_of_fibres apply blast
       apply (simp add: S0_semialg)
       apply(rule change_of_fibres[of _  C0]) 
      using "00" C0_semialg \<C>5_def change_of_fibres apply blast
      by (simp add: S1_semialg)
    have 062: "condition_to_set (Cond m S0 cent c d closed_interval) - condition_to_set \<C>3 = 
                condition_to_set (Cond m S0 cent c d closed_interval)"
      unfolding \<C>3_def condition_to_set.simps S0_def cell_def by blast 
    have 063: "condition_to_set (Cond m S1 cent c d closed_interval) - condition_to_set \<C>3 = condition_to_set (Cond m S1 cent c a left_closed_interval) "
      unfolding \<C>3_def 
    proof
      show "condition_to_set (Cond m (S1) cent c d closed_interval) - condition_to_set (Cond m A1 cent a b closed_interval)
    \<subseteq> condition_to_set (Cond m (S1) cent c a left_closed_interval)"
      proof fix x assume A: "x \<in> condition_to_set (Cond m S1 cent c d closed_interval) - condition_to_set (Cond m A1 cent a b closed_interval)"
        have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
          using A condition_to_set_memE by (metis Diff_iff Qp_pow_ConsE(1) cell_memE(1) condition_to_set.simps)
        have 0620:"val (b (tl x)) = \<infinity>"
          using tl_x_closed using A condition_to_set_memE unfolding S1_def A1_def condition_to_set.simps cell_def 
          by (metis (mono_tags, lifting) Diff_iff Int_iff local.val_zero mem_Collect_eq)
        have 0621: "val (d (tl x)) = \<infinity>"
          using tl_x_closed using A condition_to_set_memE unfolding S1_def C0_def B1_def  condition_to_set.simps cell_def 
          by (metis (mono_tags, lifting) Diff_iff Int_iff local.val_zero mem_Collect_eq)  
        show "x \<in> condition_to_set (Cond m S1 cent c a left_closed_interval)"
          unfolding condition_to_set.simps
          apply(rule cell_memI) 
          using A unfolding condition_to_set.simps cell_def apply blast 
          using A unfolding condition_to_set.simps cell_def apply blast 
          using A apply(rule  DiffE) 
          unfolding condition_to_set.simps cell_def closed_interval_def mem_Collect_eq 0620 0621 S1_def
          apply(rule left_closed_interval_memI) 
           apply blast
        proof-  
          assume A0: " x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<and> tl x \<in> C0 \<inter> A1 \<and> val (c (tl x)) \<le> val (hd x \<ominus> cent (tl x)) \<and> val (hd  x \<ominus> cent (tl x)) \<le> \<infinity>"
          assume A1: "   \<not> (x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<and> tl x \<in> A1 \<and> val (a (tl x)) \<le> val (hd x \<ominus> cent (tl x)) \<and> val (hd x \<ominus> cent (tl x)) \<le> \<infinity>) "
          have " \<not> val (a (tl x)) \<le> val (hd x \<ominus> cent (tl x))"
            using A0 A1 by blast 
          thus " val (hd x \<ominus> cent (tl x)) < val (a (tl x)) "
          using not_le[of "val (a (tl x))" "val (hd x \<ominus> cent (tl x))"] by blast 
        qed
      qed
      show "condition_to_set (Cond m S1 cent c a left_closed_interval)
    \<subseteq> condition_to_set (Cond m S1 cent c d closed_interval) - condition_to_set (Cond m A1 cent a b closed_interval)"
      proof fix x assume A: "  x \<in> condition_to_set (Cond m S1 cent c a left_closed_interval)"
        show  "x \<in> condition_to_set (Cond m S1 cent c d closed_interval) - condition_to_set (Cond m A1 cent a b closed_interval)"
        proof
        have tl_x_closed: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
          using A condition_to_set_memE by (metis Qp_pow_ConsE(1) cell_memE(1) condition_to_set.simps)
        have 0620:"val (b (tl x)) = \<infinity>"
          using tl_x_closed using A condition_to_set_memE unfolding S1_def A1_def condition_to_set.simps cell_def 
          by (metis (mono_tags, lifting) Int_iff local.val_zero mem_Collect_eq)
        have 0621: "val (d (tl x)) = \<infinity>"
          using tl_x_closed using A condition_to_set_memE unfolding S1_def C0_def B1_def  condition_to_set.simps cell_def 
          by (metis (mono_tags, lifting) Int_iff local.val_zero mem_Collect_eq)  
        show "x \<in> condition_to_set (Cond m S1 cent c d closed_interval)"
          unfolding condition_to_set.simps
          apply(rule cell_memI)
          using A unfolding condition_to_set.simps cell_def apply blast 
          using A unfolding condition_to_set.simps cell_def apply blast 
          unfolding closed_interval_def 
          using A unfolding condition_to_set.simps cell_def mem_Collect_eq left_closed_interval_def  0621 
          using eint_ord_code(3) by blast
        show "x \<notin> condition_to_set (Cond m A1 cent a b closed_interval)"
          using A condition_to_set_memE(2)[of "Cond m S1 cent c a left_closed_interval" m S1 cent c a left_closed_interval x] 
          unfolding condition_to_set.simps cell_def closed_interval_def mem_Collect_eq left_closed_interval_def 
          using notin_closed by blast
        qed
      qed
    qed
    have 064: "condition_to_set \<C>4 - condition_to_set \<C>3 = (condition_to_set (Cond m S0 cent c d closed_interval) - condition_to_set \<C>3) 
            \<union>(condition_to_set (Cond m S1 cent c d closed_interval) - condition_to_set \<C>3)"
      unfolding 061 by blast 
    have 065: "condition_to_set \<C>4 - condition_to_set \<C>3 =  condition_to_set (Cond m S0 cent c d closed_interval) 
            \<union>condition_to_set (Cond m S1 cent c a left_closed_interval)"
      unfolding 064 063 062 by blast 
    show ?thesis 
      unfolding 065 apply(rule c_decomposable_disjoint_union)
        apply(rule c_cell_is_c_decomposable) 
          apply(rule change_of_fibres[of _ B]) using assms apply blast 
          using S0_semialg apply blast 
        apply(rule c_cell_is_c_decomposable) 
           apply(rule is_cell_conditionI') 
          using S1_semialg apply blast
          using assms  is_cell_conditionE apply blast 
          using assms  is_cell_conditionE apply blast 
          using assms  is_cell_conditionE apply blast 
          unfolding is_convex_condition_def apply blast 
          unfolding condition_to_set.simps cell_def S0_def S1_def by blast 
  qed
  have 07: "is_c_decomposable m cent (condition_to_set \<C>5 - condition_to_set \<C>2)"
    apply(rule closed_interval_minus_left_closed_interval_cell_diff[of  _ _ C1 _ c d _ A0 a b' "C1 \<union> A0" ]) 
    unfolding \<C>5_def \<C>2_def apply blast apply blast apply blast apply blast
    using "00" \<C>5_def apply blast
    using \<C>2_cell_cond \<C>2_def by blast
  have 08: "(condition_to_set \<C>4 - condition_to_set \<C>3) \<inter> (condition_to_set \<C>5 - condition_to_set \<C>2) = {}"
    unfolding condition_to_set.simps \<C>4_def \<C>5_def cell_def C0_def C1_def by blast 
  show " is_c_decomposable m cent (condition_to_set \<C>1 - condition_to_set (Cond m A cent a b closed_interval))"
    unfolding 05 apply(rule c_decomposable_disjoint_union)
    using 06 apply blast 
    using 07 apply blast 
    using 08 by blast 
  show "(condition_to_set (Cond m B0 cent c d' left_closed_interval) - condition_to_set (Cond m A cent a b closed_interval)) \<inter>
    (condition_to_set \<C>1 - condition_to_set (Cond m A cent a b closed_interval)) =
    {}"
    unfolding condition_to_set.simps \<C>1_def  B0_def B1_def cell_def  by blast 
  qed
qed

definition constant_fun_glue where
"constant_fun_glue m A f c = fun_glue m A f (Qp_const m c)"

lemma constant_fun_glue_closed:
  assumes "is_semialgebraic m A"
  assumes "f \<in> carrier (SA m)"
  assumes "c \<in> carrier Q\<^sub>p"
  shows  "constant_fun_glue m A f c \<in> carrier (SA m)"
proof- 
  have 0: "Qp_const m c \<in> carrier (SA m)"
    using assms SA_car constant_function_in_semialg_functions by blast
  show ?thesis unfolding constant_fun_glue_def 
    apply(rule fun_glue_closed)
    using assms apply blast 
    using assms "0" apply linarith
    using assms by blast 
qed

lemma constant_fun_glue_formula1:
  assumes "is_semialgebraic m A"
  assumes "f \<in> carrier (SA m)"
  assumes "c \<in> carrier Q\<^sub>p"
  assumes "x \<in> A"
  shows  "constant_fun_glue m A f c x = f x"
  unfolding constant_fun_glue_def
  apply(rule fun_glueE) 
  using assms apply blast 
  using assms SA_car constant_function_in_semialg_functions apply blast
  using assms is_semialgebraic_closed apply blast
  using assms by blast 

lemma constant_fun_glue_formula2:
  assumes "is_semialgebraic m A"
  assumes "f \<in> carrier (SA m)"
  assumes "c \<in> carrier Q\<^sub>p"
  assumes "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
  assumes "x \<notin> A"
  shows  "constant_fun_glue m A f c x = c"
proof-
  have 0: "constant_fun_glue m A f c x = (Qp_const m c) x"
  unfolding constant_fun_glue_def
  using  fun_glueE'[of f m "(Qp_const m c)" A x]  assms  SA_car constant_function_in_semialg_functions  is_semialgebraic_closed 
  by blast 
  show ?thesis unfolding 0 constant_function_def using assms 
    by (metis constant_functionE constant_function_def) 
qed

lemma SA_less_fun:
  assumes "f \<in> carrier (SA m)"
  shows "\<exists>g \<in> carrier (SA m). (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (f x))"
proof-
  obtain A where A_def: "A = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). f x \<noteq> \<zero>}"
    by blast 
  obtain g where g_def: "g = fun_glue m A (\<pp>[^](-1::int) \<odot>\<^bsub>SA m\<^esub>f) (Qp_const m \<one>)"
    by blast 
  have g_closed: "g \<in> carrier (SA m)"
    unfolding g_def apply(rule fun_glue_closed) 
    using assms SA_smult_closed p_intpow_closed(1) apply blast
    using SA_car constant_function_in_semialg_functions apply blast
    unfolding A_def using assms SA_nonzero_set_is_semialg by blast
  have 1: " \<pp> [^] (-1::int) \<in> carrier Q\<^sub>p"
    using  p_intpow_closed(1)[of "(-1::int)"]  by blast
  have 0: " \<pp> [^] (-1::int) \<odot>\<^bsub>SA m\<^esub> f \<in> carrier (SA m)"
    using 1 SA_smult_closed[of f m "\<pp>[^](-1::int)" ]  assms by blast 
  have 2: "\<And>x. x \<in> A \<Longrightarrow> g x = \<pp>[^](-1::int) \<otimes> (f x)"
  proof- fix x assume A: "x \<in> A" 
    have 2: "(\<pp> [^] (-1::int) \<odot>\<^bsub>SA m\<^esub> f) x = \<pp> [^] (-1::int) \<otimes> f x"
      apply(rule SA_smult_formula[of f m "\<pp>[^](-1::int)" x])
      using assms apply blast using 1 apply blast  using A unfolding A_def by blast  
    have 3: "constant_function (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) \<one> \<in> carrier (SA m)"
      using  constant_function_in_semialg_functions[of \<one> m] Qp.cring_simprules(6) SA_car by blast
    show "g x = \<pp>[^](-1::int) \<otimes> (f x)"
    using A 0 1  3 assms 
          fun_glueE[of "\<pp>[^](-1::int) \<odot>\<^bsub>SA m\<^esub>f" m "constant_function (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) \<one>" A x] 
    unfolding g_def A_def 2 by blast 
  qed
  have 3: "val (\<pp>[^](-1::int)) = eint (-1)"
  using val_p_int_pow by blast
  have 4: "\<And>x. x \<in> A \<Longrightarrow> val (f x) \<noteq> \<infinity>"
    using assms unfolding A_def mem_Collect_eq val_def  
    using eint.distinct(1) by presburger
  hence 5: "\<And>x. x \<in> A \<Longrightarrow> val( g x) = (eint (-1)) + val (f x)"
  proof- fix x assume A: "x \<in> A"
    have "f x \<in> carrier Q\<^sub>p"
      using A assms unfolding A_def mem_Collect_eq  
      using function_ring_car_closed SA_car_memE(2) by blast
    thus "val( g x) = (eint (-1)) + val (f x)"
      using A val_mult[of "\<pp>[^](-1::int)" ] assms 3 4 unfolding A_def   
      using "1" "2" A by presburger
  qed
  hence 6: "\<And>x. x \<in> A \<Longrightarrow> val( g x) <  val (f x)"
  proof- fix x assume  A: "x \<in> A"
    then have 60: "val (g x) = (eint (-1)) + val (f x)" using 5 by blast 
    obtain m where m_def: "val (f x) = eint m "
      using A 4 by (meson eint2_cases)
    show "val (g x) < val (f x)"
      unfolding 60 m_def using 4 eint_ord_code(2) plus_eint_simps(1) by presburger   
  qed
  have "\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (f x)"
  proof fix x assume A: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    show "val (g x) < val (f x)"
    proof(cases "x \<in> A")
      case True 
      then show ?thesis using 6 by blast  
    next
      case False
      then have 00: "val (f x) = \<infinity>"
        using A unfolding A_def 
        by (metis (mono_tags, lifting) local.val_zero mem_Collect_eq)
      have 01: "g x = \<one> "
        using SA_nonzero_set_is_semialg SA_smult_closed[of f m "\<pp>[^](-1::int)" ] assms A False constant_fun_glue_formula2[of m A "\<pp> [^] (-1::int) \<odot>\<^bsub>SA m\<^esub> f" \<one>  x] 0 Qp.one_closed
        unfolding constant_fun_glue_def g_def A_def by blast 
      show ?thesis unfolding 00 01 val_one
        by simp
    qed
  qed
  then show ?thesis using g_closed by blast 
qed

lemma closed_interval_minus_closed_ray_cell_diff:
  assumes "\<C>' = Cond m A cent a b closed_interval"
  assumes "\<C> = Cond m B cent c d closed_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C>' - condition_to_set \<C>)"
proof-
  obtain g where g_def: "g \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (a x))"
    using SA_less_fun assms is_cell_conditionE by metis   
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B cent g d closed_interval" 
    by blast 
  have 0: "condition_to_set \<C>' \<inter>  condition_to_set \<C> =  condition_to_set \<C>' \<inter> condition_to_set \<C>1"
    apply(rule equalityI)
  proof
    show " \<And>x. x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C> \<Longrightarrow> x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C>1"
    proof fix x assume A: " x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C>"
      have 0: "val (a (tl x)) \<le> val (hd x \<ominus>  (cent (tl x)))"
        apply(rule closed_interval_memE[of _ _ "val (b (tl x))"])
        using A condition_to_set.simps[of m A cent a b closed_interval] cell_memE(3)[of x m A cent a b closed_interval] assms 
        unfolding assms  by blast 
      have 1: "val (hd x \<ominus>  (cent (tl x))) \<le> val (d (tl x))"
        apply(rule closed_ray_memE[of _ "val (c (tl x))" "val (d (tl x))" ])
        using A condition_to_set.simps[of m A cent c d closed_ray] cell_memE(3)[of x m B cent c d closed_ray] assms 
        unfolding  condition_to_set.simps assms  by blast 
      show "x \<in> condition_to_set \<C>'"
        using A by blast 
      have 2: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using A unfolding assms condition_to_set.simps cell_def 
        using cartesian_power_tail by blast
      have 3: "val (g (tl x)) < val (a (tl x))"
        using 2 g_def by blast
      show " x \<in> condition_to_set \<C>1 "
        unfolding \<C>1_def condition_to_set.simps
        apply(rule cell_memI) using A unfolding assms condition_to_set.simps 
        apply (meson Int_iff cell_memE(1))
        using A unfolding assms condition_to_set.simps 
        apply (meson Int_iff cell_memE(2))
        apply(rule closed_interval_memI)
        using 0 3 less_le_trans unfolding le_less  assms condition_to_set.simps 
        using "0" apply blast
        using 1 unfolding le_less by blast 
    qed
    show "condition_to_set \<C>' \<inter> condition_to_set \<C>1 \<subseteq> condition_to_set \<C>' \<inter> condition_to_set \<C>"
      unfolding \<C>1_def assms(2) condition_to_set.simps cell_def closed_interval_def closed_ray_def by blast 
  qed
  then have 1: "condition_to_set \<C>' - condition_to_set \<C> = condition_to_set \<C>' - condition_to_set \<C>1"
    by blast 
  show ?thesis unfolding 1 \<C>1_def unfolding assms  
    apply(rule closed_interval_minus_closed_interval_cell_diff[of _ _ B _ g d _ A a b "B \<union> A" ]) 
         apply blast apply blast apply blast apply blast 
     apply(rule is_cell_conditionI') 
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast 
    using assms is_cell_conditionE apply meson
    unfolding is_convex_condition_def apply blast 
    using assms unfolding assms by blast 
qed

lemma closed_interval_minus_open_ray_cell_diff:
  assumes "\<C>' = Cond m A cent a b closed_interval"
  assumes "\<C> = Cond m B cent c d open_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C>' - condition_to_set \<C>)"
proof-
  obtain g where g_def: "g \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (a x))"
    using SA_less_fun assms is_cell_conditionE by metis   
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B cent g d left_closed_interval" 
    by blast 
  have 0: "condition_to_set \<C>' \<inter>  condition_to_set \<C> =  condition_to_set \<C>' \<inter> condition_to_set \<C>1"
    apply(rule equalityI)
  proof
    show " \<And>x. x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C> \<Longrightarrow> x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C>1"
    proof fix x assume A: " x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C>"
      have 0: "val (a (tl x)) \<le> val (hd x \<ominus>  (cent (tl x)))"
        apply(rule closed_interval_memE[of _ _ "val (b (tl x))"])
        using A condition_to_set.simps[of m A cent a b closed_interval] cell_memE(3)[of x m A cent a b closed_interval] assms 
        unfolding assms  by blast 
      have 1: "val (hd x \<ominus>  (cent (tl x))) < val (d (tl x))"
        apply(rule open_ray_memE[of _ "val (c (tl x))" "val (d (tl x))" ])
        using A condition_to_set.simps[of m A cent c d open_ray] cell_memE(3)[of x m B cent c d open_ray] assms 
        unfolding  condition_to_set.simps assms  by blast 
      show "x \<in> condition_to_set \<C>'"
        using A by blast 
      have 2: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using A unfolding assms condition_to_set.simps cell_def 
        using cartesian_power_tail by blast
      have 3: "val (g (tl x)) < val (a (tl x))"
        using 2 g_def by blast
      show " x \<in> condition_to_set \<C>1 "
        unfolding \<C>1_def condition_to_set.simps
        apply(rule cell_memI) using A unfolding assms condition_to_set.simps 
        apply (meson Int_iff cell_memE(1))
        using A unfolding assms condition_to_set.simps 
        apply (meson Int_iff cell_memE(2))
        apply(rule left_closed_interval_memI)
        using 0 3 less_le_trans unfolding le_less  assms condition_to_set.simps 
        using "0" apply blast
        using 1 unfolding le_less by blast 
    qed
    show "condition_to_set \<C>' \<inter> condition_to_set \<C>1 \<subseteq> condition_to_set \<C>' \<inter> condition_to_set \<C>"
      unfolding \<C>1_def assms(2) condition_to_set.simps cell_def left_closed_interval_def open_ray_def by blast 
  qed
  then have 1: "condition_to_set \<C>' - condition_to_set \<C> = condition_to_set \<C>' - condition_to_set \<C>1"
    by blast 
  show ?thesis unfolding 1 \<C>1_def unfolding assms  
    apply(rule closed_interval_minus_left_closed_interval_cell_diff[of _ _ A _ a b _ B g d "B \<union> A" ]) 
         apply blast apply blast apply blast apply blast 
    using assms apply blast 
     apply(rule is_cell_conditionI') 
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast 
    using assms is_cell_conditionE apply meson
    unfolding is_convex_condition_def by blast 
qed

lemma left_closed_interval_minus_closed_ray_cell_diff:
  assumes "\<C>' = Cond m A cent a b left_closed_interval"
  assumes "\<C> = Cond m B cent c d closed_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C>' - condition_to_set \<C>)"
proof-
  obtain g where g_def: "g \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (a x))"
    using SA_less_fun assms is_cell_conditionE by metis   
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B cent g d closed_interval" 
    by blast 
  have 0: "condition_to_set \<C>' \<inter>  condition_to_set \<C> =  condition_to_set \<C>' \<inter> condition_to_set \<C>1"
    apply(rule equalityI)
  proof
    show " \<And>x. x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C> \<Longrightarrow> x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C>1"
    proof fix x assume A: " x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C>"
      have 0: "val (a (tl x)) \<le> val (hd x \<ominus>  (cent (tl x)))"
        apply(rule left_closed_interval_memE[of _ _ "val (b (tl x))"])
        using A condition_to_set.simps[of m A cent a b left_closed_interval] cell_memE(3)[of x m A cent a b left_closed_interval] assms 
        unfolding assms  by blast 
      have 1: "val (hd x \<ominus>  (cent (tl x))) \<le> val (d (tl x))"
        apply(rule closed_ray_memE[of _ "val (c (tl x))" "val (d (tl x))" ])
        using A condition_to_set.simps[of m A cent c d closed_ray] cell_memE(3)[of x m B cent c d closed_ray] assms 
        unfolding  condition_to_set.simps assms  by blast 
      show "x \<in> condition_to_set \<C>'"
        using A by blast 
      have 2: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using A unfolding assms condition_to_set.simps cell_def 
        using cartesian_power_tail by blast
      have 3: "val (g (tl x)) < val (a (tl x))"
        using 2 g_def by blast
      show " x \<in> condition_to_set \<C>1 "
        unfolding \<C>1_def condition_to_set.simps
        apply(rule cell_memI) using A unfolding assms condition_to_set.simps 
        apply (meson Int_iff cell_memE(1))
        using A unfolding assms condition_to_set.simps 
        apply (meson Int_iff cell_memE(2))
        apply(rule closed_interval_memI)
        using 0 3 less_le_trans unfolding le_less  assms condition_to_set.simps 
        using "0" apply blast
        using 1 unfolding le_less by blast 
    qed
    show "condition_to_set \<C>' \<inter> condition_to_set \<C>1 \<subseteq> condition_to_set \<C>' \<inter> condition_to_set \<C>"
      unfolding \<C>1_def assms(2) condition_to_set.simps cell_def closed_interval_def closed_ray_def by blast 
  qed
  then have 1: "condition_to_set \<C>' - condition_to_set \<C> = condition_to_set \<C>' - condition_to_set \<C>1"
    by blast 
  show ?thesis unfolding 1 \<C>1_def unfolding assms  
    apply(rule left_closed_interval_minus_closed_interval_cell_diff[of _ _ A _ a b _ B g d "B \<union> A" ]) 
         apply blast apply blast apply blast apply blast 
    using assms apply blast 
     apply(rule is_cell_conditionI') 
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast 
    using assms is_cell_conditionE apply meson
    unfolding is_convex_condition_def by blast 
qed

lemma left_closed_interval_minus_open_ray_cell_diff:
  assumes "\<C>' = Cond m A cent a b left_closed_interval"
  assumes "\<C> = Cond m B cent c d open_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C>' - condition_to_set \<C>)"
proof-
  obtain g where g_def: "g \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (a x))"
    using SA_less_fun assms is_cell_conditionE by metis   
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B cent g d left_closed_interval" 
    by blast 
  have 0: "condition_to_set \<C>' \<inter>  condition_to_set \<C> =  condition_to_set \<C>' \<inter> condition_to_set \<C>1"
    apply(rule equalityI)
  proof
    show " \<And>x. x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C> \<Longrightarrow> x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C>1"
    proof fix x assume A: " x \<in> condition_to_set \<C>' \<inter> condition_to_set \<C>"
      have 0: "val (a (tl x)) \<le> val (hd x \<ominus>  (cent (tl x)))"
        apply(rule left_closed_interval_memE[of _ _ "val (b (tl x))"])
        using A condition_to_set.simps[of m A cent a b left_closed_interval] cell_memE(3)[of x m A cent a b left_closed_interval] assms 
        unfolding assms  by blast 
      have 1: "val (hd x \<ominus>  (cent (tl x))) < val (d (tl x))"
        apply(rule open_ray_memE[of _ "val (c (tl x))" "val (d (tl x))" ])
        using A condition_to_set.simps[of m A cent c d open_ray] cell_memE(3)[of x m B cent c d open_ray] assms 
        unfolding  condition_to_set.simps assms  by blast 
      show "x \<in> condition_to_set \<C>'"
        using A by blast 
      have 2: "tl x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
        using A unfolding assms condition_to_set.simps cell_def 
        using cartesian_power_tail by blast
      have 3: "val (g (tl x)) < val (a (tl x))"
        using 2 g_def by blast
      show " x \<in> condition_to_set \<C>1 "
        unfolding \<C>1_def condition_to_set.simps
        apply(rule cell_memI) using A unfolding assms condition_to_set.simps 
        apply (meson Int_iff cell_memE(1))
        using A unfolding assms condition_to_set.simps 
        apply (meson Int_iff cell_memE(2))
        apply(rule left_closed_interval_memI)
        using 0 3 less_le_trans unfolding le_less  assms condition_to_set.simps 
        using "0" apply blast
        using 1 unfolding le_less by blast 
    qed
    show "condition_to_set \<C>' \<inter> condition_to_set \<C>1 \<subseteq> condition_to_set \<C>' \<inter> condition_to_set \<C>"
      unfolding \<C>1_def assms(2) condition_to_set.simps cell_def left_closed_interval_def open_ray_def by blast 
  qed
  then have 1: "condition_to_set \<C>' - condition_to_set \<C> = condition_to_set \<C>' - condition_to_set \<C>1"
    by blast 
  show ?thesis unfolding 1 \<C>1_def unfolding assms  
    apply(rule left_closed_interval_minus_left_closed_interval_cell_diff[of _ _ A _ a b _ B g d "B \<union> A" ]) 
         apply blast apply blast apply blast apply blast 
    using assms apply blast 
     apply(rule is_cell_conditionI') 
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast 
    using assms is_cell_conditionE apply meson
    unfolding is_convex_condition_def by blast 
qed

lemma closed_interval_minus_convex_condition_cell_diff:
  assumes "\<C>' = Cond m A cent a b I"
  assumes "\<C> = Cond m B cent c d closed_interval"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
  apply(cases "I = closed_interval")
  using assms closed_interval_minus_closed_interval_cell_diff apply blast
  apply(cases "I = left_closed_interval")
  using assms closed_interval_minus_left_closed_interval_cell_diff apply blast
  apply(cases "I = closed_ray")
  using assms closed_interval_minus_closed_ray_cell_diff apply blast
  using assms closed_interval_minus_open_ray_cell_diff is_cell_conditionE(5)[of m A cent a b I] 
  unfolding is_convex_condition_def  by blast  

lemma left_closed_interval_minus_convex_condition_cell_diff:
  assumes "\<C>' = Cond m A cent a b I"
  assumes "\<C> = Cond m B cent c d left_closed_interval"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
  apply(cases "I = closed_interval")
  using assms left_closed_interval_minus_closed_interval_cell_diff apply blast
  apply(cases "I = left_closed_interval")
  using assms left_closed_interval_minus_left_closed_interval_cell_diff apply blast
  apply(cases "I = closed_ray")
  using assms left_closed_interval_minus_closed_ray_cell_diff apply blast
  using assms left_closed_interval_minus_open_ray_cell_diff is_cell_conditionE(5)[of m A cent a b I] 
  unfolding is_convex_condition_def  by blast  

lemma open_ray_minus_closed_interval_cell_diff:
  assumes "\<C>' = Cond m A cent a b closed_interval"
  assumes "\<C> = Cond m B cent c d open_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  obtain h where h_def: "h \<in> carrier (SA m) \<and>(\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (h x) = min (val (a x)) (val (d x)))"
    using assms is_cell_conditionE by (metis (mono_tags, opaque_lifting) SA_min_fun)
  obtain g where g_def: "g \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (h x))"
    using h_def  by (metis SA_less_fun)
  have g_le1: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> val (g (tl x)) < val (a (tl x))"
    using h_def g_def  min.strict_boundedE by (metis Qp_pow_ConsE(1))
  have g_le2: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> val (g (tl x)) < val (d (tl x))"
    using h_def g_def min.strict_boundedE by (metis Qp_pow_ConsE(1))
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B cent g d left_closed_interval"
    by blast 
  have 0: "is_cell_condition \<C>1"
    unfolding \<C>1_def apply(rule is_cell_conditionI')
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast
    using assms is_cell_conditionE apply meson 
    unfolding is_convex_condition_def by blast 
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m B cent g g open_ray"
    by blast 
  have 1: "is_cell_condition \<C>2"
    unfolding \<C>2_def apply(rule is_cell_conditionI')
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast
    using g_def apply blast
    unfolding is_convex_condition_def by blast 
  have 2: "condition_to_set \<C> = condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    apply(rule equalityI) 
  proof
    show "\<And>x. x \<in> condition_to_set \<C> \<Longrightarrow> x \<in> condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    proof
      fix x assume A: "x \<in> condition_to_set \<C>" "x \<notin> condition_to_set \<C>2"
      show "x \<in> condition_to_set \<C>1" unfolding \<C>1_def condition_to_set.simps 
        apply(rule cell_memI) 
        using A unfolding assms condition_to_set.simps cell_def apply blast 
        using A unfolding assms condition_to_set.simps cell_def apply blast 
        apply(rule left_closed_interval_memI)
        using A unfolding \<C>2_def left_closed_interval_def assms condition_to_set.simps cell_def mem_Collect_eq 
         apply (metis (no_types, lifting) "0" Qp.cring_simprules(4) Qp_pow_ConsE(1) Qp_pow_ConsE(2) \<C>1_def assms(1) assms(2) assms(5) assms(6) g_def is_cell_condition_closure'(1) is_cell_condition_closure'(2) notin_closed open_ray_memI ultrametric_equal_eq ultrametric_equal_eq' val_ultrametric_noteq'')
        using A unfolding \<C>2_def left_closed_interval_def open_ray_def assms condition_to_set.simps cell_def mem_Collect_eq 
        by blast 
    qed
    show "condition_to_set \<C>1 \<union> condition_to_set \<C>2 \<subseteq> condition_to_set \<C>"
    proof fix x assume A: "x \<in> condition_to_set \<C>1 \<union> condition_to_set \<C>2"
      show "x \<in> condition_to_set \<C>"
        unfolding assms condition_to_set.simps 
        apply(rule cell_memI) 
        using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
        using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
        apply(rule open_ray_memI) 
        apply(cases "x \<in> condition_to_set \<C>1")
        using A unfolding open_ray_def left_closed_interval_def  \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
      proof- 
        assume A0: "x \<notin> {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> B \<and> val (hd as \<ominus> cent (tl as)) \<in> {a. val (g (tl as)) \<le> a \<and> a < val (d (tl as))}}"
        then have A1: "x \<in> condition_to_set \<C>2"
          using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def left_closed_interval_def by blast 
        show "val (hd x \<ominus> cent (tl x)) < val (d (tl x))"
        using A1 g_le2[of x] less_trans unfolding mem_Collect_eq open_ray_def left_closed_interval_def  \<C>1_def \<C>2_def condition_to_set.simps cell_def
        by blast
      qed
    qed
  qed
  have 3: "condition_to_set \<C>2 \<inter> condition_to_set \<C>' = {}"
  proof
    show "condition_to_set \<C>2 \<inter> condition_to_set \<C>' \<subseteq> {}"
    proof fix x assume A: "x \<in> condition_to_set \<C>2 \<inter> condition_to_set \<C>'"
      have 30: "val (hd x \<ominus> cent (tl x)) \<ge> val (a (tl x))"
        using A cell_memE(3) unfolding assms condition_to_set.simps 
        by (meson Int_iff closed_interval_memE)
      have 31: "val (hd x \<ominus> cent (tl x)) < val (g (tl x))"
        using A cell_memE(3) unfolding \<C>2_def condition_to_set.simps 
        by (meson Int_iff open_ray_memE)      
      show "x \<in> {}"
        using 30 31 g_le1[of x] A
        unfolding assms condition_to_set.simps cell_def \<C>2_def mem_Collect_eq 
                  open_ray_def closed_interval_def Int_iff by auto 
    qed
    show "{} \<subseteq> condition_to_set \<C>2 \<inter> condition_to_set \<C>'"
      by blast 
  qed
  have 4: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set \<C>2 \<union> (condition_to_set \<C>1 - condition_to_set \<C>')"
    using 3 2 by blast 
  have 5: "is_c_decomposable m cent (condition_to_set \<C>2)"
    using 1 unfolding \<C>2_def using c_cell_is_c_decomposable by blast
  have 6: "is_c_decomposable m cent (condition_to_set \<C>1 - condition_to_set \<C>')"
    using left_closed_interval_minus_closed_interval_cell_diff \<C>1_def assms  "0" by blast
  have 7: "(condition_to_set \<C>2) \<inter> (condition_to_set \<C>1 - condition_to_set \<C>') = {}"
    apply(rule equalityI')
    unfolding \<C>2_def \<C>1_def condition_to_set.simps 
    using cell_memE(3)  open_ray_memE left_closed_interval_memE
     apply (metis Diff_iff Int_iff basic_trans_rules(17) basic_trans_rules(20))
    by blast 
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 4 using 7 6 5 
    by (simp add: c_decomposable_disjoint_union)
qed

lemma closed_ray_minus_closed_interval_cell_diff:
  assumes "\<C>' = Cond m A cent a b closed_interval"
  assumes "\<C> = Cond m B cent c d closed_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  obtain h where h_def: "h \<in> carrier (SA m) \<and>(\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (h x) = min (val (a x)) (val (d x)))"
    using assms is_cell_conditionE by (metis (mono_tags, opaque_lifting) SA_min_fun)
  obtain g where g_def: "g \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (h x))"
    using h_def  by (metis SA_less_fun)
  have g_le1: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> val (g (tl x)) < val (a (tl x))"
    using h_def g_def  min.strict_boundedE by (metis Qp_pow_ConsE(1))
  have g_le2: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> val (g (tl x)) < val (d (tl x))"
    using h_def g_def min.strict_boundedE by (metis Qp_pow_ConsE(1))
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B cent g d closed_interval"
    by blast 
  have 0: "is_cell_condition \<C>1"
    unfolding \<C>1_def apply(rule is_cell_conditionI')
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast
    using assms is_cell_conditionE apply meson 
    unfolding is_convex_condition_def by blast 
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m B cent g g open_ray"
    by blast 
  have 1: "is_cell_condition \<C>2"
    unfolding \<C>2_def apply(rule is_cell_conditionI')
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast
    using g_def apply blast
    unfolding is_convex_condition_def by blast 
  have 2: "condition_to_set \<C> = condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    apply(rule equalityI) 
  proof
    show "\<And>x. x \<in> condition_to_set \<C> \<Longrightarrow> x \<in> condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    proof
      fix x assume A: "x \<in> condition_to_set \<C>" "x \<notin> condition_to_set \<C>2"
      show "x \<in> condition_to_set \<C>1" unfolding \<C>1_def condition_to_set.simps 
        apply(rule cell_memI) 
        using A unfolding assms condition_to_set.simps cell_def apply blast 
        using A unfolding assms condition_to_set.simps cell_def apply blast 
        apply(rule closed_interval_memI)
        using A unfolding \<C>2_def closed_interval_def assms condition_to_set.simps cell_def mem_Collect_eq 
         apply (metis (no_types, lifting) "0" Qp.cring_simprules(4) Qp_pow_ConsE(1) Qp_pow_ConsE(2) \<C>1_def assms(1) assms(2) assms(5) assms(6) g_def is_cell_condition_closure'(1) is_cell_condition_closure'(2) notin_closed open_ray_memI ultrametric_equal_eq ultrametric_equal_eq' val_ultrametric_noteq'')
        using A unfolding \<C>2_def closed_ray_def left_closed_interval_def open_ray_def assms condition_to_set.simps cell_def mem_Collect_eq 
        by blast 
    qed
    show "condition_to_set \<C>1 \<union> condition_to_set \<C>2 \<subseteq> condition_to_set \<C>"
    proof fix x assume A: "x \<in> condition_to_set \<C>1 \<union> condition_to_set \<C>2"
      show "x \<in> condition_to_set \<C>"
        unfolding assms condition_to_set.simps 
        apply(rule cell_memI) 
        using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
        using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
        apply(rule closed_ray_memI) 
        apply(cases "x \<in> condition_to_set \<C>1")
        using A unfolding open_ray_def closed_interval_def  \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
      proof- 
        assume A0: "x \<notin> {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> B \<and> val (hd as \<ominus> cent (tl as)) \<in> {a. val (g (tl as)) \<le> a \<and> a \<le> val (d (tl as))}}"
        then have A1: "x \<in> condition_to_set \<C>2"
          using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def open_ray_def closed_interval_def by blast 
        show "val (hd x \<ominus> cent (tl x)) \<le> val (d (tl x))"
          using A1 g_le2[of x] less_trans unfolding mem_Collect_eq open_ray_def left_closed_interval_def  \<C>1_def \<C>2_def condition_to_set.simps cell_def        
          by (metis (no_types, opaque_lifting) basic_trans_rules(20) g_le2 notin_closed)        
      qed
    qed
  qed
  have 3: "condition_to_set \<C>2 \<inter> condition_to_set \<C>' = {}"
  proof
    show "condition_to_set \<C>2 \<inter> condition_to_set \<C>' \<subseteq> {}"
    proof fix x assume A: "x \<in> condition_to_set \<C>2 \<inter> condition_to_set \<C>'"
      have 30: "val (hd x \<ominus> cent (tl x)) \<ge> val (a (tl x))"
        using A cell_memE(3) unfolding assms condition_to_set.simps 
        by (meson Int_iff closed_interval_memE)
      have 31: "val (hd x \<ominus> cent (tl x)) < val (g (tl x))"
        using A cell_memE(3) unfolding \<C>2_def condition_to_set.simps 
        by (meson Int_iff open_ray_memE)      
      show "x \<in> {}"
        using 30 31 g_le1[of x] A unfolding assms condition_to_set.simps cell_def 
              \<C>2_def open_ray_def closed_interval_def Int_iff mem_Collect_eq by auto           
    qed
    show "{} \<subseteq> condition_to_set \<C>2 \<inter> condition_to_set \<C>'"
      by blast 
  qed
  have 4: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set \<C>2 \<union> (condition_to_set \<C>1 - condition_to_set \<C>')"
    using 3 2 by blast 
  have 5: "is_c_decomposable m cent (condition_to_set \<C>2)"
    using 1 unfolding \<C>2_def using c_cell_is_c_decomposable by blast
  have 6: "is_c_decomposable m cent (condition_to_set \<C>1 - condition_to_set \<C>')"
    using closed_interval_minus_closed_interval_cell_diff \<C>1_def assms  "0" by blast
  have 7: "(condition_to_set \<C>2) \<inter> (condition_to_set \<C>1 - condition_to_set \<C>') = {}"
    apply(rule equalityI')
    unfolding \<C>2_def \<C>1_def condition_to_set.simps 
    using cell_memE(3)  open_ray_memE closed_interval_memE
     apply (metis Diff_iff Int_iff basic_trans_rules(17) basic_trans_rules(20))
    by blast 
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 4 using 7 6 5 
    by (simp add: c_decomposable_disjoint_union)
qed

lemma open_ray_minus_left_closed_interval_cell_diff:
  assumes "\<C>' = Cond m A cent a b left_closed_interval"
  assumes "\<C> = Cond m B cent c d open_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  obtain h where h_def: "h \<in> carrier (SA m) \<and>(\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (h x) = min (val (a x)) (val (d x)))"
    using assms is_cell_conditionE by (metis (mono_tags, opaque_lifting) SA_min_fun)
  obtain g where g_def: "g \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (h x))"
    using h_def  by (metis SA_less_fun)
  have g_le1: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> val (g (tl x)) < val (a (tl x))"
    using h_def g_def  min.strict_boundedE by (metis Qp_pow_ConsE(1))
  have g_le2: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> val (g (tl x)) < val (d (tl x))"
    using h_def g_def min.strict_boundedE by (metis Qp_pow_ConsE(1))
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B cent g d left_closed_interval"
    by blast 
  have 0: "is_cell_condition \<C>1"
    unfolding \<C>1_def apply(rule is_cell_conditionI')
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast
    using assms is_cell_conditionE apply meson 
    unfolding is_convex_condition_def by blast 
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m B cent g g open_ray"
    by blast 
  have 1: "is_cell_condition \<C>2"
    unfolding \<C>2_def apply(rule is_cell_conditionI')
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast
    using g_def apply blast
    unfolding is_convex_condition_def by blast 
  have 2: "condition_to_set \<C> = condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    apply(rule equalityI) 
  proof
    show "\<And>x. x \<in> condition_to_set \<C> \<Longrightarrow> x \<in> condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    proof
      fix x assume A: "x \<in> condition_to_set \<C>" "x \<notin> condition_to_set \<C>2"
      show "x \<in> condition_to_set \<C>1" unfolding \<C>1_def condition_to_set.simps 
        apply(rule cell_memI) 
        using A unfolding assms condition_to_set.simps cell_def apply blast 
        using A unfolding assms condition_to_set.simps cell_def apply blast 
        apply(rule left_closed_interval_memI)
        using A unfolding \<C>2_def left_closed_interval_def assms condition_to_set.simps cell_def mem_Collect_eq 
         apply (metis (no_types, lifting) "0" Qp.cring_simprules(4) Qp_pow_ConsE(1) Qp_pow_ConsE(2) \<C>1_def assms(1) assms(2) assms(5) assms(6) g_def is_cell_condition_closure'(1) is_cell_condition_closure'(2) notin_closed open_ray_memI ultrametric_equal_eq ultrametric_equal_eq' val_ultrametric_noteq'')
        using A unfolding \<C>2_def left_closed_interval_def open_ray_def assms condition_to_set.simps cell_def mem_Collect_eq 
        by blast 
    qed
    show "condition_to_set \<C>1 \<union> condition_to_set \<C>2 \<subseteq> condition_to_set \<C>"
    proof fix x assume A: "x \<in> condition_to_set \<C>1 \<union> condition_to_set \<C>2"
      show "x \<in> condition_to_set \<C>"
        unfolding assms condition_to_set.simps 
        apply(rule cell_memI) 
        using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
        using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
        apply(rule open_ray_memI) 
        apply(cases "x \<in> condition_to_set \<C>1")
        using A unfolding open_ray_def left_closed_interval_def  \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
      proof- 
        assume A0: "x \<notin> {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> B \<and> val (hd as \<ominus> cent (tl as)) \<in> {a. val (g (tl as)) \<le> a \<and> a < val (d (tl as))}}"
        then have A1: "x \<in> condition_to_set \<C>2"
          using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def left_closed_interval_def by blast 
        show "val (hd x \<ominus> cent (tl x)) < val (d (tl x))"
        using A1 g_le2[of x] less_trans unfolding mem_Collect_eq open_ray_def left_closed_interval_def  \<C>1_def \<C>2_def condition_to_set.simps cell_def
        by blast
      qed
    qed
  qed
  have 3: "condition_to_set \<C>2 \<inter> condition_to_set \<C>' = {}"
  proof
    show "condition_to_set \<C>2 \<inter> condition_to_set \<C>' \<subseteq> {}"
    proof fix x assume A: "x \<in> condition_to_set \<C>2 \<inter> condition_to_set \<C>'"
      have 30: "val (hd x \<ominus> cent (tl x)) \<ge> val (a (tl x))"
        using A cell_memE(3) unfolding assms condition_to_set.simps 
        by (meson Int_iff left_closed_interval_memE)
      have 31: "val (hd x \<ominus> cent (tl x)) < val (g (tl x))"
        using A cell_memE(3) unfolding \<C>2_def condition_to_set.simps 
        by (meson Int_iff open_ray_memE)      
      show "x \<in> {}"
        using 30 31 g_le1[of x] A less_trans 
        unfolding assms condition_to_set.simps cell_def \<C>2_def open_ray_def left_closed_interval_def
                  mem_Collect_eq Int_iff Un_iff by auto 
    qed
    show "{} \<subseteq> condition_to_set \<C>2 \<inter> condition_to_set \<C>'"
      by blast 
  qed
  have 4: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set \<C>2 \<union> (condition_to_set \<C>1 - condition_to_set \<C>')"
    using 3 2 by blast 
  have 5: "is_c_decomposable m cent (condition_to_set \<C>2)"
    using 1 unfolding \<C>2_def using c_cell_is_c_decomposable by blast
  have 6: "is_c_decomposable m cent (condition_to_set \<C>1 - condition_to_set \<C>')"
    using left_closed_interval_minus_left_closed_interval_cell_diff \<C>1_def assms  "0" by blast
  have 7: "(condition_to_set \<C>2) \<inter> (condition_to_set \<C>1 - condition_to_set \<C>') = {}"
    apply(rule equalityI')
    unfolding \<C>2_def \<C>1_def condition_to_set.simps 
    using cell_memE(3)  open_ray_memE left_closed_interval_memE
     apply (metis Diff_iff Int_iff basic_trans_rules(17) basic_trans_rules(20))
    by blast 
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 4 using 7 6 5 
    by (simp add: c_decomposable_disjoint_union)
qed

lemma closed_ray_minus_left_closed_interval_cell_diff:
  assumes "\<C>' = Cond m A cent a b left_closed_interval"
  assumes "\<C> = Cond m B cent c d closed_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  obtain h where h_def: "h \<in> carrier (SA m) \<and>(\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (h x) = min (val (a x)) (val (d x)))"
    using assms is_cell_conditionE by (metis (mono_tags, opaque_lifting) SA_min_fun)
  obtain g where g_def: "g \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (g x) < val (h x))"
    using h_def  by (metis SA_less_fun)
  have g_le1: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> val (g (tl x)) < val (a (tl x))"
    using h_def g_def  min.strict_boundedE by (metis Qp_pow_ConsE(1))
  have g_le2: "\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow> val (g (tl x)) < val (d (tl x))"
    using h_def g_def min.strict_boundedE by (metis Qp_pow_ConsE(1))
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m B cent g d closed_interval"
    by blast 
  have 0: "is_cell_condition \<C>1"
    unfolding \<C>1_def apply(rule is_cell_conditionI')
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast
    using assms is_cell_conditionE apply meson 
    unfolding is_convex_condition_def by blast 
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m B cent g g open_ray"
    by blast 
  have 1: "is_cell_condition \<C>2"
    unfolding \<C>2_def apply(rule is_cell_conditionI')
    using assms is_cell_conditionE apply blast 
    using assms is_cell_conditionE apply blast 
    using g_def apply blast
    using g_def apply blast
    unfolding is_convex_condition_def by blast 
  have 2: "condition_to_set \<C> = condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    apply(rule equalityI) 
  proof
    show "\<And>x. x \<in> condition_to_set \<C> \<Longrightarrow> x \<in> condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    proof
      fix x assume A: "x \<in> condition_to_set \<C>" "x \<notin> condition_to_set \<C>2"
      show "x \<in> condition_to_set \<C>1" unfolding \<C>1_def condition_to_set.simps 
        apply(rule cell_memI) 
        using A unfolding assms condition_to_set.simps cell_def apply blast 
        using A unfolding assms condition_to_set.simps cell_def apply blast 
        apply(rule closed_interval_memI)
        using A unfolding \<C>2_def closed_interval_def assms condition_to_set.simps cell_def mem_Collect_eq 
         apply (metis (no_types, lifting) "0" Qp.cring_simprules(4) Qp_pow_ConsE(1) Qp_pow_ConsE(2) \<C>1_def assms(1) assms(2) assms(5) assms(6) g_def is_cell_condition_closure'(1) is_cell_condition_closure'(2) notin_closed open_ray_memI ultrametric_equal_eq ultrametric_equal_eq' val_ultrametric_noteq'')
        using A unfolding \<C>2_def closed_ray_def left_closed_interval_def open_ray_def assms condition_to_set.simps cell_def mem_Collect_eq 
        by blast 
    qed
    show "condition_to_set \<C>1 \<union> condition_to_set \<C>2 \<subseteq> condition_to_set \<C>"
    proof fix x assume A: "x \<in> condition_to_set \<C>1 \<union> condition_to_set \<C>2"
      show "x \<in> condition_to_set \<C>"
        unfolding assms condition_to_set.simps 
        apply(rule cell_memI) 
        using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
        using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
        apply(rule closed_ray_memI) 
        apply(cases "x \<in> condition_to_set \<C>1")
        using A unfolding open_ray_def closed_interval_def  \<C>1_def \<C>2_def condition_to_set.simps cell_def apply blast 
      proof- 
        assume A0: "x \<notin> {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> B \<and> val (hd as \<ominus> cent (tl as)) \<in> {a. val (g (tl as)) \<le> a \<and> a \<le> val (d (tl as))}}"
        then have A1: "x \<in> condition_to_set \<C>2"
          using A unfolding \<C>1_def \<C>2_def condition_to_set.simps cell_def open_ray_def closed_interval_def by blast 
        show "val (hd x \<ominus> cent (tl x)) \<le> val (d (tl x))"
          using A1 g_le2[of x] less_trans unfolding mem_Collect_eq open_ray_def left_closed_interval_def  \<C>1_def \<C>2_def condition_to_set.simps cell_def        
          by (metis (no_types, opaque_lifting) basic_trans_rules(20) g_le2 notin_closed)        
      qed
    qed
  qed
  have 3: "condition_to_set \<C>2 \<inter> condition_to_set \<C>' = {}"
  proof
    show "condition_to_set \<C>2 \<inter> condition_to_set \<C>' \<subseteq> {}"
    proof fix x assume A: "x \<in> condition_to_set \<C>2 \<inter> condition_to_set \<C>'"
      have 30: "val (hd x \<ominus> cent (tl x)) \<ge> val (a (tl x))"
        using A cell_memE(3) unfolding assms condition_to_set.simps 
        by (meson Int_iff left_closed_interval_memE)
      have 31: "val (hd x \<ominus> cent (tl x)) < val (g (tl x))"
        using A cell_memE(3) unfolding \<C>2_def condition_to_set.simps 
        by (meson Int_iff open_ray_memE)      
      show "x \<in> {}"
        using 30 31 g_le1[of x ] A le_less_trans[of "val (a (tl x)) " "val (hd x \<ominus> cent (tl x))"  " val (g (tl x))"] unfolding assms condition_to_set.simps cell_def   
        by (metis (mono_tags, lifting) A Int_iff assms(1) basic_trans_rules(20) cell_memE(1) condition_to_set.simps)
    qed
    show "{} \<subseteq> condition_to_set \<C>2 \<inter> condition_to_set \<C>'"
      by blast 
  qed
  have 4: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set \<C>2 \<union> (condition_to_set \<C>1 - condition_to_set \<C>')"
    using 3 2 by blast 
  have 5: "is_c_decomposable m cent (condition_to_set \<C>2)"
    using 1 unfolding \<C>2_def using c_cell_is_c_decomposable by blast
  have 6: "is_c_decomposable m cent (condition_to_set \<C>1 - condition_to_set \<C>')"
    using closed_interval_minus_left_closed_interval_cell_diff \<C>1_def assms  "0" by blast
  have 7: "(condition_to_set \<C>2) \<inter> (condition_to_set \<C>1 - condition_to_set \<C>') = {}"
    apply(rule equalityI')
    unfolding \<C>2_def \<C>1_def condition_to_set.simps 
    using cell_memE(3)  open_ray_memE closed_interval_memE
     apply (metis Diff_iff Int_iff basic_trans_rules(17) basic_trans_rules(20))
    by blast 
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 4 using 7 6 5 
    by (simp add: c_decomposable_disjoint_union)
qed

lemma open_ray_minus_closed_ray_cell_diff:
  assumes "\<C> = Cond m A cent a b open_ray"
  assumes "\<C>' = Cond m B cent c d closed_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  obtain A0 where A0_def: "A0 = A - B"
    by blast 
  obtain A1 where A1_def: "A1 = A \<inter> B"
    by blast 
  have A_semialg: "is_semialgebraic m A"
    using assms is_cell_conditionE by blast 
  have B_semialg: "is_semialgebraic m B"
    using assms is_cell_conditionE by blast 
  have A0_semialg: "is_semialgebraic m A0"
    unfolding A0_def using A_semialg B_semialg diff_is_semialgebraic by blast
  have A1_semialg: "is_semialgebraic m A1"
    unfolding A1_def by (simp add: A_semialg B_semialg intersection_is_semialg)
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m A0 cent a b open_ray"
    by blast 
  have 0: "is_cell_condition \<C>1"
    unfolding \<C>1_def using assms A0_semialg change_of_fibres by blast
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m A1 cent a b open_ray"
    by blast 
  have 0: "is_cell_condition \<C>2"
    unfolding \<C>2_def using assms A1_semialg change_of_fibres by blast
  have 1: "condition_to_set \<C>1 \<inter> condition_to_set \<C>' = {}"
    unfolding \<C>1_def assms A0_def by (metis Diff_disjoint disj_fibres_imp_disj_cells inf_commute)
  have d_semialg: "d \<in> carrier (SA m)"
    using assms is_cell_conditionE by meson 
  have b_semialg: "b \<in> carrier (SA m)"
    using assms is_cell_conditionE by meson
  obtain d' where d'_def: "d' \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (d' x) = val (d x) + 1)"
    using d_semialg SA_Suc_fun by blast
  obtain B0 where B0_def: "B0 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x = \<zero>} \<inter> B"
    by blast 
  obtain B1 where B1_def: "B1 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x \<noteq> \<zero>} \<inter> B"
    by blast
  have B0_closed: "is_semialgebraic m B0"
    unfolding B0_def using assms is_cell_conditionE d_semialg SA_zero_set_is_semialg 
    by (meson intersection_is_semialg)
  have B1_closed: "is_semialgebraic m B1 "
    unfolding B1_def using assms is_cell_conditionE d_semialg nonzero_evimage_closed 
    by (meson intersection_is_semialg)
  have B_closed: "B \<subseteq> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    using assms is_cell_conditionE B_semialg is_semialgebraic_closed by presburger
  obtain \<C>3 where \<C>3_def: "\<C>3 = Cond m B0 cent c d closed_ray"
    by blast 
  obtain \<C>4 where \<C>4_def: "\<C>4 = Cond m B1 cent c d closed_ray"
    by blast 
  have \<C>3_is_cell: "is_cell_condition \<C>3"
    unfolding \<C>3_def using assms B0_closed change_of_fibres by blast
  have \<C>4_is_cell: "is_cell_condition \<C>4"
    unfolding \<C>4_def using assms B1_closed change_of_fibres by blast
  have 2: "B = B0 \<union> B1"
    using assms is_cell_conditionE(1)[of m B cent c d closed_ray] B_closed 
    unfolding B0_def B1_def assms  by blast
  have 3: "B0 \<inter> B1 = {}"
    unfolding B0_def B1_def by blast 
  have 4: "condition_to_set \<C>' = condition_to_set \<C>3 \<union> condition_to_set \<C>4"
    unfolding assms \<C>4_def \<C>3_def 2 using  union_fibres \<C>3_def \<C>3_is_cell \<C>4_def \<C>4_is_cell by blast
  have 5: "condition_to_set \<C>3 \<inter> condition_to_set \<C>4 = {}"
    unfolding assms \<C>4_def \<C>3_def 2 using 3 disjoint_fibres \<C>3_def \<C>3_is_cell \<C>4_def \<C>4_is_cell by blast
  have 6: "A = A0 \<union> A1"
    unfolding A0_def A1_def by blast 
  have 7: "condition_to_set \<C> = condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    unfolding assms \<C>1_def \<C>2_def 6 using union_fibres A0_semialg A1_semialg assms(1) assms(5) change_of_fibres 
    by blast
  have 8: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set \<C>1 \<union> (condition_to_set \<C>2 - condition_to_set \<C>')"
    unfolding 7 using 1 by blast 
  obtain D0 where D0_def: "D0 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x = \<zero>} \<inter> A1"
    by blast 
  have D0_semialg: "is_semialgebraic m D0"
    unfolding D0_def by (metis (no_types, lifting) A1_def A_semialg B0_closed B0_def Int_ac(4) intersection_is_semialg)
  obtain D1 where D1_def: "D1 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x \<noteq> \<zero>} \<inter> A1"
    by blast 
  have D1_semialg: "is_semialgebraic m D1"
    unfolding D1_def 
    apply(intro intersection_is_semialg A1_semialg)
    using d_semialg nonzero_evimage_closed  by auto 
  obtain \<C>20 where \<C>20_def: "\<C>20 = Cond m D0 cent a b open_ray"
    by blast 
  obtain \<C>21 where \<C>21_def: "\<C>21 = Cond m D1 cent a b open_ray"
    by blast 
  have 9: "is_cell_condition \<C>20 "
    unfolding \<C>20_def using assms D0_semialg change_of_fibres by blast
  have 10: "is_cell_condition \<C>21 "
    unfolding \<C>21_def using assms D1_semialg change_of_fibres by blast
  have 11: "A1 = D0 \<union> D1"
    unfolding D0_def D1_def A1_def using assms 2 B0_def B1_def by blast
  have 12: "condition_to_set \<C>2 = condition_to_set \<C>20 \<union> condition_to_set \<C>21"
    unfolding \<C>20_def \<C>21_def \<C>2_def 11 using union_fibres "10" "9" \<C>20_def \<C>21_def by blast
  have 13: "condition_to_set \<C>20 \<inter> condition_to_set \<C>4 = {}"
    unfolding \<C>20_def \<C>4_def B1_def D0_def condition_to_set.simps cell_def mem_Collect_eq by blast 
  have 14: "condition_to_set \<C>21 \<inter> condition_to_set \<C>3 = {}"
    unfolding \<C>21_def \<C>3_def B0_def D1_def condition_to_set.simps cell_def mem_Collect_eq by blast 
  have 15: "D0 \<inter> D1 = {}"
    unfolding D0_def D1_def by blast 
  have 16: "condition_to_set \<C>20 \<inter> condition_to_set \<C>21 = {}"
    unfolding \<C>20_def \<C>21_def using 15 disjoint_fibres 
    by (meson disj_fibres_imp_disj_cells)
  have 17: "condition_to_set \<C>2 - condition_to_set \<C>'
    = (condition_to_set \<C>20 - condition_to_set \<C>3) \<union> (condition_to_set \<C>21 - condition_to_set \<C>4)"
    unfolding 12 4 using 13 14 16  by blast 
  have 18: "is_c_decomposable m cent (condition_to_set \<C>20 - condition_to_set \<C>3)" 
  proof- 
    obtain E0 where E0_def: "E0 = D0 \<inter> B0"
      by blast 
    obtain E1 where E1_def: "E1 = D0 - B0"
      by blast 
    have E0_semialg: "is_semialgebraic m E0"
      unfolding E0_def by (simp add: B0_closed D0_semialg intersection_is_semialg)
    have E1_semialg: "is_semialgebraic m E1"
      unfolding E1_def by (simp add: B0_closed D0_semialg diff_is_semialgebraic)
    obtain \<C>200 where \<C>200_def: "\<C>200 = Cond m E0 cent a b open_ray"
      by blast 
    have 180: "is_cell_condition \<C>200"
      unfolding \<C>200_def using assms 
      by (metis (no_types, lifting) "9" E0_def \<C>20_def \<C>3_def \<C>3_is_cell intersection_is_semialg is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) padic_fields.is_cell_conditionE(1) padic_fields.is_cell_conditionI' padic_fields_axioms)
    obtain \<C>201 where \<C>201_def: "\<C>201 = Cond m E1 cent a b open_ray"
      by blast 
    have 181: "is_cell_condition \<C>201"
      unfolding \<C>201_def using assms 
      by (metis (no_types, lifting) "9" E1_def \<C>20_def \<C>3_def \<C>3_is_cell is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) padic_fields.diff_is_semialgebraic padic_fields.is_cell_conditionE(1) padic_fields.is_cell_conditionI' padic_fields_axioms)
    have 182: "D0 = E0 \<union> E1"
      unfolding E1_def E0_def by blast 
    have 183: "E0 \<inter> E1 = {}"
      unfolding E1_def E0_def by blast 
    have 184: "condition_to_set \<C>20 = condition_to_set \<C>200 \<union> condition_to_set \<C>201"
      unfolding \<C>20_def \<C>200_def \<C>201_def 182 
      using "180" E1_semialg \<C>200_def change_of_fibres union_fibres by blast
    have 185: "condition_to_set \<C>201 \<inter> condition_to_set \<C>3 = {}"
      unfolding \<C>3_def \<C>201_def E1_def condition_to_set.simps cell_def mem_Collect_eq by blast 
    have 186: "condition_to_set \<C>200 - condition_to_set \<C>3 = {}"
    proof
      show "condition_to_set \<C>200 - condition_to_set \<C>3 \<subseteq> {}"
      proof fix x assume A: "x \<in> condition_to_set \<C>200 - condition_to_set \<C>3"
        then have 1860: "val (d (tl x)) = \<infinity>"
          unfolding condition_to_set.simps \<C>200_def \<C>3_def cell_def E0_def B0_def Diff_iff mem_Collect_eq 
          using val_zero by (metis (mono_tags, lifting) Int_iff mem_Collect_eq)
        have 1861: "val (hd x \<ominus> cent (tl x)) \<in> open_ray (val (a (tl x))) (val (b (tl x))) - closed_ray (val (c (tl x))) (val (d (tl x)))"
          using A unfolding \<C>200_def \<C>3_def E0_def B0_def condition_to_set.simps cell_def 
          by blast 
        then show "x \<in> {}"
          using  open_ray_minus_closed_ray'[of "val (d (tl x))" "open_ray (val (a (tl x))) (val (b (tl x)))" "val (a (tl x))" "val (b (tl x))" "closed_ray (val (c (tl x))) (val (d (tl x)))" "val (c (tl x))"]
                 1860 by blast 
      qed
      show "{} \<subseteq> condition_to_set \<C>200 - condition_to_set \<C>3"
        by blast 
    qed
    have 187: "condition_to_set \<C>20 - condition_to_set \<C>3 = condition_to_set \<C>201 "
      unfolding 184 using 186 185 by blast 
    show "is_c_decomposable m cent (condition_to_set \<C>20 - condition_to_set \<C>3)"
      using 181 unfolding 187 \<C>201_def  
      using c_cell_is_c_decomposable by blast
  qed
  have 19: "is_c_decomposable m cent (condition_to_set \<C>21 - condition_to_set \<C>4)"
  proof-
    obtain E0 where E0_def: "E0 = D1 \<inter> B1"
      by blast 
    obtain E1 where E1_def: "E1 = D1 - B1"
      by blast 
    have E0_semialg: "is_semialgebraic m E0"
      unfolding E0_def by (simp add: B1_closed D1_semialg intersection_is_semialg)
    have E1_semialg: "is_semialgebraic m E1"
      unfolding E1_def by (simp add: B1_closed D1_semialg diff_is_semialgebraic)
    obtain \<C>200 where \<C>200_def: "\<C>200 = Cond m E0 cent a b open_ray"
      by blast 
    have 180: "is_cell_condition \<C>200"
      unfolding \<C>200_def using assms 
      by (metis (no_types, lifting) "10" E0_def \<C>21_def \<C>4_def \<C>4_is_cell intersection_is_semialg 
          is_cell_conditionE(1) is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) 
          is_cell_conditionE(5) padic_fields.is_cell_conditionI' padic_fields_axioms)
    obtain \<C>201 where \<C>201_def: "\<C>201 = Cond m E1 cent a b open_ray"
      by blast 
    have 181: "is_cell_condition \<C>201"
      unfolding \<C>201_def using assms 
      by (metis (no_types, lifting) "10" E1_def \<C>21_def \<C>4_def \<C>4_is_cell is_cell_conditionE(1)
          is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) 
          padic_fields.diff_is_semialgebraic padic_fields.is_cell_conditionI' padic_fields_axioms)
    have 182: "D1 = E0 \<union> E1"
      unfolding E1_def E0_def by blast 
    have 183: "E0 \<inter> E1 = {}"
      unfolding E1_def E0_def by blast 
    have 184: "condition_to_set \<C>21 = condition_to_set \<C>200 \<union> condition_to_set \<C>201"
      unfolding \<C>21_def \<C>200_def \<C>201_def 182 
      using "180" E1_semialg \<C>201_def change_of_fibres union_fibres \<C>200_def by blast      
    have 185: "condition_to_set \<C>201 \<inter> condition_to_set \<C>4 = {}"
      unfolding \<C>4_def \<C>201_def E1_def D1_def condition_to_set.simps cell_def mem_Collect_eq 
      using A1_def B0_def D1_def by blast      
    have 186: "condition_to_set \<C>200 - condition_to_set \<C>4 = condition_to_set (Cond m E0 cent d' b left_closed_interval)"
    proof
      show "condition_to_set \<C>200 - condition_to_set \<C>4 \<subseteq> condition_to_set (Cond m E0 cent d' b left_closed_interval)"
      proof fix x assume A: "x \<in> condition_to_set \<C>200 - condition_to_set \<C>4"
        then have 1860: "val (d (tl x)) \<noteq> \<infinity>"
          unfolding D1_def condition_to_set.simps \<C>200_def \<C>4_def cell_def E0_def B0_def Diff_iff mem_Collect_eq Int_iff 
          using A1_def D1_def 
          by (metis (no_types, opaque_lifting) closed_ray_memI eint_ord_code(3))            
        have 1861: "val (hd x \<ominus> cent (tl x)) \<in> open_ray (val (a (tl x))) (val (b (tl x))) - closed_ray (val (c (tl x))) (val (d (tl x)))"
          using A unfolding \<C>200_def \<C>4_def D1_def E0_def  condition_to_set.simps cell_def 
          by blast
        have 1862: "val (d' (tl x)) = val (d (tl x)) + 1"
          using d'_def A unfolding \<C>200_def condition_to_set.simps cell_def 
          using B0_def D1_def E0_def by blast
        show "x \<in> condition_to_set (Cond m E0 cent d' b left_closed_interval)"
          unfolding condition_to_set.simps 
          apply(rule cell_memI) 
          using A unfolding condition_to_set.simps \<C>200_def cell_def apply blast 
          using A unfolding condition_to_set.simps \<C>200_def cell_def apply blast 
          using  open_ray_minus_closed_ray[of "val (d (tl x))" "open_ray (val (a (tl x))) (val (b (tl x)))" "val (a (tl x))" "val (b (tl x))" "closed_ray (val (c (tl x))) (val (d (tl x)))" "val (c (tl x))"]
                 1860 1861 unfolding 1862 by blast 
      qed
      show "condition_to_set (Cond m E0 cent d' b left_closed_interval) \<subseteq> condition_to_set \<C>200 - condition_to_set \<C>4"
      proof fix x assume A: "x \<in> condition_to_set (Cond m E0 cent d' b left_closed_interval)"
        show "x \<in> condition_to_set \<C>200 - condition_to_set \<C>4"
        proof 
          show "x \<in> condition_to_set \<C>200"
            unfolding condition_to_set.simps \<C>200_def apply(rule  cell_memI)
            using A unfolding condition_to_set.simps cell_def apply blast 
            using A unfolding condition_to_set.simps cell_def apply blast 
            apply(rule open_ray_memI)
            using A cell_memE(3)[of x] left_closed_interval_memE
            unfolding condition_to_set.simps by blast 
          show "x \<notin> condition_to_set \<C>4"
          proof- 
            have 00: "val (hd x \<ominus> cent (tl x)) \<ge>  val (d' (tl x))"
              using A cell_memE(3)[of x] left_closed_interval_memE
              unfolding condition_to_set.simps by blast 
            have 01: "val (d (tl x)) \<noteq>  \<infinity>"
              using A unfolding val_def condition_to_set.simps cell_def E0_def D1_def mem_Collect_eq Int_iff 
              using eint.distinct(1) by presburger 
            have 02: "val (d' (tl x)) = val (d (tl x)) + 1"
              using d'_def A unfolding condition_to_set.simps cell_def 
              using Qp_pow_ConsE(1) by blast
            have 03:  "val (d' (tl x)) > val (d (tl x))"
            proof- obtain m where m_def: "val (d (tl x)) = eint m "
                using 01 by blast
              show ?thesis  using 01 02 unfolding m_def
               using eint_ord_simps(1) iless_Suc_eq by presburger
            qed
            then have "\<not> (val (hd x \<ominus> cent (tl x)) \<le> val (d (tl x)))"
              using 00 less_le_trans by blast
            thus "x \<notin> condition_to_set \<C>4"
              using A 
              unfolding E0_def \<C>4_def condition_to_set.simps cell_def closed_ray_def mem_Collect_eq
              by blast 
          qed
        qed
      qed
    qed
    have 187: "condition_to_set \<C>21 - condition_to_set \<C>4 = condition_to_set \<C>201 \<union> condition_to_set (Cond m E0 cent d' b left_closed_interval) "
      unfolding 184 using 186 185 by blast 
    show "is_c_decomposable m cent (condition_to_set \<C>21 - condition_to_set \<C>4)"
      unfolding 187 
      apply(rule c_decomposable_disjoint_union)
      using "181" \<C>201_def c_cell_is_c_decomposable apply blast
       apply(rule c_cell_is_c_decomposable)
       apply(rule is_cell_conditionI')
      using E0_semialg apply blast
      using assms is_cell_conditionE apply blast 
      using d'_def apply blast 
      using assms is_cell_conditionE apply meson 
      using is_convex_condition_def apply blast
      apply(rule equalityI')
      unfolding E1_def E0_def  \<C>201_def condition_to_set.simps cell_def  Int_iff mem_Collect_eq apply blast 
      by blast      
  qed
  have 20:  "is_c_decomposable m cent (condition_to_set \<C>2 - condition_to_set \<C>')"
    unfolding 17 
      apply(rule c_decomposable_disjoint_union)
    using 18 apply blast 
    using 19 apply blast 
    using 16 by blast 
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 8 
      apply(rule c_decomposable_disjoint_union)
    using 1 unfolding \<C>1_def 
      apply (metis (no_types, lifting) A0_semialg assms(1) assms(5) c_cell_is_c_decomposable is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) padic_fields.is_cell_conditionI' padic_fields_axioms)
    using 20 apply blast 
    unfolding \<C>2_def A0_def A1_def condition_to_set.simps  cell_def 
    by blast 
qed

lemma closed_ray_minus_closed_ray_cell_diff:
  assumes "\<C> = Cond m A cent a b closed_ray"
  assumes "\<C>' = Cond m B cent c d closed_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  obtain A0 where A0_def: "A0 = A - B"
    by blast 
  obtain A1 where A1_def: "A1 = A \<inter> B"
    by blast 
  have A_semialg: "is_semialgebraic m A"
    using assms is_cell_conditionE by blast 
  have B_semialg: "is_semialgebraic m B"
    using assms is_cell_conditionE by blast 
  have A0_semialg: "is_semialgebraic m A0"
    unfolding A0_def using A_semialg B_semialg diff_is_semialgebraic by blast
  have A1_semialg: "is_semialgebraic m A1"
    unfolding A1_def by (simp add: A_semialg B_semialg intersection_is_semialg)
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m A0 cent a b closed_ray"
    by blast 
  have 0: "is_cell_condition \<C>1"
    unfolding \<C>1_def using assms A0_semialg change_of_fibres by blast
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m A1 cent a b closed_ray"
    by blast 
  have 0: "is_cell_condition \<C>2"
    unfolding \<C>2_def using assms A1_semialg change_of_fibres by blast
  have 1: "condition_to_set \<C>1 \<inter> condition_to_set \<C>' = {}"
    unfolding \<C>1_def assms A0_def by (metis Diff_disjoint disj_fibres_imp_disj_cells inf_commute)
  have d_semialg: "d \<in> carrier (SA m)"
    using assms is_cell_conditionE by meson 
  have b_semialg: "b \<in> carrier (SA m)"
    using assms is_cell_conditionE by meson
  obtain d' where d'_def: "d' \<in> carrier (SA m) \<and> (\<forall>x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (d' x) = val (d x) + 1)"
    using d_semialg SA_Suc_fun by blast
  obtain B0 where B0_def: "B0 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x = \<zero>} \<inter> B"
    by blast 
  obtain B1 where B1_def: "B1 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x \<noteq> \<zero>} \<inter> B"
    by blast
  have B0_closed: "is_semialgebraic m B0"
    unfolding B0_def using assms is_cell_conditionE d_semialg SA_zero_set_is_semialg 
    by (meson intersection_is_semialg)
  have B1_closed: "is_semialgebraic m B1 "
    unfolding B1_def using assms is_cell_conditionE d_semialg nonzero_evimage_closed 
    by (meson intersection_is_semialg)
  have B_closed: "B \<subseteq> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    using assms is_cell_conditionE B_semialg is_semialgebraic_closed by presburger
  obtain \<C>3 where \<C>3_def: "\<C>3 = Cond m B0 cent c d closed_ray"
    by blast 
  obtain \<C>4 where \<C>4_def: "\<C>4 = Cond m B1 cent c d closed_ray"
    by blast 
  have \<C>3_is_cell: "is_cell_condition \<C>3"
    unfolding \<C>3_def using assms B0_closed change_of_fibres by blast
  have \<C>4_is_cell: "is_cell_condition \<C>4"
    unfolding \<C>4_def using assms B1_closed change_of_fibres by blast
  have 2: "B = B0 \<union> B1"
    using assms is_cell_conditionE(1)[of m B cent c d closed_ray] B_closed 
    unfolding B0_def B1_def assms  by blast
  have 3: "B0 \<inter> B1 = {}"
    unfolding B0_def B1_def by blast 
  have 4: "condition_to_set \<C>' = condition_to_set \<C>3 \<union> condition_to_set \<C>4"
    unfolding assms \<C>4_def \<C>3_def 2 using  union_fibres \<C>3_def \<C>3_is_cell \<C>4_def \<C>4_is_cell by blast
  have 5: "condition_to_set \<C>3 \<inter> condition_to_set \<C>4 = {}"
    unfolding assms \<C>4_def \<C>3_def 2 using 3 disjoint_fibres \<C>3_def \<C>3_is_cell \<C>4_def \<C>4_is_cell by blast
  have 6: "A = A0 \<union> A1"
    unfolding A0_def A1_def by blast 
  have 7: "condition_to_set \<C> = condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    unfolding assms \<C>1_def \<C>2_def 6 using union_fibres A0_semialg A1_semialg assms(1) assms(5) change_of_fibres 
    by blast
  have 8: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set \<C>1 \<union> (condition_to_set \<C>2 - condition_to_set \<C>')"
    unfolding 7 using 1 by blast 
  obtain D0 where D0_def: "D0 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x = \<zero>} \<inter> A1"
    by blast 
  have D0_semialg: "is_semialgebraic m D0"
    unfolding D0_def by (metis (no_types, lifting) A1_def A_semialg B0_closed B0_def Int_ac(4) intersection_is_semialg)
  obtain D1 where D1_def: "D1 = {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). d x \<noteq> \<zero>} \<inter> A1"
    by blast 
  have D1_semialg: "is_semialgebraic m D1"
    unfolding D1_def 
    by(intro intersection_is_semialg SA_nonzero_set_is_semialg d_semialg A1_semialg)
  obtain \<C>20 where \<C>20_def: "\<C>20 = Cond m D0 cent a b closed_ray"
    by blast 
  obtain \<C>21 where \<C>21_def: "\<C>21 = Cond m D1 cent a b closed_ray"
    by blast 
  have 9: "is_cell_condition \<C>20 "
    unfolding \<C>20_def using assms D0_semialg change_of_fibres by blast
  have 10: "is_cell_condition \<C>21 "
    unfolding \<C>21_def using assms D1_semialg change_of_fibres by blast
  have 11: "A1 = D0 \<union> D1"
    unfolding D0_def D1_def A1_def using assms 2 B0_def B1_def by blast
  have 12: "condition_to_set \<C>2 = condition_to_set \<C>20 \<union> condition_to_set \<C>21"
    unfolding \<C>20_def \<C>21_def \<C>2_def 11 using union_fibres "10" "9" \<C>20_def \<C>21_def by blast
  have 13: "condition_to_set \<C>20 \<inter> condition_to_set \<C>4 = {}"
    unfolding \<C>20_def \<C>4_def B1_def D0_def condition_to_set.simps cell_def mem_Collect_eq by blast 
  have 14: "condition_to_set \<C>21 \<inter> condition_to_set \<C>3 = {}"
    unfolding \<C>21_def \<C>3_def B0_def D1_def condition_to_set.simps cell_def mem_Collect_eq by blast 
  have 15: "D0 \<inter> D1 = {}"
    unfolding D0_def D1_def by blast 
  have 16: "condition_to_set \<C>20 \<inter> condition_to_set \<C>21 = {}"
    unfolding \<C>20_def \<C>21_def using 15 disjoint_fibres 
    by (meson disj_fibres_imp_disj_cells)
  have 17: "condition_to_set \<C>2 - condition_to_set \<C>'
    = (condition_to_set \<C>20 - condition_to_set \<C>3) \<union> (condition_to_set \<C>21 - condition_to_set \<C>4)"
    unfolding 12 4 using 13 14 16  by blast 
  have 18: "is_c_decomposable m cent (condition_to_set \<C>20 - condition_to_set \<C>3)" 
  proof- 
    obtain E0 where E0_def: "E0 = D0 \<inter> B0"
      by blast 
    obtain E1 where E1_def: "E1 = D0 - B0"
      by blast 
    have E0_semialg: "is_semialgebraic m E0"
      unfolding E0_def by (simp add: B0_closed D0_semialg intersection_is_semialg)
    have E1_semialg: "is_semialgebraic m E1"
      unfolding E1_def by (simp add: B0_closed D0_semialg diff_is_semialgebraic)
    obtain \<C>200 where \<C>200_def: "\<C>200 = Cond m E0 cent a b closed_ray"
      by blast 
    have 180: "is_cell_condition \<C>200"
      unfolding \<C>200_def using assms 
      by (metis (no_types, lifting) "9" E0_def \<C>20_def \<C>3_def \<C>3_is_cell intersection_is_semialg is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) padic_fields.is_cell_conditionE(1) padic_fields.is_cell_conditionI' padic_fields_axioms)
    obtain \<C>201 where \<C>201_def: "\<C>201 = Cond m E1 cent a b closed_ray"
      by blast 
    have 181: "is_cell_condition \<C>201"
      unfolding \<C>201_def using assms 
      by (metis (no_types, lifting) "9" E1_def \<C>20_def \<C>3_def \<C>3_is_cell is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) padic_fields.diff_is_semialgebraic padic_fields.is_cell_conditionE(1) padic_fields.is_cell_conditionI' padic_fields_axioms)
    have 182: "D0 = E0 \<union> E1"
      unfolding E1_def E0_def by blast 
    have 183: "E0 \<inter> E1 = {}"
      unfolding E1_def E0_def by blast 
    have 184: "condition_to_set \<C>20 = condition_to_set \<C>200 \<union> condition_to_set \<C>201"
      unfolding \<C>20_def \<C>200_def \<C>201_def 182 
      using "180" E1_semialg \<C>200_def change_of_fibres union_fibres by blast
    have 185: "condition_to_set \<C>201 \<inter> condition_to_set \<C>3 = {}"
      unfolding \<C>3_def \<C>201_def E1_def condition_to_set.simps cell_def mem_Collect_eq by blast 
    have 186: "condition_to_set \<C>200 - condition_to_set \<C>3 = {}"
    proof
      show "condition_to_set \<C>200 - condition_to_set \<C>3 \<subseteq> {}"
      proof fix x assume A: "x \<in> condition_to_set \<C>200 - condition_to_set \<C>3"
        then have 1860: "val (d (tl x)) = \<infinity>"
          unfolding condition_to_set.simps \<C>200_def \<C>3_def cell_def E0_def B0_def Diff_iff mem_Collect_eq 
          using val_zero by (metis (mono_tags, lifting) Int_iff mem_Collect_eq)
        have 1861: "val (hd x \<ominus> cent (tl x)) \<in> closed_ray (val (a (tl x))) (val (b (tl x))) - closed_ray (val (c (tl x))) (val (d (tl x)))"
          using A unfolding \<C>200_def \<C>3_def E0_def B0_def condition_to_set.simps cell_def 
          by blast 
        then show "x \<in> {}"
          using  closed_ray_minus_closed_ray'[of "val (d (tl x))" "closed_ray (val (a (tl x))) (val (b (tl x)))" "val (a (tl x))" "val (b (tl x))" "closed_ray (val (c (tl x))) (val (d (tl x)))" "val (c (tl x))"]
                 1860 by blast 
      qed
      show "{} \<subseteq> condition_to_set \<C>200 - condition_to_set \<C>3"
        by blast 
    qed
    have 187: "condition_to_set \<C>20 - condition_to_set \<C>3 = condition_to_set \<C>201 "
      unfolding 184 using 186 185 by blast 
    show "is_c_decomposable m cent (condition_to_set \<C>20 - condition_to_set \<C>3)"
      using 181 unfolding 187 \<C>201_def  
      using c_cell_is_c_decomposable by blast
  qed
  have 19: "is_c_decomposable m cent (condition_to_set \<C>21 - condition_to_set \<C>4)"
  proof-
    obtain E0 where E0_def: "E0 = D1 \<inter> B1"
      by blast 
    obtain E1 where E1_def: "E1 = D1 - B1"
      by blast 
    have E0_semialg: "is_semialgebraic m E0"
      unfolding E0_def by (simp add: B1_closed D1_semialg intersection_is_semialg)
    have E1_semialg: "is_semialgebraic m E1"
      unfolding E1_def by (simp add: B1_closed D1_semialg diff_is_semialgebraic)
    obtain \<C>200 where \<C>200_def: "\<C>200 = Cond m E0 cent a b closed_ray"
      by blast 
    have 180: "is_cell_condition \<C>200"
      unfolding \<C>200_def using assms 
      by (metis (no_types, lifting) "10" E0_def \<C>21_def \<C>4_def \<C>4_is_cell intersection_is_semialg 
          is_cell_conditionE(1) is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) 
          is_cell_conditionE(5) padic_fields.is_cell_conditionI' padic_fields_axioms)
    obtain \<C>201 where \<C>201_def: "\<C>201 = Cond m E1 cent a b closed_ray"
      by blast 
    have 181: "is_cell_condition \<C>201"
      unfolding \<C>201_def using assms 
      by (metis (no_types, lifting) "10" E1_def \<C>21_def \<C>4_def \<C>4_is_cell is_cell_conditionE(1)
          is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) 
          padic_fields.diff_is_semialgebraic padic_fields.is_cell_conditionI' padic_fields_axioms)
    have 182: "D1 = E0 \<union> E1"
      unfolding E1_def E0_def by blast 
    have 183: "E0 \<inter> E1 = {}"
      unfolding E1_def E0_def by blast 
    have 184: "condition_to_set \<C>21 = condition_to_set \<C>200 \<union> condition_to_set \<C>201"
      unfolding \<C>21_def \<C>200_def \<C>201_def 182 
      using "180" E1_semialg \<C>201_def change_of_fibres union_fibres \<C>200_def by blast      
    have 185: "condition_to_set \<C>201 \<inter> condition_to_set \<C>4 = {}"
      unfolding \<C>4_def \<C>201_def E1_def D1_def condition_to_set.simps cell_def mem_Collect_eq 
      using A1_def B0_def D1_def by blast      
    have 186: "condition_to_set \<C>200 - condition_to_set \<C>4 = condition_to_set (Cond m E0 cent d' b closed_interval)"
    proof
      show "condition_to_set \<C>200 - condition_to_set \<C>4 \<subseteq> condition_to_set (Cond m E0 cent d' b closed_interval)"
      proof fix x assume A: "x \<in> condition_to_set \<C>200 - condition_to_set \<C>4"
        then have 1860: "val (d (tl x)) \<noteq> \<infinity>"
          unfolding D1_def condition_to_set.simps \<C>200_def \<C>4_def cell_def E0_def B0_def Diff_iff mem_Collect_eq Int_iff 
          using A1_def D1_def 
          by (metis (no_types, opaque_lifting) closed_ray_memI eint_ord_code(3))            
        have 1861: "val (hd x \<ominus> cent (tl x)) \<in> closed_ray (val (a (tl x))) (val (b (tl x))) - closed_ray (val (c (tl x))) (val (d (tl x)))"
          using A unfolding \<C>200_def \<C>4_def D1_def E0_def  condition_to_set.simps cell_def 
          by blast
        have 1862: "val (d' (tl x)) = val (d (tl x)) + 1"
          using d'_def A unfolding \<C>200_def condition_to_set.simps cell_def 
          using B0_def D1_def E0_def by blast
        show "x \<in> condition_to_set (Cond m E0 cent d' b closed_interval)"
          unfolding condition_to_set.simps 
          apply(rule cell_memI) 
          using A unfolding condition_to_set.simps \<C>200_def cell_def apply blast 
          using A unfolding condition_to_set.simps \<C>200_def cell_def apply blast 
          using  closed_ray_minus_closed_ray[of "val (d (tl x))" "closed_ray (val (a (tl x))) (val (b (tl x)))" "val (a (tl x))" "val (b (tl x))" "closed_ray (val (c (tl x))) (val (d (tl x)))" "val (c (tl x))"]
                 1860 1861 unfolding 1862 by blast 
      qed
      show "condition_to_set (Cond m E0 cent d' b closed_interval) \<subseteq> condition_to_set \<C>200 - condition_to_set \<C>4"
      proof fix x assume A: "x \<in> condition_to_set (Cond m E0 cent d' b closed_interval)"
        show "x \<in> condition_to_set \<C>200 - condition_to_set \<C>4"
        proof 
          show "x \<in> condition_to_set \<C>200"
            unfolding condition_to_set.simps \<C>200_def apply(rule  cell_memI)
            using A unfolding condition_to_set.simps cell_def apply blast 
            using A unfolding condition_to_set.simps cell_def apply blast 
            apply(rule closed_ray_memI)
            using A cell_memE(3)[of x] closed_interval_memE
            unfolding condition_to_set.simps by blast 
          show "x \<notin> condition_to_set \<C>4"
          proof- 
            have 00: "val (hd x \<ominus> cent (tl x)) \<ge>  val (d' (tl x))"
              using A cell_memE(3)[of x] closed_interval_memE
              unfolding condition_to_set.simps by blast 
            have 01: "val (d (tl x)) \<noteq>  \<infinity>"
              using A unfolding val_def condition_to_set.simps cell_def E0_def D1_def mem_Collect_eq Int_iff 
              using eint.distinct(1) by presburger 
            have 02: "val (d' (tl x)) = val (d (tl x)) + 1"
              using d'_def A unfolding condition_to_set.simps cell_def 
              using Qp_pow_ConsE(1) by blast
            have 03:  "val (d' (tl x)) > val (d (tl x))"
            proof- obtain m where m_def: "val (d (tl x)) = eint m "
                using 01 by blast
              show ?thesis  using 01 02 unfolding m_def
               using eint_ord_simps(1) iless_Suc_eq by presburger
            qed
            then have "\<not> (val (hd x \<ominus> cent (tl x)) \<le> val (d (tl x)))"
              using 00 less_le_trans by blast
            thus "x \<notin> condition_to_set \<C>4"
              using A 
              unfolding E0_def \<C>4_def condition_to_set.simps cell_def closed_ray_def mem_Collect_eq
              by blast 
          qed
        qed
      qed
    qed
    have 187: "condition_to_set \<C>21 - condition_to_set \<C>4 = condition_to_set \<C>201 \<union> condition_to_set (Cond m E0 cent d' b closed_interval) "
      unfolding 184 using 186 185 by blast 
    show "is_c_decomposable m cent (condition_to_set \<C>21 - condition_to_set \<C>4)"
      unfolding 187 
      apply(rule c_decomposable_disjoint_union)
      using "181" \<C>201_def c_cell_is_c_decomposable apply blast
       apply(rule c_cell_is_c_decomposable)
       apply(rule is_cell_conditionI')
      using E0_semialg apply blast
      using assms is_cell_conditionE apply blast 
      using d'_def apply blast 
      using assms is_cell_conditionE apply meson 
      using is_convex_condition_def apply blast
      unfolding E1_def E0_def  \<C>201_def condition_to_set.simps cell_def by blast 
  qed
  have 20:  "is_c_decomposable m cent (condition_to_set \<C>2 - condition_to_set \<C>')"
    unfolding 17 
      apply(rule c_decomposable_disjoint_union)
    using 18 apply blast 
    using 19 apply blast 
    using 16 by blast 
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 8 
      apply(rule c_decomposable_disjoint_union)
    using 1 unfolding \<C>1_def 
      apply (metis (no_types, lifting) A0_semialg assms(1) assms(5) c_cell_is_c_decomposable is_cell_conditionE(2) is_cell_conditionE(3) is_cell_conditionE(4) is_cell_conditionE(5) padic_fields.is_cell_conditionI' padic_fields_axioms)
    using 20 apply blast 
    unfolding \<C>2_def A0_def A1_def condition_to_set.simps  cell_def 
    by blast 
qed

lemma closed_ray_minus_open_ray_cell_diff:
  assumes "\<C> = Cond m A cent a b closed_ray"
  assumes "\<C>' = Cond m B cent c d open_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  obtain A0 where A0_def: "A0 = A - B"
    by blast 
  obtain A1 where A1_def: "A1 = A \<inter> B"
    by blast 
  have A_semialg: "is_semialgebraic m A"
    using assms is_cell_conditionE by blast 
  have B_semialg: "is_semialgebraic m B"
    using assms is_cell_conditionE by blast 
  have A0_semialg: "is_semialgebraic m A0"
    unfolding A0_def using A_semialg B_semialg diff_is_semialgebraic by blast
  have A1_semialg: "is_semialgebraic m A1"
    unfolding A1_def by (simp add: A_semialg B_semialg intersection_is_semialg)
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m A0 cent a b closed_ray"
    by blast 
  have 0: "is_cell_condition \<C>1"
    unfolding \<C>1_def using assms A0_semialg change_of_fibres by blast
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m A1 cent a b closed_ray"
    by blast 
  have 0: "is_cell_condition \<C>2"
    unfolding \<C>2_def using assms A1_semialg change_of_fibres by blast
  have 1: "condition_to_set \<C>1 \<inter> condition_to_set \<C>' = {}"
    unfolding \<C>1_def assms A0_def by (metis Diff_disjoint disj_fibres_imp_disj_cells inf_commute)
  have d_semialg: "d \<in> carrier (SA m)"
    using assms is_cell_conditionE by meson 
  have b_semialg: "b \<in> carrier (SA m)"
    using assms is_cell_conditionE by meson
  have B_closed: "B \<subseteq> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    using assms is_cell_conditionE B_semialg is_semialgebraic_closed by presburger
  have 6: "A = A0 \<union> A1"
    unfolding A0_def A1_def by blast 
  have 7: "condition_to_set \<C> = condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    unfolding assms \<C>1_def \<C>2_def 6 using union_fibres A0_semialg A1_semialg assms(1) assms(5) change_of_fibres 
    by blast
  have 8: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set \<C>1 \<union> (condition_to_set \<C>2 - condition_to_set \<C>')"
    unfolding 7 using 1 by blast 
  have 9: "is_c_decomposable  m cent (condition_to_set \<C>2 - condition_to_set \<C>')"
  proof-
    have 90: "condition_to_set \<C>2 - condition_to_set \<C>' = condition_to_set (Cond m A1 cent d b closed_interval)"
    proof
      show "condition_to_set \<C>2 - condition_to_set \<C>' \<subseteq> condition_to_set (Cond m A1 cent d b closed_interval)"
      proof fix x assume A: "x \<in> condition_to_set \<C>2 - condition_to_set \<C>'"
        show "x \<in> condition_to_set (Cond m A1 cent d b closed_interval)"
          unfolding condition_to_set.simps  apply(rule cell_memI) 
          using A unfolding condition_to_set.simps \<C>2_def cell_def apply blast 
          using A unfolding condition_to_set.simps \<C>2_def cell_def apply blast 
          apply(rule closed_interval_memI)
          using A unfolding A1_def assms open_ray_def condition_to_set.simps \<C>2_def cell_def Diff_iff mem_Collect_eq
          apply auto[1]
          using A unfolding A1_def assms closed_ray_def condition_to_set.simps \<C>2_def cell_def Diff_iff mem_Collect_eq
          by blast 
      qed
      show "condition_to_set (Cond m A1 cent d b closed_interval) \<subseteq> condition_to_set \<C>2 - condition_to_set \<C>'"
      proof fix x assume A: "x \<in> condition_to_set (Cond m A1 cent d b closed_interval)"
        show "x \<in> condition_to_set \<C>2 - condition_to_set \<C>'"
        proof
          show "x \<in> condition_to_set \<C>2"
            unfolding \<C>2_def condition_to_set.simps apply(rule cell_memI)
            using A unfolding condition_to_set.simps cell_def apply blast
            using A unfolding condition_to_set.simps cell_def apply blast 
            apply(rule closed_ray_memI)
            using A unfolding condition_to_set.simps cell_def  closed_interval_def by blast 
          show " x \<notin> condition_to_set \<C>'"
            using A unfolding assms condition_to_set.simps  cell_def  
                          closed_interval_def open_ray_def  mem_Collect_eq A1_def 
            using not_less[of "val (hd x \<ominus> cent (tl x))" "val (d (tl x))"]
            by blast 
        qed
      qed
    qed
    have 91: "is_cell_condition (Cond m A1 cent d b closed_interval)"
      apply(rule is_cell_conditionI')
      using A1_semialg apply blast
      using assms is_cell_conditionE apply blast 
      using assms is_cell_conditionE apply meson
      using assms is_cell_conditionE apply meson
      unfolding is_convex_condition_def by blast 
    show ?thesis unfolding 90 
      using 91 c_cell_is_c_decomposable by blast
  qed
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 8 
    apply(rule c_decomposable_disjoint_union)
    using 0 unfolding \<C>2_def  using A0_semialg \<C>1_def c_cell_is_c_decomposable change_of_fibres apply blast
    using 9  unfolding \<C>2_def apply blast 
    unfolding \<C>1_def A0_def A1_def condition_to_set.simps cell_def  by blast 
qed

lemma open_ray_minus_open_ray_cell_diff:
  assumes "\<C> = Cond m A cent a b open_ray"
  assumes "\<C>' = Cond m B cent c d open_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
proof- 
  obtain A0 where A0_def: "A0 = A - B"
    by blast 
  obtain A1 where A1_def: "A1 = A \<inter> B"
    by blast 
  have A_semialg: "is_semialgebraic m A"
    using assms is_cell_conditionE by blast 
  have B_semialg: "is_semialgebraic m B"
    using assms is_cell_conditionE by blast 
  have A0_semialg: "is_semialgebraic m A0"
    unfolding A0_def using A_semialg B_semialg diff_is_semialgebraic by blast
  have A1_semialg: "is_semialgebraic m A1"
    unfolding A1_def by (simp add: A_semialg B_semialg intersection_is_semialg)
  obtain \<C>1 where \<C>1_def: "\<C>1 = Cond m A0 cent a b open_ray"
    by blast 
  have 0: "is_cell_condition \<C>1"
    unfolding \<C>1_def using assms A0_semialg change_of_fibres by blast
  obtain \<C>2 where \<C>2_def: "\<C>2 = Cond m A1 cent a b open_ray"
    by blast 
  have 0: "is_cell_condition \<C>2"
    unfolding \<C>2_def using assms A1_semialg change_of_fibres by blast
  have 1: "condition_to_set \<C>1 \<inter> condition_to_set \<C>' = {}"
    unfolding \<C>1_def assms A0_def by (metis Diff_disjoint disj_fibres_imp_disj_cells inf_commute)
  have d_semialg: "d \<in> carrier (SA m)"
    using assms is_cell_conditionE by meson 
  have b_semialg: "b \<in> carrier (SA m)"
    using assms is_cell_conditionE by meson
  have B_closed: "B \<subseteq> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
    using assms is_cell_conditionE B_semialg is_semialgebraic_closed by presburger
  have 6: "A = A0 \<union> A1"
    unfolding A0_def A1_def by blast 
  have 7: "condition_to_set \<C> = condition_to_set \<C>1 \<union> condition_to_set \<C>2"
    unfolding assms \<C>1_def \<C>2_def 6 using union_fibres A0_semialg A1_semialg assms(1) assms(5) change_of_fibres 
    by blast
  have 8: "condition_to_set \<C> - condition_to_set \<C>' = condition_to_set \<C>1 \<union> (condition_to_set \<C>2 - condition_to_set \<C>')"
    unfolding 7 using 1 by blast 
  have 9: "is_c_decomposable  m cent (condition_to_set \<C>2 - condition_to_set \<C>')"
  proof-
    have 90: "condition_to_set \<C>2 - condition_to_set \<C>' = condition_to_set (Cond m A1 cent d b left_closed_interval)"
    proof
      show "condition_to_set \<C>2 - condition_to_set \<C>' \<subseteq> condition_to_set (Cond m A1 cent d b left_closed_interval)"
      proof fix x assume A: "x \<in> condition_to_set \<C>2 - condition_to_set \<C>'"
        show "x \<in> condition_to_set (Cond m A1 cent d b left_closed_interval)"
          unfolding condition_to_set.simps  apply(rule cell_memI) 
          using A unfolding condition_to_set.simps \<C>2_def cell_def apply blast 
          using A unfolding condition_to_set.simps \<C>2_def cell_def apply blast 
          apply(rule left_closed_interval_memI)
          using A unfolding A1_def assms open_ray_def condition_to_set.simps \<C>2_def cell_def Diff_iff mem_Collect_eq
          by auto 
      qed
      show "condition_to_set (Cond m A1 cent d b left_closed_interval) \<subseteq> condition_to_set \<C>2 - condition_to_set \<C>'"
      proof fix x assume A: "x \<in> condition_to_set (Cond m A1 cent d b left_closed_interval)"
        show "x \<in> condition_to_set \<C>2 - condition_to_set \<C>'"
        proof
          show "x \<in> condition_to_set \<C>2"
            unfolding \<C>2_def condition_to_set.simps apply(rule cell_memI)
            using A unfolding condition_to_set.simps cell_def apply blast
            using A unfolding condition_to_set.simps cell_def apply blast 
            apply(rule open_ray_memI)
            using A unfolding condition_to_set.simps cell_def  left_closed_interval_def by blast 
          show " x \<notin> condition_to_set \<C>'"
            using A unfolding assms condition_to_set.simps  cell_def  
                          left_closed_interval_def open_ray_def  mem_Collect_eq A1_def 
            using not_less[of "val (hd x \<ominus> cent (tl x))" "val (d (tl x))"]
            by blast 
        qed
      qed
    qed
    have 91: "is_cell_condition (Cond m A1 cent d b left_closed_interval)"
      apply(rule is_cell_conditionI')
      using A1_semialg apply blast
      using assms is_cell_conditionE apply blast 
      using assms is_cell_conditionE apply meson
      using assms is_cell_conditionE apply meson
      unfolding is_convex_condition_def by blast 
    show ?thesis unfolding 90 
      using 91 c_cell_is_c_decomposable by blast
  qed
  show "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
    unfolding 8 
    apply(rule c_decomposable_disjoint_union)
    using 0 unfolding \<C>2_def  using A0_semialg \<C>1_def c_cell_is_c_decomposable change_of_fibres apply blast
    using 9  unfolding \<C>2_def apply blast 
    unfolding \<C>1_def A0_def A1_def condition_to_set.simps cell_def  by blast 
qed

lemma closed_ray_minus_convex_condition_cell_diff:
  assumes "\<C>' = Cond m A cent a b I"
  assumes "\<C> = Cond m B cent c d closed_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
  apply(cases "I = closed_interval")
  using assms closed_ray_minus_closed_interval_cell_diff apply blast
  apply(cases "I = left_closed_interval")
  using assms closed_ray_minus_left_closed_interval_cell_diff apply blast
  apply(cases "I = closed_ray")
  using assms closed_ray_minus_closed_ray_cell_diff apply blast
  using assms closed_ray_minus_open_ray_cell_diff is_cell_conditionE(5)[of m A cent a b I] 
  unfolding is_convex_condition_def  by blast  

lemma open_ray_minus_convex_condition_cell_diff:
  assumes "\<C>' = Cond m A cent a b I"
  assumes "\<C> = Cond m B cent c d open_ray"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
  apply(cases "I = closed_interval")
  using assms open_ray_minus_closed_interval_cell_diff apply blast
  apply(cases "I = left_closed_interval")
  using assms open_ray_minus_left_closed_interval_cell_diff apply blast
  apply(cases "I = closed_ray")
  using assms open_ray_minus_closed_ray_cell_diff apply blast
  using assms open_ray_minus_open_ray_cell_diff is_cell_conditionE(5)[of m A cent a b I] 
  unfolding is_convex_condition_def  by blast 

lemma cell_diff_is_c_decomposable:
  assumes "\<C>' = Cond m A cent a b I"
  assumes "\<C> = Cond m B cent c d J"
  assumes "A \<subseteq> C"
  assumes "B \<subseteq> C"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  shows "is_c_decomposable m cent (condition_to_set \<C> - condition_to_set \<C>')"
  apply(cases "J = closed_interval")
    using assms padic_fields.closed_interval_minus_convex_condition_cell_diff padic_fields_axioms apply blast
  apply(cases "J = left_closed_interval")
    using assms(1) assms(2) assms(3) assms(4) assms(5) assms(6) padic_fields.left_closed_interval_minus_convex_condition_cell_diff padic_fields_axioms apply blast
  apply(cases  "J = open_ray")
    using assms(1) assms(2) assms(3) assms(4) assms(5) assms(6) open_ray_minus_convex_condition_cell_diff apply blast
  apply(cases "J = closed_ray")
    using assms(1) assms(2) assms(3) assms(4) assms(5) assms(6) padic_fields.closed_ray_minus_convex_condition_cell_diff padic_fields_axioms apply blast
    using assms is_cell_conditionE(5) unfolding assms is_convex_condition_def by blast 

lemma empty_is_c_decomposable:
  assumes "c \<in> carrier (SA m)"
  shows "is_c_decomposable m c {}"
proof-
  obtain \<C> where \<C>_def: "is_cell_condition \<C> \<and> arity \<C>  = m \<and>center \<C> = c \<and> condition_to_set \<C> = {}"
    using empty_in_cells[of m "carrier (Q\<^sub>p\<^bsup>m\<^esup>)" c]  unfolding is_c_decomposable_def c_cells_def  is_c_cell_def
    using assms carrier_is_semialgebraic by blast
  show ?thesis 
    apply(rule is_c_decomposableI[of "{\<C>}"])
     apply blast
  proof-
    have 0:  "(\<forall>C. C \<in> {\<C>} \<longrightarrow> center C = c)"
      using \<C>_def by blast 
    have 1: "is_cell_decomp m {\<C>} {}"
      apply(rule is_cell_decompI) 
          apply blast 
      apply(rule is_partitionI)
      apply(rule disjointI)
          apply blast 
      using \<C>_def apply blast 
      using \<C>_def apply blast 
       apply blast  
      using \<C>_def by blast 
    show " is_cell_decomp m {\<C>} {} \<and> (\<forall>C. C \<in> {\<C>} \<longrightarrow> center C = c)"
      using 0 1 by blast 
  qed
qed

lemma finite_disjoint_union_is_c_decomposable:
  assumes "disjoint S"
  assumes "finite S"
  assumes "c \<in> carrier (SA m)"
  assumes "\<And>s. s \<in> S \<Longrightarrow> is_c_decomposable m c s"
  shows "is_c_decomposable m c (\<Union> S)"
proof- 
  have "disjoint S \<and> (\<forall>s \<in> S. is_c_decomposable m c s) \<longrightarrow> is_c_decomposable m c (\<Union> S)"
  proof(rule finite.induct[of S])
    show "finite S"
      using assms by blast 
    show "disjoint {} \<and> (\<forall>s\<in>{}. is_c_decomposable m c s) \<longrightarrow> is_c_decomposable m c (\<Union> {})"
      unfolding disjoint_def using assms empty_is_c_decomposable 
      by (metis Sup_empty)
    show "\<And>A a. finite A \<Longrightarrow>
           disjoint A \<and> (\<forall>s\<in>A. is_c_decomposable m c s) \<longrightarrow> is_c_decomposable m c (\<Union> A) \<Longrightarrow>
           disjoint (insert a A) \<and> (\<forall>s\<in>insert a A. is_c_decomposable m c s) \<longrightarrow> is_c_decomposable m c (\<Union> (insert a A))"
    proof fix A a 
      assume A: "finite A"
           "disjoint A \<and> (\<forall>s\<in>A. is_c_decomposable m c s) \<longrightarrow> is_c_decomposable m c (\<Union> A)"
           "disjoint (insert a A) \<and> (\<forall>s\<in>insert a A. is_c_decomposable m c s)"
      show "is_c_decomposable m c (\<Union> (insert a A))"
        apply(cases "a \<in> A")
        using A 
        apply (metis insert_absorb)
      proof-
        assume 00: "a \<notin> A"
        have 0: "disjoint A"
          using A unfolding disjoint_def by blast 
        have 1: "(\<forall>s\<in>A. is_c_decomposable m c s)"
          using A by blast 
        have 2: "\<Union>A \<inter>  a = {}"
        proof(rule equalityI')
          show "\<And>x. x \<in> \<Union> A \<inter> a \<Longrightarrow> x \<in> {}"
          proof- fix x assume A0: "x \<in> \<Union> A \<inter> a"
            then obtain s where s_def: "s \<in> A \<and> x \<in> s \<inter> a"
              by blast 
            then have "s \<inter> a = {}"
              using 0 1 A disjointE[of "insert a A" s a] 00  by blast 
            then show "x \<in> {}"
              using s_def by blast 
          qed
          show "\<And>x. x \<in> {} \<Longrightarrow> x \<in> \<Union> A \<inter> a" by blast 
        qed
        have 3: "is_c_decomposable m  c a"
          using A by blast 
        have 4: "is_c_decomposable m c (\<Union> A)"
          using A 0 1 by blast 
        hence "is_c_decomposable m c (\<Union>A \<union> a)"
          using 2 3 4 c_decomposable_disjoint_union by blast 
        thus ?thesis 
          by (simp add: Un_commute)
      qed
    qed
  qed
  then show ?thesis 
    using assms by blast 
qed

lemma c_decomposable_minus_c_cell_is_c_decomposable:
  assumes "c \<in> carrier (SA m)"
  assumes "is_c_decomposable m c A"
  assumes "\<C> = Cond m C c a b I"
  assumes "is_cell_condition \<C>"
  shows "is_c_decomposable m c (A - condition_to_set \<C>)"
proof-
  obtain S where S_def: "S \<noteq> {} \<and> is_cell_decomp m S A \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
    using assms is_c_decomposableE[of m c A]
    by blast 
  have 0: "disjoint (condition_to_set ` S)"
    apply(rule disjointI)
    using S_def is_cell_decompE(5)[of m S A] by blast  
  have 1: "A - condition_to_set \<C> = (\<Union> s \<in> S. condition_to_set s - condition_to_set \<C>)"
    using S_def is_cell_decompE(2)[of m S A] is_partitionE(2)[of "condition_to_set ` S" A]
    by blast 
  have  2: "disjoint ((\<lambda>s . condition_to_set s - condition_to_set \<C>) ` S)"
  proof(rule disjointI) fix a b assume A: " a \<in> (\<lambda>s. condition_to_set s - condition_to_set \<C>) ` S "
           "b \<in> (\<lambda>s. condition_to_set s - condition_to_set \<C>) ` S" "a \<noteq> b"
    then obtain s where s_def: "s \<in> S \<and> a =   condition_to_set s - condition_to_set \<C>"
      by (metis (no_types, lifting) imageE image_restrict_eq)
    then obtain s' where s'_def: "s' \<in> S \<and> b =   condition_to_set s' - condition_to_set \<C>"
      using A by (metis (no_types, lifting) imageE image_restrict_eq)
    have "s \<noteq> s'"
      using s_def s'_def A by blast 
    hence "condition_to_set s \<inter> condition_to_set s' = {}"
      using s_def s'_def is_cell_decompE S_def 
      by meson
    thus "a \<inter> b = {}"
      using s_def s'_def  A  0 disjointE by blast 
  qed
  have 3: "\<And>s. s \<in> S \<Longrightarrow> is_c_decomposable m c (condition_to_set s - condition_to_set \<C>)"
  proof- fix s assume A: "s \<in> S"
    obtain B c' d J where BcdJ_def: "s = Cond m B c c' d J"
      using A S_def is_cell_decompE 
      by (metis condition_decomp')
    show "is_c_decomposable m c (condition_to_set s - condition_to_set \<C>)"
    using assms S_def cell_diff_is_c_decomposable[of \<C> m C c a b I s B c' d J  "carrier (Q\<^sub>p\<^bsup>m\<^esup>)"] 
    by (metis A BcdJ_def is_cell_conditionE''(1) is_cell_decompE(3) is_semialgebraic_closed)
  qed
  show "is_c_decomposable m c (A - condition_to_set \<C>)"
    unfolding 1 
    apply(rule finite_disjoint_union_is_c_decomposable)
    using 2 apply blast 
    using S_def is_cell_decompE(1) apply blast 
    using assms apply blast using 3 by blast 
qed

lemma c_decomposable_difference0:
  assumes "is_c_decomposable m c C"
  assumes "S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
  shows "is_c_decomposable m c (C - B)"
proof- 
  obtain n where n_def: "n = card S"
    by blast 
  have "\<forall> C S B . is_c_decomposable m c C \<longrightarrow> ( n = card S \<longrightarrow> ((S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)) \<longrightarrow>  is_c_decomposable m c (C - B)))"
  proof(induction n)
    case 0
    then show ?case  
      by (metis bot_nat_def card_0_eq padic_fields.is_cell_decompE(1) padic_fields_axioms)
  next
    case (Suc n) fix n 
    assume IH: " \<forall>C S B.
            is_c_decomposable m c C \<longrightarrow>
            n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c) \<longrightarrow> is_c_decomposable m c (C - B)"
    show " \<forall>C S B.
            is_c_decomposable m c C \<longrightarrow>
            Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c) \<longrightarrow> is_c_decomposable m c (C - B)"
    proof fix C 
      show "\<forall>S B. is_c_decomposable m c C \<longrightarrow>
               Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c) \<longrightarrow> is_c_decomposable m c (C - B)"
      proof fix S 
        show "\<forall>B. is_c_decomposable m c C \<longrightarrow>
             Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c) \<longrightarrow> is_c_decomposable m c (C - B)"
        proof fix B 
          show "is_c_decomposable m c C \<longrightarrow>
         Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c) \<longrightarrow> is_c_decomposable m c (C - B)"
          proof assume A0: "is_c_decomposable m c C "
            show "Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c) \<longrightarrow> is_c_decomposable m c (C - B)"
            proof assume A1: "Suc n = card S"
              show "S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c) \<longrightarrow> is_c_decomposable m c (C - B)"
              proof assume A2: " S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
                show "is_c_decomposable m c (C - B)"
                proof- 
                  obtain C' where C'_def: "C' \<in> S" using A2 by blast 
                  obtain S' where S'_def: "S' = S - {C'}" by blast 
                  obtain D where D_def: "D = (\<Union> c \<in> S'. condition_to_set c)"
                    by blast 
                  have 00: "\<Union> (condition_to_set ` (S - {C'})) \<subseteq> \<Union> (condition_to_set ` S) "
                    by blast
                  have 0: "is_cell_decomp m S' D \<and> (\<forall>C. C \<in> S' \<longrightarrow> center C = c)"
                  proof
                    show "is_cell_decomp m S' D"
                      apply(rule is_cell_decompI) 
                      unfolding S'_def using A2 is_cell_decompE(1) apply blast
                         apply(rule is_partitionI) using A2 is_cell_decompE(2)[of m S B] 
                      unfolding disjoint_def using  is_partitionE(1)[of "condition_to_set ` S" B]  
                      apply (metis (mono_tags, lifting) DiffD1 image_iff disjoint_def)
                        unfolding D_def S'_def apply blast 
                        using A2 is_cell_decompE(4)[of m S B] 
                        apply (meson DiffD1 is_cell_decompE(3))
                        using A2 is_cell_decompE(2)[of m S B] is_partitionE[of "condition_to_set ` S" B]
                              is_cell_decompE(6)[of m S B] 00 apply blast
                        using A2 is_cell_decompE(2)[of m S B] is_partitionE(1)[of "condition_to_set ` S" B]
                        unfolding disjoint_def using is_cell_decompE(6)[of m S B] 00 
                        by (meson Diff_iff is_cell_decompE(5))
                      show " \<forall>C. C \<in> S' \<longrightarrow> center C = c"
                        using A2 unfolding S'_def by blast
                  qed
                  have 1: "is_c_decomposable m c (C - D)"
                  proof(cases "D = {}")
                    case True
                    then show ?thesis using A0 unfolding True by simp
                  next
                    case False
                    have F0: "S' \<noteq> {}"
                    proof assume A: "S' = {}"
                      then have "D = {}"
                        using 0 is_cell_decompE(2)[of m S' D] is_partitionE[of "condition_to_set ` S'" D]
                        unfolding A by blast
                      then show False using False by blast 
                    qed
                    have F1: "is_c_decomposable m c D"
                      apply(rule is_c_decomposableI[of S']) 
                      using F0 apply blast 
                      using 0 by blast 
                    have F2: "\<And> C S B. is_c_decomposable m c C \<Longrightarrow> n = card S \<Longrightarrow> 
                                    S \<noteq> {} \<and> is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c) \<Longrightarrow>
                                     is_c_decomposable m c (C - B)"
                      using IH by blast 
                    have F3: "n = card (S - {C'})"
                      by (metis A1 C'_def Diff_empty card.infinite card_Diff_insert diff_Suc_1 mem_simps(2) zero_less_Suc zero_less_iff_neq_zero)
                    show ?thesis
                      using A0 F0 F2[of C S' D] 0 F1 F3  unfolding S'_def  by blast 
                  qed
                  have 2: "B = \<Union> (condition_to_set ` S)"
                    using A2 is_cell_decompE(2)[of m S B] is_partitionE[of "condition_to_set ` S" B] by blast 
                  have 3: "C - B = (C - D) - condition_to_set C'"
                    unfolding D_def S'_def 2 using C'_def by blast 
                  obtain D' a b J where  def: "C' = Cond m D' c a b J"
                    using C'_def A2 is_cell_decompE 
                    by (metis condition_decomp')
                  have 4: "is_c_decomposable m c ((C - D) - condition_to_set C')"
                    apply(rule c_decomposable_minus_c_cell_is_c_decomposable[of _ _ _ _ D' a b J])
                    using assms is_c_decomposableE apply blast 
                    using 1 apply blast 
                    using def apply blast 
                    using C'_def A2 is_cell_decompE by blast 
                  show ?thesis using 4 unfolding D_def S'_def 
                    using A2 is_cell_decompE(2) is_partitionE (2) "3" "4" by presburger
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
  then show ?thesis using assms n_def by blast
qed

lemma c_decomposable_difference:
  assumes "is_c_decomposable m c C"
  assumes "is_c_decomposable m c B"
  shows "is_c_decomposable m c (C - B)"
proof- 
  obtain S where S_def: " S \<noteq> {} \<and>
        is_cell_decomp m S B \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
    using assms unfolding is_c_decomposable_def by blast 
  show ?thesis 
    by(rule c_decomposable_difference0[of _ _ _ S], 
        rule assms, rule S_def)
qed  

theorem c_decomposable_is_gen_boolean_algebra:
  assumes "is_c_decomposable m c C"
  shows "c_decomposables m c C = gen_boolean_algebra C (Cells\<^bsub>m,c\<^esub>(C))"
proof
  show "c_decomposables m c C \<subseteq> gen_boolean_algebra C (Cells\<^bsub>m,c\<^esub>(C))"
  proof fix x assume A: "x \<in> c_decomposables m c C"
    show "x \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C"
    proof-
      obtain S where S_def: "S \<noteq> {} \<and> is_cell_decomp m S x \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
        using A c_decomposables_def 
        by (metis (no_types, lifting) is_c_decomposableE(1) mem_Collect_eq)
      have 0: "x = (\<Union> Y \<in> S. condition_to_set Y )"
        using S_def 
        by (metis is_cell_decompE(2) is_partitionE(2))
      have 1: "\<And>Y. Y \<in> S \<Longrightarrow> condition_to_set Y \<in> Cells\<^bsub>m,c\<^esub>(C)"
      proof- fix Y assume A0: "Y \<in> S"
        have 0: "arity Y = m"
          using A0 S_def is_cell_decompE(4) by blast
        have 1: "is_cell_condition Y"
          using A0 S_def is_cell_decompE(3) by blast
        have 2: "center Y = c"
          using A0  S_def by blast
        have 3: "(\<exists>\<C>. is_cell_condition \<C> \<and> arity \<C> = m \<and> center \<C> = c \<and> condition_to_set Y = condition_to_set \<C>)"
          using 0 1 2 
          by blast
        have 4: "condition_to_set Y \<subseteq> C"
        proof-
          have "condition_to_set Y \<subseteq> x"
            using A0 S_def is_cell_decomp_subset by blast
          thus ?thesis using A c_decomposables_closed by blast 
        qed
        thus "condition_to_set Y \<in> Cells\<^bsub>m, c\<^esub>C"
          using 0 1 2 3 4 is_cell_decompE(3)[of m S x Y] is_cell_decompE(4)[of m S x Y] S_def 
          unfolding c_cells_def  is_c_cell_def mem_Collect_eq 
          by blast
      qed
      show ?thesis 
        unfolding 0 apply(rule gen_boolean_algebra_finite_union[of "condition_to_set ` S" C "Cells\<^bsub>m, c\<^esub>C"])
         apply(rule gen_boolean_algebra_generators) using c_cells_def  mem_Collect_eq apply blast 
        using 1 apply blast 
        using S_def is_cell_decompE(1) by blast
    qed
  qed
  show "gen_boolean_algebra C (Cells\<^bsub>m, c\<^esub>(C)) \<subseteq> c_decomposables m c C"
  proof fix x assume A: "x \<in> gen_boolean_algebra C (Cells\<^bsub>m, c\<^esub>(C))"
    show "x \<in>  c_decomposables m c C"
    proof(rule boolean_algebra_alt_induct[of x C "Cells\<^bsub>m, c\<^esub>(C)"])
      show "x \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C" using A by blast 
      show "C \<in> c_decomposables m c C" using assms unfolding c_decomposables_def  
        by blast
      show "\<And>A. A \<in> Cells\<^bsub>m, c\<^esub>C \<Longrightarrow> A \<inter> C \<in> c_decomposables m c C"
      proof- fix A assume A0: "A \<in> Cells\<^bsub>m,c\<^esub>(C)"
        then have 0: "A \<subseteq> C"
          using A0 c_cells_def by blast
        obtain \<C> where \<C>_def: "is_cell_condition \<C> \<and> arity \<C> = m \<and> center \<C> = c \<and> A = condition_to_set \<C>"
          using A0 unfolding c_cells_def is_c_cell_def by blast 
        obtain S where S_def: "S = {\<C>}"
          by blast 
        have 1: "is_cell_decomp m S A"
          apply(rule is_cell_decompI) 
          unfolding S_def apply blast 
          apply(rule is_partitionI) 
          unfolding disjoint_def apply blast 
          using \<C>_def apply blast 
          using \<C>_def apply blast 
          using 0 assms is_c_decomposableE[of m c C] apply (meson basic_trans_rules(23) is_cell_decompE(6))
          by blast 
        show "A \<inter> C \<in> c_decomposables m c C"
          unfolding c_decomposables_def mem_Collect_eq using 1 is_c_decomposableI[of S m A c]
          unfolding S_def using \<C>_def 
          by (metis "0" Int_absorb2 insert_not_empty singletonD)
      qed          
      show "\<And>A Ca.
       A \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C \<Longrightarrow>
       Ca \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C \<Longrightarrow>
       A \<in> c_decomposables m c C \<Longrightarrow> Ca \<in> c_decomposables m c C \<Longrightarrow> A \<inter> Ca = {} \<Longrightarrow> A \<union> Ca \<in> c_decomposables m c C"
      proof- fix A B assume A: " A \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C"  "A \<in> c_decomposables m c C" 
                            "B \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C" "B \<in> c_decomposables m c C" "A \<inter> B= {}"
        show "A \<union> B \<in> c_decomposables m c C"
          unfolding c_decomposables_def mem_Collect_eq
        proof
          obtain S where S_def: "S \<noteq> {} \<and> is_cell_decomp m S A \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
            using A unfolding c_decomposables_def mem_Collect_eq using is_c_decomposableE[of m c A] 
            by blast
          obtain S' where S'_def: "S' \<noteq> {} \<and>is_cell_decomp m S' B \<and> (\<forall>C. C \<in> S' \<longrightarrow> center C = c)"
            using A unfolding c_decomposables_def mem_Collect_eq using is_c_decomposableE[of m c B] 
            by blast
          have 0: "A \<union> B - A = B"
            using A(5) by blast 
          have 1: "is_cell_decomp m (S \<union> S') (A \<union> B)"
            apply(rule cell_decomp_union[of "A"]) 
               apply blast 
            using assms A  apply (meson S'_def S_def Un_subset_iff is_cell_decompE(6))
            using S_def apply blast
            using S'_def unfolding 0 by blast 
          show "is_c_decomposable m c (A \<union> B)"
            apply(rule is_c_decomposableI[of "S \<union> S'"])
            using  S_def apply blast 
            using 1 S_def S'_def by blast 
          show "A \<union> B \<subseteq> C"
            using A assms c_decomposables_closed by blast
        qed
      qed

      show " \<And>A B.
       A \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C \<Longrightarrow>
      B \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C \<Longrightarrow> A \<in> c_decomposables m c C \<Longrightarrow> B \<in> c_decomposables m c C \<Longrightarrow> A - B \<in> c_decomposables m c C "
      proof- fix A B assume A: "A \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C" "B \<in> gen_boolean_algebra C Cells\<^bsub>m, c\<^esub>C" 
                               "A \<in> c_decomposables m c C" "B \<in> c_decomposables m c C"
        show "A - B \<in> c_decomposables m c C"
          using A c_decomposable_difference unfolding c_decomposables_def mem_Collect_eq by blast 
      qed
    qed
  qed
qed

lemma cell_decomp_same_center:
  assumes "is_cell_condition \<C>"
  assumes "\<C> = Cond m C c a1 a2 I"
  assumes "B \<subseteq> condition_to_set \<C>"
  assumes "\<exists>S. is_cell_decomp m S B \<and> (\<forall> A \<in> S. center A = c)"
  shows "\<exists>S'. is_cell_decomp m S' (condition_to_set \<C> - B) \<and> (\<forall>A \<in> S'. center A = c)"
proof(cases "B = {}")
  case True
  have "is_cell_decomp m {\<C>} (condition_to_set \<C> - B)"
    apply(rule is_cell_decompI)
    apply blast 
       apply(rule is_partitionI) apply(rule disjointI)
        apply blast unfolding True apply blast 
    unfolding assms using arity.simps 
    using assms(1) assms(2) apply blast
    unfolding condition_to_set.simps cell_def apply blast 
    by blast 
  then show ?thesis unfolding assms using center.simps by blast 
next
  case False
  obtain S where S_def: "is_cell_decomp m S B \<and> (\<forall> A \<in> S. center A = c)"
    using  assms by blast 
  have 0: "S \<noteq> {}"
    using S_def False is_cell_decompE is_partitionE 
    by (metis ccSup_empty image_empty)
  have 1: "is_c_decomposable m c B"
    apply(rule is_c_decomposableI[of S])
    using 0 apply blast 
    using S_def by blast 
  have "is_c_decomposable m c (condition_to_set \<C> - B)"
    apply(rule c_decomposable_difference)
    using assms unfolding assms using c_cell_is_c_decomposable apply blast
    using 1 by blast 
  then show ?thesis using is_c_decomposableE by blast 
qed
end

(**************************************************************************************************)
(**************************************************************************************************)
subsection\<open>Refining Cells Against a Set of Endpoints\<close>
(**************************************************************************************************)
(**************************************************************************************************)

text\<open>Given a finite set \texttt{Fs} of semialgebraic functions, and a cell condition $\mathcal{C}$ 
\texttt{= Cond m C c a1 a2 I}, we would like to decompose the underlying set of $\mathcal{C}$ into 
finitely many cells \texttt{S} which are compatible with \texttt{Fs} in the sense that for any cell 
$\mathcal{D} \in$ \texttt{S}, and any cell $\mathcal{B}$\texttt{ = Cond m C c f g J} where 
\texttt{f, g }$\in$\texttt{ Fs} and \texttt{J} is arbitrary, either \texttt{condition\_to\_set} 
$\mathcal{D} \subseteq$ \texttt{condition\_to\_set }$\mathcal{B}$ or they are disjoint. This will 
be useful in the proof of Denef's Theorem $II$. In particular, it will be crucial for establishing 
equation $(3)$ from Denef's proof of cell decompostion theorem $II_d$. This proof will use the 
results from the previous section that sets which can be decomposed into cells with a common center 
form a boolean algebra. We can proceed as follows:
\begin{enumerate}

\item Form the collection of underlying sets of cells $\mathcal{B}$ \texttt{= Cond m C c f g J} 
where $f, g \in Fs \cup \{a1, a2\}$, which are contained in 
\texttt{condition\_to\_set }$\mathcal{C}$. 
These generate a subalgebra of all $c$-decomposable sets contained in 
\texttt{condition\_to\_set }$\mathcal{C}$. This subalgebra is what we call 
\texttt{endpoint\_c\_algebra} below.  

\item Since there are finitely many sets above, we can obtain the atoms of the subalgebra they 
generate. Since $c$-decomposable sets form a boolean algebra, these atoms themselves will be 
$c$-decomposable. Thus each atom can be further decomposed into a finite disjoint union of cells 
centered at $c$. Collecting the cells in each of these decompositions will give us our desired 
decomposition of $\mathcal{C}$. 
\end{enumerate}
   \<close>
context padic_fields
begin

lemma static_order_type_decomp_0:
  assumes "finite Fs"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "is_semialgebraic m B"
  shows "\<exists>Bs. finite Bs \<and> Bs partitions B \<and> (\<forall>b \<in> Bs. is_semialgebraic m b \<and> 
          (\<forall>f \<in> Fs. \<forall>g \<in> Fs. \<forall>x \<in> b.\<forall>y \<in> b. (val (f x) < val (g x) \<longleftrightarrow> val (f y) < val (g y)) \<and> (val (f x) = val (g x) \<longleftrightarrow> val (f y) = val (g y))))"
proof- 
  obtain Fs_pairs where Fs_pairs_def: "Fs_pairs = {(f, g). f \<noteq> g} \<inter> ( Fs \<times> Fs)"
    by blast 
  have Fs_pairs_finite: "finite Fs_pairs"
  proof- have "finite (Fs \<times> Fs)"
      using assms by blast 
    thus ?thesis 
      unfolding Fs_pairs_def by blast 
  qed
  obtain S1 where S1_def: "S1 = (\<lambda>(f,g). B \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) < val (g x)})"
    by blast 
  have S1_semialg: "\<And>f g. (f,g) \<in> Fs_pairs \<Longrightarrow> is_semialgebraic m (S1 (f,g))"
  proof- fix f g assume A: "(f,g) \<in> Fs_pairs"
    have 0: "f \<in> Fs"
      using A unfolding Fs_pairs_def by blast 
    have 1: "g \<in> Fs"
      using A unfolding Fs_pairs_def by blast 
    have f_closed: "f \<in> carrier (SA m)"
      using 0 assms by blast 
    have g_closed: "g \<in> carrier (SA m)"
      using 1 assms by blast 
    have 3: "S1 (f,g) =  B \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) < val (g x)}"
      using S1_def by blast 
    show "is_semialgebraic m (S1 (f,g))"
      unfolding 3
      by(rule intersection_is_semialg, rule assms, rule semialg_val_strict_ineq_set_is_semialg, rule f_closed, rule g_closed)
  qed
  obtain S2 where S2_def: "S2 = (\<lambda>(f,g). B \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)})"
    by blast 
  have S2_semialg: "\<And>f g. (f,g) \<in> Fs_pairs \<Longrightarrow> is_semialgebraic m (S2 (f,g))"
  proof- fix f g assume A: "(f,g) \<in> Fs_pairs"
    have 0: "f \<in> Fs"
      using A unfolding Fs_pairs_def by blast 
    have 1: "g \<in> Fs"
      using A unfolding Fs_pairs_def by blast 
    have f_closed: "f \<in> carrier (SA m)"
      using 0 assms by blast 
    have g_closed: "g \<in> carrier (SA m)"
      using 1 assms by blast 
    have 3: "S2 (f,g) =  B \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)}"
      using S2_def by blast 
    show "is_semialgebraic m (S2 (f,g))"
      unfolding 3
      by(rule intersection_is_semialg, rule assms, rule semialg_val_eq_set_is_semialg, rule f_closed, rule g_closed)
  qed
  obtain S where S_def: "S = (S1 ` Fs_pairs)\<union>(S2 ` Fs_pairs)"
    by blast 
  have S_semialg: "\<And>s. s \<in> S \<Longrightarrow> is_semialgebraic m s"
    unfolding S_def using S1_semialg S2_semialg unfolding Fs_pairs_def 
    by blast
  have S_finite: "finite S"
    using Fs_pairs_finite unfolding S_def by blast 
  obtain P where P_def: "P = atoms_of S"
    by blast 
  have finite_P: "finite P"
    unfolding P_def using S_finite 
    by (simp add: finite_set_imp_finite_atoms)
  have P_semialg: "\<And>s. s \<in> P \<Longrightarrow> is_semialgebraic m s"
    using S_finite S_semialg atoms_of_gen_boolean_algebra
    unfolding P_def is_semialgebraic_def semialg_sets_def 
    by (metis (no_types, opaque_lifting) Set.basic_monos(7) local.P_def subsetI)
  show " \<exists>Bs. finite Bs \<and>
         Bs partitions B \<and>
         (\<forall>b\<in>Bs.
             is_semialgebraic m b \<and>
             (\<forall>f\<in>Fs. \<forall>g\<in>Fs. \<forall>x\<in>b. \<forall>y\<in>b. ((val (f x) < val (g x)) = (val (f y) < val (g y)) \<and> (val (f x) = val (g x)) = (val (f y) = val (g y))))) "
  proof(cases "Fs = {}")
    case True
    obtain Bs where Bs_def: "Bs = {B}"
      by blast 
    have T0: "Bs partitions B" unfolding Bs_def 
      by(rule is_partitionI, rule Generated_Boolean_Algebra.disjointI, blast, blast)
    show ?thesis using True T0 assms Bs_def by blast
  next
    case False
    show ?thesis 
    proof(cases "Fs_pairs = {}")
      case True
      obtain f where f_def: "f \<in> Fs"
        using False by blast 
      have T0: "\<And>g. g \<in> Fs \<Longrightarrow> g = f"
        apply(rule ccontr)
        using f_def True unfolding Fs_pairs_def by blast 
      obtain Bs where Bs_def: "Bs = {B}"
        by blast 
      have T1: "Bs partitions B" unfolding Bs_def 
        by(rule is_partitionI, rule Generated_Boolean_Algebra.disjointI, blast, blast)
      have T2: "(\<forall>f\<in>Fs. \<forall>g\<in>Fs. \<forall>x\<in>B. \<forall>y\<in>B. ((val (f x) < val (g x)) = (val (f y) < val (g y)) \<and> (val (f x) = val (g x)) = (val (f y) = val (g y))))"
        using T0 by blast  
      show ?thesis
        using T1 T2 assms Bs_def by blast 
    next
      case F: False
      have S_union: "\<Union> S = B"
      proof(rule equalityI')
        fix x assume A: "x \<in> \<Union>S"
        show "x \<in> B"
          using A unfolding S_def S1_def S2_def by blast 
      next 
        fix x assume A: "x \<in> B"
        show "x \<in> \<Union> S"
        proof- 
          have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
            using A assms  is_semialgebraic_closed by blast
          obtain f g where fg_def: "(f,g) \<in>  Fs_pairs"
            using F 
            by (metis equals0I surj_pair)
          have 0: "(g, f) \<in> Fs_pairs"
            using fg_def unfolding Fs_pairs_def 
            by blast
          have 1: "val (f x) = val (g x) \<Longrightarrow> x \<in> S2 (f,g)"
            unfolding S2_def using x_closed A 
            by blast
          have 2: "val (f x) < val (g x) \<Longrightarrow> x \<in> S1 (f,g)"
            unfolding S1_def using x_closed A 
            by blast
          have 3: "val (f x) > val (g x) \<Longrightarrow> x \<in> S1 (g,f)"
            unfolding S1_def using x_closed A 
            by blast
          have 4: "val (f x) \<noteq> val (g x) \<Longrightarrow> \<not>val (f x) < val (g x) \<Longrightarrow> val (f x) > val (g x)"
            by (meson basic_trans_rules(18) padic_fields.notin_closed padic_fields_axioms)
          show ?thesis 
            apply(cases "val (f x) = val (g x)")
            using 1 fg_def unfolding S_def  apply blast
            apply(cases "val (f x) < val (g x)")
            using 2 fg_def unfolding S_def  apply blast
            using 0 3 4 unfolding S_def by blast 
        qed
      qed
      have P_union: "\<Union> P = B"
        unfolding P_def using atoms_of_covers[of B] S_union S_finite by blast 
      have P_partitions: "P partitions B"
        apply(rule is_partitionI, rule Generated_Boolean_Algebra.disjointI)
        using P_def atoms_of_disjoint S_finite apply blast
        by(rule P_union)
      have "(\<forall>b\<in>P.
             is_semialgebraic m b \<and>
             (\<forall>f\<in>Fs. \<forall>g\<in>Fs. \<forall>x\<in>b. \<forall>y\<in>b. (val (f x) < val (g x) \<longleftrightarrow> val (f y) < val (g y)) \<and> (val (f x) = val (g x) \<longleftrightarrow> val (f y) = val (g y))))"
      proof(rule , rule, rule P_semialg, blast, rule , rule , rule , rule )
        fix b f g x y 
        assume A0: "b \<in> P"    "f \<in> Fs" "g \<in> Fs" "x \<in> b" "y \<in> b"
        show "(val (f x) < val (g x) \<longleftrightarrow> val (f y) < val (g y)) \<and> (val (f x) = val (g x) \<longleftrightarrow> val (f y) = val (g y))"
        proof(cases "f = g")
          case True
          show ?thesis unfolding True by blast 
        next
          case False
          have 0: "(f,g) \<in> Fs_pairs"
            using A0 Fs_pairs_def  False by blast
          obtain s1 where s1_def: "s1 = S1 (f,g)"
            by blast 
          have s1_in_S: "s1 \<in> S"
            using 0 s1_def S_def by blast 
          obtain s2 where s2_def: "s2 = S2 (f,g)"
            by blast 
          have s2_in_S: "s2 \<in> S"
            using 0 s2_def S_def by blast 
          have 1: "b \<subseteq> s1 \<or> b \<inter> s1 = {}"
            using A0 s1_in_S P_def atoms_are_minimal by blast 
          have 2: "b \<subseteq> s2 \<or> b \<inter> s2 = {}"
            using A0 s2_in_S P_def atoms_are_minimal by blast 
          have x_closed: "x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
            using A0 P_semialg[of b] is_semialgebraic_closed by blast
          have y_closed: "y \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>)"
            using A0 P_semialg[of b] is_semialgebraic_closed by blast
          have 3: "x \<in> s1 \<longleftrightarrow> y \<in> s1"
            using A0 1 by blast 
          have 4: "x \<in> s2 \<longleftrightarrow> y \<in> s2"
            using A0 2 by blast 
          have 5: "s1 = B \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) < val (g x)}"
            unfolding s1_def S1_def by blast 
          have 6: "s2 = B \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)}"
            unfolding s2_def S2_def by blast 
          have x_in_B: "x \<in> B"
            using P_union A0 by blast 
          have y_in_B: "y \<in> B"
            using P_union A0 by blast 
          have 7: "(val (f x) < val (g x)) = (val (f y) < val (g y))"
            using y_closed x_closed 3  x_in_B y_in_B unfolding 5 by blast
          have 8: "(val (f x) = val (g x)) = (val (f y) = val (g y))"
            using y_closed x_closed 4  x_in_B y_in_B unfolding 6 by blast 
          show ?thesis using 7 8 by blast 
        qed
      qed
      thus ?thesis using P_partitions P_semialg 
        using finite_P by blast
    qed
  qed
qed

definition static_order_type where
"static_order_type Fs b = (\<forall>f \<in> Fs. \<forall>g \<in> Fs. \<forall>x \<in> b.\<forall>y \<in> b. (val (f x) < val (g x) \<longleftrightarrow> val (f y) < val (g y)) \<and> (val (f x) = val (g x) \<longleftrightarrow> val (f y) = val (g y)))"

lemma static_ord_typeI: 
  assumes "\<And>f g x y. f \<in> Fs \<Longrightarrow> g \<in> Fs \<Longrightarrow> x \<in> b \<Longrightarrow> y \<in> b \<Longrightarrow> (val (f x) < val (g x) \<Longrightarrow> val (f y) < val (g y))"
  assumes "\<And>f g x y. f \<in> Fs \<Longrightarrow> g \<in> Fs \<Longrightarrow> x \<in> b \<Longrightarrow> y \<in> b \<Longrightarrow> (val (f x) = val (g x) \<Longrightarrow> val (f y) = val (g y))"
  shows "static_order_type Fs b"
  unfolding static_order_type_def
  apply(rule, rule, rule , rule , rule conjI)
  using assms apply blast using assms by blast 

lemma static_ord_typeE: 
  assumes "static_order_type Fs b"
  assumes "f \<in> Fs"
  assumes "g \<in> Fs"
  assumes "x \<in> b"
  assumes "y \<in> b"
  shows "val (f x) < val (g x) \<Longrightarrow> val (f y) < val (g y)"
        "val (f x) = val (g x) \<Longrightarrow> val (f y) = val (g y)"
  using assms unfolding static_order_type_def  apply blast
  using assms unfolding static_order_type_def  by blast

lemma static_order_type_decomp:
  assumes "finite Fs"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "is_semialgebraic m B"
  shows "\<exists>Bs. finite Bs \<and> Bs partitions B \<and> (\<forall>b \<in> Bs. is_semialgebraic m b \<and> 
                      static_order_type Fs b)"
  unfolding static_order_type_def 
by(rule static_order_type_decomp_0, rule assms, rule assms, rule assms)

definition endpoint_generators where
"endpoint_generators m c B f g = {\<C>. \<exists>I. is_convex_condition I \<and> \<C> = Cond m B c f g I} "

lemma endpoint_generators_cell_cond:
  assumes "is_semialgebraic m B"
  assumes "c \<in> carrier (SA m)"
  assumes "f \<in> carrier (SA m)"
  assumes "g \<in> carrier (SA m)"
  assumes "\<C> \<in> endpoint_generators m c B f g"
  shows "is_cell_condition \<C>"
proof- 
  obtain I where I_def: "is_convex_condition I \<and> \<C> = Cond m B c f g I"
    using assms(5) unfolding endpoint_generators_def by blast 
  have \<C>_eq: "\<C> = Cond m B c f g I"
    using I_def by blast 
  show ?thesis 
    unfolding \<C>_eq apply(rule is_cell_conditionI', rule assms , rule assms, rule assms, rule assms)
    using I_def by blast 
qed

lemma endpoint_generators_finite:
"finite (endpoint_generators m c B f g)"
proof- 
  have 0: "finite {closed_interval, left_closed_interval, closed_ray, open_ray}"
    by blast
  obtain Is where Is_def: "Is = {closed_interval, left_closed_interval, closed_ray, open_ray}"
    by blast 
  have 1: "\<And>I. is_convex_condition I \<Longrightarrow> I \<in> Is"
    unfolding is_convex_condition_def Is_def 
    by(erule disjE, blast,erule disjE, blast,erule disjE, blast, blast)
  have 2: "\<And>I. I \<in> Is \<Longrightarrow> is_convex_condition I"
  proof- fix I assume A: "I \<in> Is" show "is_convex_condition I"
    unfolding Is_def is_convex_condition_def 
    apply(cases "I = closed_interval", blast)
    apply(cases "I = left_closed_interval", blast)
    apply(cases "I = closed_ray", blast)
    using A unfolding Is_def by force 
  qed
  have 3:  "(endpoint_generators m c B f g) = Cond m B c f g ` Is"
    apply(rule equalityI')
    using 1  unfolding endpoint_generators_def mem_Collect_eq image_iff 
    apply blast
    using 2 by blast  
  thus ?thesis unfolding Is_def using 0 by force 
qed

definition endpoint_c_algebra where
  "endpoint_c_algebra m c B a1 a2 I Fs = gen_boolean_algebra (condition_to_set (Cond m B c a1 a2 I))
                                                      (condition_to_set ` (\<Union> (f,g) \<in> Fs \<times> Fs. (endpoint_generators m c B f g))) "

lemma is_c_decomposable_algebra:
  assumes "is_c_decomposable m c C"
  shows "C \<in> c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
proof-
  have 0: "C \<subseteq> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"
    using assms is_cell_decompE unfolding is_c_decomposable_def 
    by meson
  show ?thesis 
    using assms unfolding is_c_decomposable_def c_decomposables_def mem_Collect_eq 
    using 0 by blast 
qed

lemma singleton_mem:
"x \<in> {y} = (x = y)"
  by blast 

lemma constant_zero:
"\<And>x. x \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) \<Longrightarrow>
         (constant_function (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) \<zero> (tl x)) = \<zero>"
  by(intro constant_functionE Qp_pow_ConsE, auto )

lemma carrier_is_c_decomposable: 
  assumes "c \<in> carrier (SA m)"
  shows "is_c_decomposable m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
proof- 
  have 0: "carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>) = condition_to_set (Cond m (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) c c (constant_function (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) \<zero>) closed_ray)"
    apply(rule equalityI')
    unfolding condition_to_set.simps apply(rule cell_memI, blast)
    using cartesian_power_tail apply blast
     by(rule closed_ray_memI, unfold constant_zero val_zero cell_def mem_Collect_eq, auto )      
  have 1: "is_cell_condition  (Cond m (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) c c (constant_function (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) \<zero>) closed_ray)"
    apply(rule is_cell_conditionI', rule carrier_is_semialgebraic, rule assms, rule assms, rule constant_fun_closed, rule Qp.zero_closed)
    unfolding is_convex_condition_def by blast
  have 2: "is_cell_decomp m {(Cond m (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) c c (constant_function (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) \<zero>) closed_ray)} (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    apply(rule is_cell_decompI, blast, rule is_partitionI, rule Generated_Boolean_Algebra.disjointI, blast)
    using 0 apply blast unfolding singleton_mem using 1 arity.simps  apply blast
     apply blast by blast 
  show ?thesis apply(rule is_c_decomposableI[of " {(Cond m (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) c c (constant_function (carrier (Q\<^sub>p\<^bsup>m\<^esup>)) \<zero>) closed_ray)}"], 
        blast) unfolding singleton_mem using center.simps 1 
    using "2" by blast
qed
    
lemma carrier_is_c_decomposable': 
  assumes "is_c_decomposable m c A"
  shows "is_c_decomposable m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
by(rule carrier_is_c_decomposable, rule is_c_decomposableE, rule assms)

lemma intersection_is_c_decomposable:
  assumes "is_c_decomposable m c A"
  assumes "is_c_decomposable m c B"
  shows "is_c_decomposable m c (A \<inter> B)"
proof-
  have 0: "A \<in> c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    by(rule is_c_decomposable_algebra, rule assms )
  have 1: "B \<in> c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    by(rule is_c_decomposable_algebra, rule assms )
  have 2: "c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) = gen_boolean_algebra (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (Cells\<^bsub>m,c\<^esub>((carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))))"
    by(rule c_decomposable_is_gen_boolean_algebra, rule carrier_is_c_decomposable', rule assms )
  have 3: "A \<inter> B\<in> gen_boolean_algebra (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (Cells\<^bsub>m,c\<^esub>((carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))))"
    apply(rule gen_boolean_algebra_intersect)
    using 0 unfolding 2 apply blast
    using 1 unfolding 2 by blast
  show ?thesis using 3 2 c_decomposables_def by blast
qed

lemma union_is_c_decomposable:
  assumes "is_c_decomposable m c A"
  assumes "is_c_decomposable m c B"
  shows "is_c_decomposable m c (A \<union> B)"
proof-
  have 0: "A \<in> c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    by(rule is_c_decomposable_algebra, rule assms )
  have 1: "B \<in> c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    by(rule is_c_decomposable_algebra, rule assms )
  have 2: "c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) = gen_boolean_algebra (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (Cells\<^bsub>m,c\<^esub>((carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))))"
    by(rule c_decomposable_is_gen_boolean_algebra, rule carrier_is_c_decomposable', rule assms )
  have 3: "A \<union> B\<in> gen_boolean_algebra (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (Cells\<^bsub>m,c\<^esub>((carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))))"
    apply(rule gen_boolean_algebra.union)
    using 0 unfolding 2 apply blast
    using 1 unfolding 2 by blast
  show ?thesis using 3 2 c_decomposables_def by blast
qed

lemma diff_is_c_decomposable:
  assumes "is_c_decomposable m c A"
  assumes "is_c_decomposable m c B"
  shows "is_c_decomposable m c (A - B)"
proof-
  have 0: "A \<in> c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    by(rule is_c_decomposable_algebra, rule assms )
  have 1: "B \<in> c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    by(rule is_c_decomposable_algebra, rule assms )
  have 2: "c_decomposables m c (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) = gen_boolean_algebra (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (Cells\<^bsub>m,c\<^esub>((carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))))"
    by(rule c_decomposable_is_gen_boolean_algebra, rule carrier_is_c_decomposable', rule assms )
  have 3: "A - B\<in> gen_boolean_algebra (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (Cells\<^bsub>m,c\<^esub>((carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))))"
    apply(rule gen_boolean_algebra_diff)
    using 0 unfolding 2 apply blast
    using 1 unfolding 2 by blast
  show ?thesis using 3 2 c_decomposables_def by blast
qed

lemma intersection_in_c_decomposables: 
  assumes "is_c_decomposable m c A"
  assumes "B \<in> c_decomposables m c C"
  shows "(A \<inter> B) \<in> c_decomposables m c C"
  unfolding c_decomposables_def mem_Collect_eq 
  apply(rule conjI, rule intersection_is_c_decomposable, rule assms)
  using assms unfolding c_decomposables_def apply blast
  using assms unfolding c_decomposables_def by blast

lemma intersection_in_c_decomposables': 
  assumes "is_c_decomposable m c A"
  assumes "B \<in> c_decomposables m c C"
  shows "(B \<inter> A) \<in> c_decomposables m c C"
  unfolding c_decomposables_def mem_Collect_eq 
  apply(rule conjI, rule intersection_is_c_decomposable)
  using assms unfolding c_decomposables_def apply blast
  using assms apply blast
  using assms unfolding c_decomposables_def by blast

lemma condition_to_set_cell_decomp:
  assumes "A = condition_to_set \<C>"
  assumes "is_cell_condition \<C>"
  assumes "arity \<C> = m"
  shows "is_cell_decomp m {\<C>} A"
  apply(rule is_cell_decompI, blast, rule is_partitionI, rule Generated_Boolean_Algebra.disjointI, blast)
  using assms apply blast using assms arity.simps apply blast
  using assms condition_to_set.simps unfolding cell_def 
   apply (meson cell_condition_to_set_subset)
  by blast 

lemma cell_is_c_decomposable: 
  assumes "is_cell_condition (Cond m C c a1 a2 I)"
  shows "is_c_decomposable m c (condition_to_set (Cond m C c a1 a2 I))"
  apply(rule is_c_decomposableI[of "{Cond m C c a1 a2 I}"], blast, rule conjI, rule condition_to_set_cell_decomp
        , blast, rule assms, rule arity.simps)
  unfolding singleton_mem using center.simps by blast

lemma endpoint_c_algebra_is_c_decomposable:
  assumes "c \<in> carrier (SA m)"
  assumes "is_semialgebraic m B"
  assumes "a1 \<in> carrier (SA m)"
  assumes "a2 \<in> carrier (SA m)"
  assumes "is_convex_condition I"
  assumes "finite Fs"
  assumes "\<And>f. f \<in> Fs \<Longrightarrow> f \<in> carrier (SA m)"
  assumes "C \<in> endpoint_c_algebra m c B a1 a2 I Fs"
  shows "is_c_decomposable m c C"
apply(rule gen_boolean_algebra.induct[of _  " (condition_to_set (Cond m B c a1 a2 I))" " (condition_to_set ` (\<Union> (f,g) \<in> Fs \<times> Fs. (endpoint_generators m c B f g)))"])
  using assms unfolding endpoint_c_algebra_def apply blast
     apply(rule c_cell_is_c_decomposable, rule is_cell_conditionI', rule assms, rule assms, rule assms, rule assms, rule assms )
  proof- 
    fix x assume A: "x \<in>  condition_to_set ` (\<Union>(f, g)\<in>Fs \<times> Fs. endpoint_generators m c B f g)"
    then obtain f g \<C> where fg_def: "(f,g) \<in> Fs \<times> Fs \<and> \<C> \<in>  endpoint_generators m c B f g \<and> x = condition_to_set  \<C>"
      by blast 
    have f_in: "f \<in> Fs"
      using fg_def by blast 
    have g_in: "g \<in> Fs"
      using fg_def by blast
    obtain J where J_def: "is_convex_condition J \<and> \<C> = Cond m B c f g J"
      using fg_def endpoint_generators_def by blast 
    have \<C>_eq: "\<C> = Cond m B c f g J"
      using J_def by blast 
    have \<C>_cell_cond: "is_cell_condition \<C>"
      apply(rule endpoint_generators_cell_cond[of m B c f g], rule assms, rule assms, rule assms, rule f_in, rule assms, rule g_in)
      using fg_def by blast 
    have 0: " c_decomposables m c (condition_to_set (Cond m B c a1 a2 I)) =
      gen_boolean_algebra (condition_to_set (Cond m B c a1 a2 I)) (Cells\<^bsub>m, c\<^esub>(condition_to_set (Cond m B c a1 a2 I)))"
      apply(rule c_decomposable_is_gen_boolean_algebra[of m c ])
      by(rule c_cell_is_c_decomposable, rule is_cell_conditionI', rule assms, rule assms, rule assms, rule assms, rule assms )
    have x_eq: "x = condition_to_set \<C>"
      using fg_def by blast 
    have 1:  "(x \<inter> condition_to_set (Cond m B c a1 a2 I))  \<in> c_decomposables m c (condition_to_set (Cond m B c a1 a2 I))"
      apply(rule intersection_in_c_decomposables)
      unfolding x_eq \<C>_eq apply(rule cell_is_c_decomposable)
      using \<C>_cell_cond unfolding \<C>_eq apply blast
      unfolding c_decomposables_def mem_Collect_eq apply(rule conjI)
       apply(rule cell_is_c_decomposable)
      by(rule is_cell_conditionI', rule assms, rule assms, rule assms, rule assms, rule assms, blast)
    show "is_c_decomposable m c (x \<inter> condition_to_set (Cond m B c a1 a2 I))"
      using 1 unfolding c_decomposables_def by blast 
  next
    fix A C assume A: " A \<in> gen_boolean_algebra (condition_to_set (Cond m B c a1 a2 I)) (condition_to_set ` (\<Union>(f, g)\<in>Fs \<times> Fs. endpoint_generators m c B f g))"
                      "is_c_decomposable m c A"
                      " C \<in> gen_boolean_algebra (condition_to_set (Cond m B c a1 a2 I)) (condition_to_set ` (\<Union>(f, g)\<in>Fs \<times> Fs. endpoint_generators m c B f g))"
                      "is_c_decomposable m c C"
    show "is_c_decomposable m c (A \<union> C)"
      by(rule union_is_c_decomposable, rule A, rule A)
  next
    fix A assume A: " A \<in> gen_boolean_algebra (condition_to_set (Cond m B c a1 a2 I)) (condition_to_set ` (\<Union>(f, g)\<in>Fs \<times> Fs. endpoint_generators m c B f g))"
                    " is_c_decomposable m c A"
    show "is_c_decomposable m c (condition_to_set (Cond m B c a1 a2 I) - A)"
      by(rule diff_is_c_decomposable, rule cell_is_c_decomposable, rule is_cell_conditionI', 
            rule assms, rule assms, rule assms, rule assms, rule assms, rule A)
  qed

lemma endpoint_c_algebra_atomic_cell_decomp:
  assumes "is_cell_condition (Cond m C c a1 a2 I)"
  assumes "finite Gs"
  assumes "Gs \<subseteq> carrier (SA m)"
  shows "\<exists>S. is_cell_decomp m S (condition_to_set (Cond m C c a1 a2 I)) \<and> (\<forall>B \<in> S. center B = c \<and> 
            (\<forall>f \<in> Gs. \<forall>g \<in> Gs. \<forall>I. is_convex_condition I \<longrightarrow> 
        condition_to_set B \<subseteq> condition_to_set (Cond m C c f g I) \<or> condition_to_set B \<inter> condition_to_set (Cond m C c f g I) = {}))"
proof-
  obtain Fs where Fs_def: "Fs = Gs \<union> {a1, a2}"
    by blast 
  have finite_Fs: "finite Fs"
    unfolding Fs_def finite_Un by(rule conjI, rule assms, blast)
  obtain As where As_def: "As = atoms_of (endpoint_c_algebra m c C a1 a2 I (Fs))"
    by blast 
  have 0: "\<Union> As = condition_to_set (Cond m C c a1 a2 I)"
    unfolding As_def apply(rule atoms_of_covers)
    apply(rule equalityI)
    using gen_boolean_algebra.universe[of "condition_to_set (Cond m C c a1 a2 I)" "(condition_to_set ` (\<Union>(x, y)\<in>Fs \<times> Fs. endpoint_generators m c C x y))"]
    unfolding endpoint_c_algebra_def apply blast
    using gen_boolean_algebra_subset[of _ "condition_to_set (Cond m C c a1 a2 I)" "(condition_to_set ` (\<Union>(x, y)\<in>Fs \<times> Fs. endpoint_generators m c C x y))"]
    by blast
  have 1: "finite ((\<Union>(x, y)\<in>Fs \<times> Fs. endpoint_generators m c C x y))"
    apply(rule Finite_Set.finite_UN_I)
    using assms finite_Fs apply blast 
  proof- fix a assume A: "a \<in> Fs \<times> Fs"
    then obtain x y where xy_def: "a = (x,y)"
      by blast 
    have 0: " (case a of (x, y) \<Rightarrow> endpoint_generators m c C x y) =  endpoint_generators m c C x y"
      unfolding xy_def by blast
    show "finite (case a of (x, y) \<Rightarrow> endpoint_generators m c C x y)"
      unfolding 0 by(rule endpoint_generators_finite )
  qed   
  have 2: "gen_boolean_algebra (condition_to_set (Cond m C c a1 a2 I)) (condition_to_set ` (\<Union>(x, y)\<in>Fs \<times> Fs. endpoint_generators m c C x y)) = gen_boolean_algebra (condition_to_set (Cond m C c a1 a2 I))
   ((\<inter>) (condition_to_set (Cond m C c a1 a2 I)) ` condition_to_set ` (\<Union>(x, y)\<in>Fs \<times> Fs. endpoint_generators m c C x y))"
    using gen_boolean_algebra_restrict_generators[of "condition_to_set (Cond m C c a1 a2 I)" "(condition_to_set ` (\<Union>(x, y)\<in>Fs \<times> Fs. endpoint_generators m c C x y))"]
    by blast 
  have 3: "condition_to_set  (Cond m C c a1 a2 I) \<in> ((\<inter>) (condition_to_set (Cond m C c a1 a2 I)) ` condition_to_set ` (\<Union>(x, y)\<in>Fs \<times> Fs. endpoint_generators m c C x y))"
  proof- 
    have 00: "(a1, a2) \<in> Fs \<times> Fs"
      unfolding Fs_def by blast 
    have 01: "Cond m C c a1 a2 I \<in>  (\<Union>(x, y)\<in>Fs \<times> Fs. endpoint_generators m c C x y)"
    proof-
      have 000: "Cond m C c a1 a2 I \<in> {\<C>. \<exists>I. is_convex_condition I \<and> \<C> = Cond m C c a1 a2 I}"
        using assms is_cell_conditionE(5) by blast 
      show ?thesis 
      unfolding endpoint_generators_def using 00 000  by blast 
    qed
    show ?thesis using 00 01 by blast 
  qed
  have 4: "As \<subseteq> endpoint_c_algebra m c C a1 a2 I Fs"
    apply(rule subsetI)
    unfolding endpoint_c_algebra_def 2
    apply(rule atoms_closed) using 1 apply blast
    unfolding As_def endpoint_c_algebra_def unfolding 2 apply blast
    unfolding 2 using 3 by blast 
  have 5: "\<And>a. a \<in> As \<Longrightarrow> is_c_decomposable m c a"
    apply(rule endpoint_c_algebra_is_c_decomposable[of c m C a1 a2 I Fs])
    apply(rule is_cell_conditionE[of m C c a1 a2 I], rule assms)
    apply(rule is_cell_conditionE[of m C c a1 a2 I], rule assms)
    apply(rule is_cell_conditionE[of m C c a1 a2 I], rule assms)
    apply(rule is_cell_conditionE[of m C c a1 a2 I], rule assms)
    apply(rule is_cell_conditionE[of m C c a1 a2 I], rule assms)
      apply(rule finite_Fs)
    unfolding Fs_def using assms is_cell_conditionE(4,3)[of m C c a1 a2 I]
     apply blast
    using 4 unfolding Fs_def by blast
  obtain F where F_def: "F = (\<lambda>a. (SOME S.  S \<noteq> {} \<and> is_cell_decomp m S a \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)))"
    by blast
  have 6: "\<And>a. a \<in> As \<Longrightarrow> \<exists>S. S \<noteq> {} \<and> is_cell_decomp m S a \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
    using is_c_decomposableE[of m c ] 5 by blast
  have 7: "\<And>a. a \<in> As \<Longrightarrow> (F a) \<noteq> {} \<and> is_cell_decomp m (F a) a \<and> (\<forall>C. C \<in> (F a)  \<longrightarrow> center C = c)"
  proof- fix a assume A: "a \<in> As"
    obtain S where S_def: "S \<noteq> {} \<and> is_cell_decomp m S a \<and> (\<forall>C. C \<in> S \<longrightarrow> center C = c)"
      using 6 A by blast 
    show " (F a) \<noteq> {} \<and>is_cell_decomp m (F a) a \<and> (\<forall>C. C \<in> F a \<longrightarrow> center C = c)"
      apply(rule SomeE[of "F a" _ S]) unfolding F_def apply blast
      by(rule S_def)
  qed
  have 8: "finite (\<Union> (F ` As))"
    apply(rule Finite_Set.finite_UN_I)
    unfolding As_def endpoint_c_algebra_def apply(rule atoms_finite)
    using 1 unfolding endpoint_generators_def apply blast
    using 7 is_cell_decompE(1) unfolding As_def endpoint_c_algebra_def endpoint_generators_def 
    by blast
  have 9: "condition_to_set ` \<Union> (F ` As) partitions condition_to_set (Cond m C c a1 a2 I)"
  proof(rule is_partitionI, rule Generated_Boolean_Algebra.disjointI)
    fix A B assume A: "A \<in> condition_to_set ` \<Union> (F ` As)" "B \<in> condition_to_set ` \<Union> (F ` As)" "A \<noteq> B"
    obtain a C where a_def: "a \<in> As \<and> C \<in> F a \<and>  A = condition_to_set C "
      using A by blast 
    obtain b C' where b_def: "b \<in> As \<and> C' \<in> F b \<and>  B = condition_to_set C' "
      using A by blast 
    have A_eq: "A = condition_to_set C"
      using a_def by blast 
    have B_eq: "B = condition_to_set C'"
      using b_def by blast 
    have A_sub: "A \<subseteq> a"
      using a_def 7[of a] is_cell_decompE(2) is_partitionE(2) 
      by (metis is_cell_decomp_subset)
    have B_sub: "B \<subseteq> b"
      using b_def 7[of b] is_cell_decompE(2) is_partitionE(2) 
      by (metis is_cell_decomp_subset)  
    have 0: "a \<noteq> b \<Longrightarrow> a \<inter> b = {}"
      using a_def b_def unfolding As_def 
      using atoms_of_disjoint by blast
    show "A \<inter> B = {}"
      apply(cases "a = b")
      using a_def b_def is_cell_decompE is_partitionE 7 
       apply (metis (no_types, lifting) A(3))
      using 0 A_sub B_sub by blast 
  next 
    have 10: "\<And>a. a \<in> As \<Longrightarrow> a \<subseteq> condition_to_set (Cond m C c a1 a2 I)"
      using 0 by blast
    show "\<Union> (condition_to_set ` \<Union> (F ` As)) = condition_to_set (Cond m C c a1 a2 I)"
    proof(rule equalityI') fix x assume A: "x \<in> \<Union> (condition_to_set ` \<Union> (F ` As))"
    obtain a \<C> where a_def: "a \<in> As \<and> \<C> \<in> F a \<and> x \<in>  condition_to_set \<C> "
      using A by blast 
    have 11: "condition_to_set \<C>  \<subseteq> a"
      using a_def 7 is_cell_decompE(2) is_partitionE(2) by blast 
    show "x \<in> condition_to_set (Cond m C c a1 a2 I)"
      using a_def 11 10[of a] A by blast 
    next
      fix x assume A: "x \<in> condition_to_set (Cond m C c a1 a2 I)"
      obtain a where a_def: "a \<in> As \<and> x \<in> a"
      using A 0 by blast 
    obtain \<C> where \<C>_def: "\<C> \<in> F a \<and> x \<in> condition_to_set \<C>"
      using a_def 7[of a] is_cell_decompE(2) is_partitionE(2) by blast 
    show "x \<in> \<Union> (condition_to_set ` \<Union> (F ` As))"
      using A \<C>_def a_def by blast 
    qed
  qed
  have 10: "is_cell_decomp m (\<Union> (F ` As)) (condition_to_set (Cond m C c a1 a2 I))"
    apply(rule is_cell_decompI, rule 8, rule 9)
    using 7 is_cell_decompE apply blast
    unfolding condition_to_set.simps cell_def  apply blast
  proof- 
    fix \<C> \<C>' assume A: "\<C> \<in> \<Union> (F ` As)" "\<C>' \<in> \<Union> (F ` As)" "\<C> \<noteq> \<C>'"
    obtain a where a_def: "a \<in> As \<and> \<C> \<in> F a"
      using A by blast 
    obtain b where b_def: "b \<in> As \<and> \<C>' \<in> F b"
      using A by blast    
    have A_sub: "condition_to_set \<C> \<subseteq> a"
      using a_def 7[of a] is_cell_decompE(2) is_partitionE(2) 
      by (metis is_cell_decomp_subset)
    have B_sub: "condition_to_set \<C>' \<subseteq> b"
      using b_def 7[of b] is_cell_decompE(2) is_partitionE(2) 
      by (metis is_cell_decomp_subset) 
    have 0: "a \<noteq> b \<Longrightarrow> a \<inter> b = {}"
      using a_def b_def unfolding As_def 
      using atoms_of_disjoint by blast
    show "condition_to_set \<C> \<inter> condition_to_set \<C>' = {}"
      apply(cases "a = b")
       apply(rule is_cell_decompE(5)[of m "F a" a])
      using a_def  7[of a] apply blast
      using a_def apply blast using a_def b_def apply blast
      using A apply blast
      using 0 A_sub B_sub by blast 
  qed
  have 11: " (\<forall>B\<in>(\<Union> (F ` As)). center B = c \<and>
                (\<forall>f\<in>Gs.
                    \<forall>g\<in>Gs.
                       \<forall>I. is_convex_condition I \<longrightarrow>
                           condition_to_set B \<subseteq> condition_to_set (Cond m C c f g I) \<or>
                           condition_to_set B \<inter> condition_to_set (Cond m C c f g I) = {}))"
  proof fix B assume A: "B \<in>(\<Union> (F ` As))"
    obtain a where a_def: "a \<in> As \<and> B\<in> F a"
      using A by blast 
    have 110: "center B = c"
      using a_def 7 [of a] by blast 
    have 111: " (\<forall>f\<in>Gs.
             \<forall>g\<in>Gs.
                \<forall>I. is_convex_condition I \<longrightarrow>
                    condition_to_set B \<subseteq> condition_to_set (Cond m C c f g I) \<or> condition_to_set B \<inter> condition_to_set (Cond m C c f g I) = {})"
    proof(rule, rule, rule, rule) fix f g J
      assume A': "f \<in> Gs" "g \<in> Gs" "is_convex_condition J"
      have 00: "(Cond m C c f g J) \<in> endpoint_generators m c C f g"
        unfolding endpoint_generators_def using A' by blast 
      have 01: "(f,g) \<in> Gs \<times> Gs"
        using A' by blast
      have 02: "condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I)  \<in>  endpoint_c_algebra m c C a1 a2 I Fs"
        unfolding endpoint_c_algebra_def 
        apply(rule gen_boolean_algebra.generator)
        using 00 01 Fs_def  by blast 
      have 03: "condition_to_set B \<subseteq>condition_to_set (Cond m C c a1 a2 I)"
        using a_def As_def 0 
        by (metis "7" Sup_upper2 is_cell_decomp_subset)
      show " condition_to_set B \<subseteq> condition_to_set (Cond m C c f g J) \<or> condition_to_set B \<inter> condition_to_set (Cond m C c f g J) = {}"
      proof(cases "condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I) = {}")
        case True
        then show ?thesis using 03 by blast 
      next
        case False
        show "condition_to_set B \<subseteq> condition_to_set (Cond m C c f g J) \<or> condition_to_set B \<inter> condition_to_set (Cond m C c f g J) = {}"
        proof(cases "condition_to_set B \<subseteq> condition_to_set (Cond m C c f g J)")
          case True
          then show ?thesis by blast 
        next
        case F: False
        obtain x where x_def: "x \<in> condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I)"
          using False by blast 
        have F0: "x \<in> \<Union> (endpoint_c_algebra m c C a1 a2 I Fs)"
          using x_def 02 by blast  
        obtain b where b_def: "b\<in> As \<and> x \<in> b"
          using F0 atoms_of_covers' unfolding As_def  
          using "0" As_def x_def by blast
        have F1: "b \<subseteq>condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I)"
          using atoms_are_minimal[of b "endpoint_c_algebra m c C a1 a2 I Fs" "condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I)"]
                b_def  x_def unfolding As_def 
          using "02" by blast
        have F2: "condition_to_set  B \<subseteq> a"
          using a_def A is_cell_decompE(2)[of m "F a" a] is_partitionE(2) 7[of a] by blast
        obtain y where y_def: "y \<in> condition_to_set B \<and> y \<notin>condition_to_set (Cond m C c f g J) "
          using F by blast 
        have F3: "condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I) \<inter> a = {} \<or>
                   a \<subseteq> condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I)"
          apply(rule atoms_are_minimal[of a " endpoint_c_algebra m c C a1 a2 I Fs" "condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I)"])
          using a_def unfolding As_def apply blast
          by(rule 02)
        have F4:  "condition_to_set B \<subseteq> condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I) \<or> condition_to_set B \<inter> condition_to_set (Cond m C c f g J) \<inter> condition_to_set (Cond m C c a1 a2 I) = {}"
          using F3 F2 by blast
        show "condition_to_set B \<subseteq> condition_to_set (Cond m C c f g J) \<or> condition_to_set B \<inter> condition_to_set (Cond m C c f g J) = {}"
          using F  F4  03 by blast
      qed
    qed
     qed
     show " center B = c \<and>
         (\<forall>f\<in>Gs.
             \<forall>g\<in>Gs.
                \<forall>I. is_convex_condition I \<longrightarrow>
                    condition_to_set B \<subseteq> condition_to_set (Cond m C c f g I) \<or> condition_to_set B \<inter> condition_to_set (Cond m C c f g I) = {})"
       using 110 111 by blast 
  qed
  show ?thesis using 10 11 by blast 
qed

lemma semialg_boundary_cell_decomp:
  assumes "finite Fs"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "is_cell_condition \<C>"
  assumes "\<C> = Cond m B c a1 a2 I"
  shows "\<exists>S. is_cell_decomp m S (condition_to_set (Cond m B c a1 a2 I)) \<and> (\<forall>C \<in> S. center C = c \<and> 
            (\<forall>f \<in> Fs. \<forall>g \<in> Fs. \<forall>I. is_convex_condition I \<longrightarrow> 
        condition_to_set C \<subseteq> condition_to_set (Cond m B c f g I) \<or> condition_to_set C \<inter> condition_to_set (Cond m B c f g I) = {}))"
  apply(rule endpoint_c_algebra_atomic_cell_decomp)
  using assms unfolding assms apply blast
  by(rule assms, rule assms )
end 

(**************************************************************************************************)
(**************************************************************************************************)
subsubsection\<open>Cell Algebras\<close>
(**************************************************************************************************)
(**************************************************************************************************)

text\<open>This section formalizes a type of set system which we call a cell algebra. The intent is to 
capture the basic properties of the class of sets which can be generated from disjoint unions of 
some basic type of set. We call the generators cells, and in application we will apply this 
formalization to certain classes of $p$-adic cells. The main point is that we are interested in 
showing that such systems are closed under finite unions, even if they may not be disjoint.\<close>

context padic_fields
begin

inductive_set cell_algebra
  for Cells  where
    empty: "{} \<in> cell_algebra Cells"
  | generator:  "A \<in> Cells \<Longrightarrow> A \<in> cell_algebra Cells"
  | disjoint_union:      "\<lbrakk>A \<in> cell_algebra Cells ; C \<in> cell_algebra Cells; A \<inter> C = {}\<rbrakk> \<Longrightarrow> A \<union> C \<in> cell_algebra Cells"

lemma cell_algebra_union:
  assumes "\<And> A C. \<lbrakk>A \<in> cell_algebra B ; C \<in> cell_algebra B\<rbrakk> \<Longrightarrow> A \<inter> C \<in> cell_algebra B"
  assumes "\<And> A C. \<lbrakk>A \<in> cell_algebra B ; C \<in> cell_algebra B\<rbrakk> \<Longrightarrow> A - C \<in> cell_algebra B"
  shows "\<And> A C. \<lbrakk>A \<in> cell_algebra B ; C \<in> cell_algebra B\<rbrakk> \<Longrightarrow> A \<union> C \<in> cell_algebra B"
proof- fix A C assume A: "A \<in> cell_algebra B" "C \<in> cell_algebra B"
  have 0: "A \<union> C = (A - C) \<union> (C - A) \<union> (A \<inter> C)"
    by blast 
  show "A \<union> C \<in> cell_algebra B" unfolding 0 
    apply(rule cell_algebra.disjoint_union)
    apply(rule cell_algebra.disjoint_union)
    apply(rule assms ) using A apply blast using A apply blast 
    apply(rule assms ) using A apply blast using A apply blast 
      apply blast 
    apply(rule assms ) using A apply blast using A apply blast 
    by blast 
qed

lemma cell_algebra_cell_union:
  assumes "\<And> A C. \<lbrakk>A \<in> Cells ; C \<in> Cells\<rbrakk> \<Longrightarrow> A \<inter> C \<in> cell_algebra B"
  assumes "\<And> A C. \<lbrakk>A \<in> Cells ; C \<in> Cells\<rbrakk> \<Longrightarrow> A - C \<in> cell_algebra B"
  shows "\<And> A C. \<lbrakk>A \<in> Cells ; C \<in> Cells\<rbrakk> \<Longrightarrow> A \<union> C \<in> cell_algebra B"
proof- fix A C assume A: "A \<in> Cells" "C \<in> Cells"
  have 0: "A \<union> C = (A - C) \<union> (C - A) \<union> (A \<inter> C)"
    by blast 
  show "A \<union> C \<in> cell_algebra B" unfolding 0 
    apply(rule cell_algebra.disjoint_union)
    apply(rule cell_algebra.disjoint_union)
    using A cell_algebra.generator assms A 
    apply auto[1]
        using A cell_algebra.generator assms A 
           apply auto[1]
        apply blast 
        apply(rule assms(1))
        using  A by auto 
qed

lemma disjoint_insert:
  assumes "disjoint S"
  assumes "\<And>s. s \<in> S \<Longrightarrow> A \<inter> s = {}"
  shows "disjoint (insert A S)"
proof(rule disjointI)
  fix s s' assume A: "s \<in> insert A S" "s' \<in> insert A S" "s \<noteq> s'"
  show " s \<inter> s' = {}"
    apply(cases "s = A")
    using A assms apply blast 
    apply(cases "s' = A")
    using A assms apply blast 
    using A assms disjointE by blast 
qed

lemma cell_algebra_finite_disjoint_union:
  assumes "S \<subseteq> cell_algebra B"
  assumes  "finite S"
  assumes "disjoint S"
  shows "\<Union> S \<in> cell_algebra B"
proof-
  have "S \<subseteq> cell_algebra B \<and> disjoint S \<longrightarrow> \<Union> S \<in> cell_algebra B"
    apply(rule finite.induct[of S], intro assms)
    using cell_algebra.empty apply auto[1]
    unfolding insert_subset 
    using assms cell_algebra.disjoint_union 
    Generated_Boolean_Algebra.disjoint_def Sup_insert insert_absorb 
    insert_partition 
    by (metis DiffD1 Diff_insert_absorb)  
  thus ?thesis using assms by auto 
qed

definition cell_disjointify where
"cell_disjointify A S = insert (A - (\<Union>  S)) (((\<inter>) A ` S) \<union> (\<lambda>x. x - A) ` S)"

text\<open>If A is a set and S is a disjoint collection of sets, then cell\_disjointify A S will return a 
new collection of disjoint sets which has the same union as $\bigcup$ (insert A S)\<close>

lemma disjoint_fact:
  assumes "disjoint S"
  shows "disjoint (((\<inter>) A ` S) \<union> (\<lambda>x. x - A) ` S)"
proof(rule disjointI)
  fix s s' assume A: " s \<in> (\<inter>) A ` S \<union> (\<lambda>x. x - A) ` S" "s' \<in> (\<inter>) A ` S \<union> (\<lambda>x. x - A) ` S" "s \<noteq> s'"
  show " s \<inter> s' = {}" 
    apply(cases "s \<in> (\<inter>) A ` S")
     apply(cases "s' \<in> (\<inter>) A ` S") using A assms disjointE[of S] 
    by auto 
qed

lemma cell_disjointify_disjoint:
  assumes  "disjoint S"
  shows "disjoint (cell_disjointify A S)"
  unfolding cell_disjointify_def 
  apply(rule disjoint_insert)
  using assms disjoint_fact[of S A] apply blast 
  by auto 

lemma cell_disjointify_union:
  assumes  "disjoint S"
  shows "\<Union>(cell_disjointify A S) = \<Union> (insert A S)"
  apply(rule equalityI) 
  apply (rule subsetI)
  using assms unfolding cell_disjointify_def apply blast 
  using assms unfolding cell_disjointify_def by blast 

lemma empty_disjoint:
"disjoint {}"
  apply(rule disjointI)
  by auto 

lemma cell_algebra_cell_decomp:
  assumes "A \<in> cell_algebra Cells"
  shows "\<exists>S \<subseteq> Cells. finite S \<and> disjoint S \<and> \<Union> S = A"
  apply(rule cell_algebra.induct[of A Cells])
  using assms apply blast 
    using disjointI empty_disjoint apply blast 
   using insert_subset disjointI disjoint_insert 
   apply (metis bot.extremum ccpo_Sup_singleton empty_disjoint equals0D finite.simps insert_subsetI)
 proof- fix A C assume A: "A \<in> cell_algebra Cells"
           "\<exists>S\<subseteq>Cells. finite S \<and> disjoint S \<and> \<Union> S = A"
           "C \<in> cell_algebra Cells"
           "\<exists>S\<subseteq>Cells. finite S \<and> disjoint S \<and> \<Union> S = C"
           "A \<inter> C = {}"
   obtain S where S_def: "S\<subseteq>Cells \<and> finite S \<and> disjoint S \<and> \<Union> S = A"
     using A by blast 
   obtain S' where S'_def: "S'\<subseteq>Cells \<and> finite S' \<and> disjoint S' \<and> \<Union> S' = C"
     using A by blast 
   have "finite (S \<union> S') \<and> disjoint (S \<union> S') \<and> \<Union> (S \<union> S') = A \<union> C"
     apply(rule conjI)
     using S_def S'_def apply blast 
     apply(rule conjI)
     apply(rule disjointI)
     using S_def S'_def A disjointE[of S] disjointE[of S'] 
      apply (metis Sup_inf_eq_bot_iff Un_iff inf_commute)
     using S_def S'_def by blast 
   thus "\<exists>S\<subseteq>Cells. finite S \<and> disjoint S \<and> \<Union> S = A \<union> C"
     using S_def S'_def 
     by (meson Un_subset_iff)
 qed

lemma cell_algebra_minus_union:
  assumes "\<And> A C. \<lbrakk>A \<in> Cells ; C \<in> Cells\<rbrakk> \<Longrightarrow> A - C \<in> cell_algebra Cells"
  shows "\<And> A C. \<lbrakk>A \<in> Cells ; C \<subseteq> Cells ; finite C\<rbrakk> \<Longrightarrow> A - \<Union>C \<in> cell_algebra Cells"
proof- fix A C assume A: "A \<in> Cells" "C \<subseteq> Cells" "finite C"
  have "C \<subseteq> Cells \<longrightarrow> A - \<Union>C \<in> cell_algebra Cells"
    apply(rule finite.induct[of C])
    using A apply blast 
    using A cell_algebra.generator[of A Cells] apply auto[1]
  proof- fix C c assume AA: "finite C" "C \<subseteq> Cells \<longrightarrow> A - \<Union> C \<in> cell_algebra Cells"
    show "insert c C \<subseteq> Cells \<longrightarrow> A - \<Union> (insert c C) \<in> cell_algebra Cells"
    proof assume AAA: "insert c C \<subseteq> Cells"
      hence 0: "A - \<Union> C \<in> cell_algebra Cells"
        using AA by blast 
      obtain S where S_def: "S \<subseteq> Cells \<and> disjoint S \<and> finite S \<and> \<Union> S =  A - \<Union> C"
        using 0 cell_algebra_cell_decomp[of "A - \<Union> C" Cells] by blast 
      have  1: "A - \<Union> (insert c C) = \<Union> S - c"
        using S_def by blast 
      hence 2: "A - \<Union> (insert c C) = \<Union> ((\<lambda>s. s- c) ` S)"
        by auto
      have 3: "c \<in> Cells"
        using AAA by blast 
      show "A - \<Union> (insert c C) \<in> cell_algebra Cells"
        unfolding 2 apply(rule cell_algebra_finite_disjoint_union)
        using S_def assms[of _ c] 3 apply blast 
        using S_def apply blast 
        apply(rule disjointI)
        using S_def disjointE by blast 
    qed
  qed
  thus "A - \<Union>C \<in> cell_algebra Cells"
    using A by blast 
qed

lemma cell_algebra_finite_union:
  assumes "\<And> A C. \<lbrakk>A \<in> Cells ; C \<in> Cells\<rbrakk> \<Longrightarrow> A \<inter> C \<in> cell_algebra Cells"
  assumes "\<And> A C. \<lbrakk>A \<in> Cells ; C \<in> Cells\<rbrakk> \<Longrightarrow> A - C \<in> cell_algebra Cells"
  shows "\<And>S. finite S \<and> S \<subseteq> Cells \<Longrightarrow> \<Union> S \<in> cell_algebra Cells"
proof- 
  fix S assume A: "finite S \<and> S \<subseteq> Cells"
  have "finite S \<and> S \<subseteq> Cells \<longrightarrow> \<Union> S \<in> cell_algebra Cells"
    apply(rule finite.induct[of S])
    using A apply blast 
    using cell_algebra.empty 
    apply (simp add: cell_algebra.empty)
  proof fix A a
    assume AA: "finite A" " finite A \<and> A \<subseteq> Cells \<longrightarrow> \<Union> A \<in> cell_algebra Cells" "finite (insert a A) \<and> insert a A \<subseteq> Cells"
    then have 0: " \<Union> A \<in> cell_algebra Cells"
      by blast 
    obtain S where S_def: "S \<subseteq> Cells \<and> finite S \<and> disjoint S \<and> \<Union> S =  \<Union> A"
      using 0 by (meson cell_algebra_cell_decomp)
    obtain S' where S'_def: "S' = cell_disjointify a S"
      by blast 
    have 1: " \<Union> (insert a A) = \<Union> S'"
      unfolding S'_def using S_def 
      by (simp add: cell_disjointify_union)
    have 2: "a \<in> Cells"
      using AA by blast 
    have 3: "S' \<subseteq> cell_algebra Cells"
    proof fix x assume AA: "x \<in> S'"
      show "x \<in> cell_algebra Cells"
        using AA unfolding S'_def unfolding cell_disjointify_def 
        apply(cases "x = a - \<Union> S")
        using 2 assms cell_algebra_minus_union[of Cells a S] S_def 
        apply simp
        apply(cases "x \<in> (\<inter>) a ` S")
        using assms(1)[of a ] S_def AA 2 apply auto[1]
        using assms(2)[of _ a ] S_def AA 2 by auto 
    qed
    show "\<Union> (insert a A) \<in> cell_algebra Cells"
      unfolding 1 using  3 S'_def cell_disjointify_disjoint S_def 
      by (metis cell_algebra_finite_disjoint_union cell_disjointify_def finite_UnI finite_imageI finite_insert)
  qed
  thus "\<Union> S \<in> cell_algebra Cells"
    using A by blast 
qed
end

(**************************************************************************************************)
(**************************************************************************************************)
subsection\<open>Cells Whose Convex Condition is a Single Point\<close>
(**************************************************************************************************)
(**************************************************************************************************)

text\<open>Given a cell $\mathcal{C}$\texttt{ = Cond m C c a1 a2 I}, we will frequently be interested in 
decomposing $\mathcal{C}$ into pieces where 
\texttt{val (t }$\ominus$\texttt{ c x) = val (}$\varphi$\texttt{ x)} for some fixed semialgebriaic 
function $\varphi$. This section elaborates on the properties of sets which can be decomposed into 
finite disjoint unions of such cells. Our main concern will be showing that these structures form 
what we called a cell algebra in the previous section. This will be used to proved that finite 
(possibly not disjoint) unions of sets which can be decomposed into these cells can again be 
decomposed into these cells.  \<close>

context padic_fields
begin

lemma one_point_closed_interval:
"condition_to_set (Cond m C c f f closed_interval) = {as \<in> carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>). tl as \<in> C \<and> val (hd as \<ominus> c (tl as)) =  val (f (tl as))}"
  unfolding condition_to_set.simps  cell_def closed_interval_def mem_Collect_eq 
  apply(rule equalityI')
  unfolding mem_Collect_eq using basic_trans_rules(24) apply blast
   by (metis basic_trans_rules(20) notin_closed)

lemma finite_closed_interval_cell_intersection:
  shows 
"condition_to_set (Cond m C c f f closed_interval) \<inter> condition_to_set (Cond m C' c g g closed_interval)
 = condition_to_set (Cond m (C \<inter> C' \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)}) c f f closed_interval)"
  unfolding one_point_closed_interval apply(rule equalityI')
  by(auto simp: Qp_pow_ConsE(1))

lemma finite_closed_interval_cell_diff:
  shows "condition_to_set (Cond m C c f f closed_interval) - condition_to_set (Cond m C' c g g closed_interval) 
          = condition_to_set (Cond m ((C \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)}) - C' \<union> (C - {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)}) ) c f f closed_interval)"
  unfolding one_point_closed_interval
  apply(rule equalityI')
  unfolding mem_Collect_eq 
  apply (metis (mono_tags, lifting) DiffD1 DiffD2 DiffI Int_iff UnCI mem_Collect_eq)
  using Qp_pow_ConsE(1) by auto
  
definition c_cells_at_one_val_point where
"c_cells_at_one_val_point m c Fs C = 
    {\<C>. condition_to_set \<C>  \<subseteq> C \<and> is_cell_condition \<C> \<and> arity \<C> = m \<and> 
      center \<C> = c \<and> u_bound \<C> = l_bound \<C> \<and> u_bound \<C> \<in> Fs \<and>
       boundary_condition \<C> = closed_interval }"

definition one_val_point_c_decomposable where
"one_val_point_c_decomposable m c Fs C A = 
          (\<exists>S. is_cell_decomp m S A \<and> S \<subseteq> c_cells_at_one_val_point m c Fs C)"

definition one_val_point_decomposables where
"one_val_point_decomposables m c Fs C = {A. one_val_point_c_decomposable m c Fs C A}"

lemma  c_cells_at_one_val_point_is_c_decomposable:
  assumes "A \<in> c_cells_at_one_val_point m c Fs C"
  shows "condition_to_set A \<in> one_val_point_decomposables m c Fs C"
proof-
  have 0: "arity A = m"
    using assms unfolding c_cells_at_one_val_point_def by blast 
  have 1: "is_cell_decomp m {A} (condition_to_set A)"
    apply(rule is_cell_decompI)
        apply blast
    apply(rule is_partitionI)
    apply(rule disjointI)
        apply blast 
    apply blast 
    using assms unfolding c_cells_at_one_val_point_def apply blast 
    using condition_decomp'[of A]  condition_to_set.simps  cell_def 0 
    apply (meson cell_condition_to_set_subset)
    by blast 
  show "condition_to_set A \<in> one_val_point_decomposables m c Fs C"
    unfolding one_val_point_decomposables_def one_val_point_c_decomposable_def mem_Collect_eq 
    using 0 1 assms by blast 
qed

lemma one_val_point_decomposables_disjoint_union:
  assumes "A \<in> one_val_point_decomposables m c Fs C"
  assumes "B \<in> one_val_point_decomposables m c Fs C"
  assumes "A \<inter> B = {}"
  shows "A \<union> B \<in> one_val_point_decomposables m c Fs C"
proof-
  obtain S1 where S1_def: "is_cell_decomp m S1 A \<and> S1 \<subseteq> c_cells_at_one_val_point m c Fs C"
    using assms unfolding one_val_point_decomposables_def 
    by (metis one_val_point_c_decomposable_def mem_Collect_eq)
  obtain S2 where S2_def: "is_cell_decomp m S2 B \<and> S2 \<subseteq> c_cells_at_one_val_point m c Fs C"
    using assms unfolding one_val_point_decomposables_def 
    by (metis one_val_point_c_decomposable_def mem_Collect_eq)    
  have p: "A \<union> B - A = B - A"
    by auto 
  have q: "B - A = B"
    using assms by auto 
  have "is_cell_decomp m (S1 \<union> S2) (A \<union> B)"
    apply(rule cell_decomp_union[of "A"])
       apply blast 
    using S1_def S2_def is_cell_decompE(6) apply auto[1]
    using S1_def apply blast 
    unfolding p q using S2_def  by auto 
  thus ?thesis 
    unfolding one_val_point_decomposables_def one_val_point_c_decomposable_def mem_Collect_eq 
    using S1_def S2_def 
    by auto
qed

lemma one_val_point_c_cell_diff:
  assumes "A \<in> c_cells_at_one_val_point m c Fs C"
  assumes "B \<in> c_cells_at_one_val_point m c Fs C"
  shows "\<exists>D \<in> c_cells_at_one_val_point m c Fs C. 
            condition_to_set A - condition_to_set B = condition_to_set D"
          "condition_to_set A - condition_to_set B \<in> one_val_point_decomposables m c Fs C"
proof- 
  obtain A0 f where fA0_def: "f \<in> Fs" "A = Cond m A0 c f f closed_interval"
    using assms unfolding c_cells_at_one_val_point_def 
    by (metis (mono_tags, lifting) condition_decomp' mem_Collect_eq)
  obtain B0 g where gB0_def: "g \<in> Fs" "B = Cond m B0 c g g  closed_interval"
    using assms unfolding c_cells_at_one_val_point_def 
    by (metis (mono_tags, lifting) condition_decomp' mem_Collect_eq)
  have AinC: "condition_to_set A \<subseteq> C"
    using assms unfolding fA0_def c_cells_at_one_val_point_def mem_Collect_eq by blast 
  have 0: "condition_to_set A - condition_to_set B = condition_to_set
     (Cond m (A0 \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)} - B0 \<union> (A0 - {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)})) c f f
       closed_interval)"
    unfolding fA0_def gB0_def finite_closed_interval_cell_diff by blast 
  have A0_semialg: "is_semialgebraic m A0"
    using assms unfolding fA0_def c_cells_at_one_val_point_def mem_Collect_eq  
    using is_cell_conditionE(1) by blast
  have B0_semialg: "is_semialgebraic m B0"
    using assms unfolding gB0_def c_cells_at_one_val_point_def mem_Collect_eq   
    using is_cell_conditionE''(1) by blast
  have 1: "f \<in> carrier (SA m)"
    using assms unfolding gB0_def c_cells_at_one_val_point_def mem_Collect_eq   
    using is_cell_conditionE'' by (metis fA0_def)
  have 2: "g \<in> carrier (SA m)"
    using assms unfolding gB0_def c_cells_at_one_val_point_def mem_Collect_eq   
    using is_cell_conditionE'' by (metis gB0_def)    
  have 3: "is_semialgebraic m {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)}"
    using 1 2 semialg_val_eq_set_is_semialg by blast
  have 4: "c \<in> carrier (SA m)"
    using assms unfolding gB0_def c_cells_at_one_val_point_def mem_Collect_eq   
    using is_cell_conditionE'' by (metis gB0_def)    
  have 5: "is_cell_condition (Cond m (A0 \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)} - B0 \<union> (A0 - {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)})) c f f
       closed_interval)"
    apply(rule is_cell_conditionI') 
        apply(rule union_is_semialgebraic ) apply(rule diff_is_semialgebraic) apply(rule intersection_is_semialg)
    using A0_semialg apply blast using 3 apply blast using  B0_semialg apply blast 
    apply(rule diff_is_semialgebraic) using A0_semialg apply blast using 3 apply blast
    using 4 apply blast using 1 apply blast using 1 apply blast unfolding is_convex_condition_def by blast 
  have 6: "is_cell_decomp m {Cond m (A0 \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)} - B0 \<union> (A0 - {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)})) c f f
       closed_interval}
         (condition_to_set
           (Cond m (A0 \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)} - B0 \<union> (A0 - {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)})) c f f
             closed_interval))"
    apply(rule is_cell_decompI)
        apply blast 
       apply(rule is_partitionI)
    apply(rule disjointI)
        apply blast 
       apply blast 
    using 5 condition_decomp(1) apply blast
    unfolding condition_to_set.simps cell_def apply blast 
    by blast 
  have 7: "condition_to_set
     (Cond m (A0 \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)} - B0 \<union> (A0 - {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)})) c f f
       closed_interval)
    \<subseteq> C"
    using AinC 0 by blast 
  have 8: "Cond m (A0 \<inter> {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)} - B0 \<union> (A0 - {x \<in> carrier (Q\<^sub>p\<^bsup>m\<^esup>). val (f x) = val (g x)})) c f f
       closed_interval \<in> c_cells_at_one_val_point m c Fs C "
    unfolding c_cells_at_one_val_point_def mem_Collect_eq arity.simps u_bound.simps l_bound.simps boundary_condition.simps center.simps 
    using 5 7 fA0_def by blast
  show "condition_to_set A - condition_to_set B \<in> one_val_point_decomposables m c Fs C"
    unfolding 0 one_val_point_decomposables_def one_val_point_c_decomposable_def mem_Collect_eq 
    using 5 6 7 8 by blast 
  show "\<exists>D\<in>c_cells_at_one_val_point m c Fs C. condition_to_set A - condition_to_set B = condition_to_set D"
    using 0 c_cells_at_one_val_point_def 
    using "8" by blast
qed

lemma empty_is_one_val_point_c_cell:
  assumes "c \<in> carrier (SA m)"
  assumes "f \<in> Fs"
  assumes "f \<in> carrier (SA m)"
  shows "{} \<in> condition_to_set ` c_cells_at_one_val_point m c Fs C "
proof-
  obtain \<C> where \<C>_def: "\<C> = Cond m {} c f f closed_interval"
    by blast
  have 0: "is_cell_condition \<C>"
    unfolding \<C>_def apply(rule is_cell_conditionI')
  apply (simp add: empty_is_semialgebraic)
  apply (simp add: assms)
  using assms apply blast
  using assms apply blast
  using is_convex_condition_def by auto
  have 1: "\<C> \<in> c_cells_at_one_val_point m c Fs C "
    using 0 assms
    unfolding \<C>_def c_cells_at_one_val_point_def mem_Collect_eq arity.simps center.simps u_bound.simps l_bound.simps boundary_condition.simps condition_to_set.simps cell_def by blast 
  have 2: "{} = condition_to_set \<C>"
    unfolding \<C>_def condition_to_set.simps cell_def by blast 
  show " {} \<in> condition_to_set ` c_cells_at_one_val_point m c Fs C"
    unfolding  2 using 0 1 assms by blast
qed

lemma empty_one_val_point_c_decomposable:
  assumes "c \<in> carrier (SA m)"
  assumes "f \<in> Fs"
  assumes "f \<in> carrier (SA m)"
  shows "one_val_point_c_decomposable m c Fs C {}"
  using assms empty_is_one_val_point_c_cell[of c m f Fs C] c_cells_at_one_val_point_is_c_decomposable[of _ m c Fs C]
  unfolding one_val_point_decomposables_def mem_Collect_eq 
  by (metis image_iff)

lemma finite_disjoint_union_one_val_point_c_decomposable:
  assumes "c \<in> carrier (SA m)"
  assumes "disjoint S"
  assumes "finite S"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "\<And>s. s \<in> S \<Longrightarrow> one_val_point_c_decomposable m c Fs C s"
  shows "one_val_point_c_decomposable m c Fs C (\<Union> S)"
proof- 
  have "disjoint S \<and> (\<forall>s \<in> S. one_val_point_c_decomposable m c Fs C s) \<longrightarrow> one_val_point_c_decomposable m c Fs C (\<Union> S)"
  proof(rule finite.induct[of S])
    obtain f where f_def: "f \<in> Fs"
      using assms by auto 
    have f_semialg: "f \<in> carrier (SA m)"
      using f_def assms by auto 
    show "finite S"
      using assms by blast 
    show "disjoint {} \<and> (\<forall>s\<in>{}. one_val_point_c_decomposable m c Fs C s) \<longrightarrow> one_val_point_c_decomposable m c Fs C (\<Union> {})"
      unfolding disjoint_def using assms f_def empty_one_val_point_c_decomposable[of c m f Fs C] f_semialg
      by (metis Sup_empty)
    show "\<And>A a. finite A \<Longrightarrow>
           disjoint A \<and> (\<forall>s\<in>A. one_val_point_c_decomposable m c Fs C s) \<longrightarrow> one_val_point_c_decomposable m c Fs C (\<Union> A) \<Longrightarrow>
           disjoint (insert a A) \<and> (\<forall>s\<in>insert a A. one_val_point_c_decomposable m c Fs C s) \<longrightarrow>
           one_val_point_c_decomposable m c Fs C (\<Union> (insert a A))"
    proof fix A a 
      assume A: "finite A"
           "disjoint A \<and> (\<forall>s\<in>A. one_val_point_c_decomposable m c Fs C s) \<longrightarrow> one_val_point_c_decomposable m c Fs C (\<Union> A)"
           "disjoint (insert a A) \<and> (\<forall>s\<in>insert a A. one_val_point_c_decomposable m c Fs C s)"
      show " one_val_point_c_decomposable m c Fs C (\<Union> (insert a A))"
        apply(cases "a \<in> A")
        using A 
        apply (metis insert_absorb)
      proof-
        assume 00: "a \<notin> A"
        have 0: "disjoint A"
          using A unfolding disjoint_def by blast 
        have 1: "(\<forall>s\<in>A. one_val_point_c_decomposable m c Fs C s)"
          using A by blast 
        have 2: "\<Union>A \<inter>  a = {}"
        proof(rule equalityI')
          show "\<And>x. x \<in> \<Union> A \<inter> a \<Longrightarrow> x \<in> {}"
          proof- fix x assume A0: "x \<in> \<Union> A \<inter> a"
            then obtain s where s_def: "s \<in> A \<and> x \<in> s \<inter> a"
              by blast 
            then have "s \<inter> a = {}"
              using 0 1 A disjointE[of "insert a A" s a] 00  by blast 
            then show "x \<in> {}"
              using s_def by blast 
          qed
          show "\<And>x. x \<in> {} \<Longrightarrow> x \<in> \<Union> A \<inter> a" by blast 
        qed
        have 3: "one_val_point_c_decomposable m c Fs C  a"
          using A by blast 
        have 4: "one_val_point_c_decomposable m c Fs C (\<Union> A)"
          using A 0 1 by blast 
        hence "one_val_point_c_decomposable m c Fs C (\<Union>A \<union> a)"
          using 2 3 4 one_val_point_decomposables_disjoint_union unfolding one_val_point_decomposables_def mem_Collect_eq 
          by blast 
        thus ?thesis 
          by (simp add: Un_commute)
      qed
    qed
  qed
  then show ?thesis 
    using assms by blast 
qed

lemma one_val_point_c_decomposable_minus_one_val_point_c_cell_one_val_point_c_decomposable:
  assumes "c \<in> carrier (SA m)"
  assumes "A \<in> one_val_point_decomposables m c Fs C"
  assumes "\<C> \<in> c_cells_at_one_val_point m c Fs C "
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  shows "one_val_point_c_decomposable m c Fs C (A - condition_to_set \<C>)"
proof-
  obtain S where S_def: "is_cell_decomp m S A \<and> S \<subseteq> c_cells_at_one_val_point m c Fs C"
    using assms unfolding one_val_point_decomposables_def one_val_point_c_decomposable_def mem_Collect_eq by blast 
  have 0: "disjoint (condition_to_set ` S)"
    apply(rule disjointI)
    using S_def is_cell_decompE(5)[of m S A] by blast  
  have 1: "A - condition_to_set \<C> = (\<Union> s \<in> S. condition_to_set s - condition_to_set \<C>)"
    using S_def is_cell_decompE(2)[of m S A] is_partitionE(2)[of "condition_to_set ` S" A]
    by blast 
  have  2: "disjoint ((\<lambda>s . condition_to_set s - condition_to_set \<C>) ` S)"
  proof(rule disjointI) fix a b assume A: " a \<in> (\<lambda>s. condition_to_set s - condition_to_set \<C>) ` S "
           "b \<in> (\<lambda>s. condition_to_set s - condition_to_set \<C>) ` S" "a \<noteq> b"
    then obtain s where s_def: "s \<in> S \<and> a =   condition_to_set s - condition_to_set \<C>"
      by (metis (no_types, lifting) imageE image_restrict_eq)
    then obtain s' where s'_def: "s' \<in> S \<and> b =   condition_to_set s' - condition_to_set \<C>"
      using A by (metis (no_types, lifting) imageE image_restrict_eq)
    have "s \<noteq> s'"
      using s_def s'_def A by blast 
    hence "condition_to_set s \<inter> condition_to_set s' = {}"
      using s_def s'_def is_cell_decompE S_def 
      by meson
    thus "a \<inter> b = {}"
      using s_def s'_def  A  0 disjointE by blast 
  qed
  have 3: "\<And>s. s \<in> S \<Longrightarrow> one_val_point_c_decomposable m c Fs C (condition_to_set s - condition_to_set \<C>)"
  proof-
    fix s assume A: "s \<in> S"
    obtain B f where Bf_def: "s = Cond m B c f f closed_interval"
      using A S_def is_cell_decompE(4)[of m S A s] unfolding c_cells_at_one_val_point_def  
      using Diff_eq_empty_iff Diff_iff all_not_in_conv mem_Collect_eq 
            condition_decomp'[of s] by auto 
    show " one_val_point_c_decomposable m c Fs C (condition_to_set s - condition_to_set \<C>)"
    using assms S_def one_val_point_c_cell_diff unfolding  one_val_point_decomposables_def mem_Collect_eq  
    using A by blast
  qed
  show "one_val_point_c_decomposable m c Fs C (A - condition_to_set \<C>)"
    unfolding 1 
    apply(rule finite_disjoint_union_one_val_point_c_decomposable)
    using assms apply blast 
    using 2 apply blast 
    using S_def is_cell_decompE(1) apply blast 
    using assms using 3 by auto 
qed

lemma one_val_point_c_decomposable_diff0:
  assumes "c \<in> carrier (SA m)" 
  assumes "one_val_point_c_decomposable m c Fs A C"
  assumes "S \<noteq> {} \<and> is_cell_decomp m S B \<and> S \<subseteq> c_cells_at_one_val_point m c Fs A"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  shows "one_val_point_c_decomposable m c Fs A (C - B)"
proof- 
  obtain n where n_def: "n = card S"
    by blast 
  have "\<forall> C S B . one_val_point_c_decomposable m c Fs A C \<longrightarrow> ( n = card S \<longrightarrow> ((S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A)) \<longrightarrow>  one_val_point_c_decomposable m c Fs A (C - B))"
  proof(induction n)
    case 0
    then show ?case  
      by (metis bot_nat_def card_0_eq padic_fields.is_cell_decompE(1) padic_fields_axioms)
  next
    case (Suc n) fix n 
    assume IH: " \<forall>C S B.
            one_val_point_c_decomposable m c Fs A C \<longrightarrow>
            n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A \<longrightarrow> one_val_point_c_decomposable m c Fs A (C - B)"
    show " \<forall>C S B.
            one_val_point_c_decomposable m c Fs A C \<longrightarrow>
            Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A \<longrightarrow> one_val_point_c_decomposable m c Fs A (C - B)"
    proof fix C 
      show "\<forall>S B. one_val_point_c_decomposable m c Fs A C \<longrightarrow>
               Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A \<longrightarrow> one_val_point_c_decomposable m c Fs A (C - B)"
      proof fix S 
        show "\<forall>B. one_val_point_c_decomposable m c Fs A C \<longrightarrow>
             Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A \<longrightarrow> one_val_point_c_decomposable m c Fs A (C - B)"
        proof fix B 
          show "one_val_point_c_decomposable m c Fs A C \<longrightarrow>
         Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A \<longrightarrow> one_val_point_c_decomposable m c Fs A (C - B)"
          proof assume A0: "one_val_point_c_decomposable m c Fs A C "
            show "Suc n = card S \<longrightarrow> S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A \<longrightarrow> one_val_point_c_decomposable m c Fs A (C - B)"
            proof assume A1: "Suc n = card S"
              show "S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A \<longrightarrow> one_val_point_c_decomposable m c Fs A (C - B)"
              proof assume A2: " S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A"
                show "one_val_point_c_decomposable m c Fs A (C - B)"
                proof- 
                  obtain C' where C'_def: "C' \<in> S" using A2 by blast 
                  obtain S' where S'_def: "S' = S - {C'}" by blast 
                  obtain D where D_def: "D = (\<Union> c \<in> S'. condition_to_set c)"
                    by blast 
                  have 00: "\<Union> (condition_to_set ` (S - {C'})) \<subseteq> \<Union> (condition_to_set ` S) "
                    by blast
                  have 0: "is_cell_decomp m S' D \<and>  S' \<subseteq> c_cells_at_one_val_point m c Fs A"
                  proof
                    show "is_cell_decomp m S' D"
                      apply(rule is_cell_decompI) 
                      unfolding S'_def using A2 is_cell_decompE(1) apply blast
                         apply(rule is_partitionI) using A2 is_cell_decompE(2)[of m S B] 
                      unfolding disjoint_def using  is_partitionE(1)[of "condition_to_set ` S" B]  
                      apply (metis (mono_tags, lifting) DiffD1 image_iff disjoint_def)
                        unfolding D_def S'_def apply blast 
                        using A2 is_cell_decompE(4)[of m S B] 
                        apply (meson DiffD1 is_cell_decompE(3))
                        using A2 is_cell_decompE(2)[of m S B] is_partitionE[of "condition_to_set ` S" B]
                              is_cell_decompE(6)[of m S B] 00 apply blast
                        using A2 is_cell_decompE(2)[of m S B] is_partitionE(1)[of "condition_to_set ` S" B]
                        unfolding disjoint_def using is_cell_decompE(6)[of m S B] 00 
                        by (meson Diff_iff is_cell_decompE(5))
                      show " S' \<subseteq> c_cells_at_one_val_point m c Fs A"
                        using A2 unfolding S'_def by blast
                  qed
                  have 1: "one_val_point_c_decomposable m c Fs A (C - D)"
                  proof(cases "D = {}")
                    case True
                    then show ?thesis using A0 unfolding True by simp
                  next
                    case False
                    have F0: "S' \<noteq> {}"
                    proof assume A: "S' = {}"
                      then have "D = {}"
                        using 0 is_cell_decompE(2)[of m S' D] is_partitionE[of "condition_to_set ` S'" D]
                        unfolding A by blast
                      then show False using False by blast 
                    qed
                    have F1: "one_val_point_c_decomposable m c Fs A D"
                      unfolding one_val_point_c_decomposable_def 
                      using "0" by auto
                    have F2: "\<And> C S B. one_val_point_c_decomposable m c Fs A C \<Longrightarrow> n = card S \<Longrightarrow> 
                                    S \<noteq> {} \<and> is_cell_decomp m S B \<and>  S \<subseteq> c_cells_at_one_val_point m c Fs A \<Longrightarrow>
                                     one_val_point_c_decomposable m c Fs A (C - B)"
                      using IH by blast 
                    have F3: "n = card (S - {C'})"
                      by (metis A1 C'_def Diff_empty card.infinite card_Diff_insert diff_Suc_1 mem_simps(2) zero_less_Suc zero_less_iff_neq_zero)
                    show ?thesis
                      using A0 F0 F2[of C S' D] 0 F1 F3  unfolding S'_def  by blast 
                  qed
                  have 2: "B = \<Union> (condition_to_set ` S)"
                    using A2 is_cell_decompE(2)[of m S B] is_partitionE[of "condition_to_set ` S" B] by blast 
                  have 3: "C - B = (C - D) - condition_to_set C'"
                    unfolding D_def S'_def 2 using C'_def by blast 
                  have 5: "condition_to_set C' \<subseteq> A \<and>
             is_cell_condition C' \<and> arity C' = m \<and> center C' = c \<and> u_bound C' = l_bound C'\<and> u_bound C' \<in> Fs \<and> boundary_condition C' = closed_interval"
 using C'_def A2 is_cell_decompE condition_decomp'[of C'] unfolding c_cells_at_one_val_point_def  by blast 
                  then obtain D' a  where  def: "C' = Cond m D' c a a closed_interval"
                    using C'_def A2 is_cell_decompE condition_decomp'[of C'] unfolding c_cells_at_one_val_point_def 
                    by metis
                  have 4: "one_val_point_c_decomposable m c Fs A ((C - D) - condition_to_set C')"
                    apply(rule one_val_point_c_decomposable_minus_one_val_point_c_cell_one_val_point_c_decomposable)
                    using assms unfolding one_val_point_c_decomposable_def apply blast 
                    using 1 unfolding one_val_point_decomposables_def mem_Collect_eq  apply blast 
                    using def C'_def A2 is_cell_decompE(3)[of m S B C'] 
                     unfolding c_cells_at_one_val_point_def mem_Collect_eq 
                     using 5 assms by auto              
                  show ?thesis using 4 unfolding D_def S'_def 
                    using A2 is_cell_decompE(2) is_partitionE (2) "3" "4" by presburger
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
  then show ?thesis using assms n_def by blast
qed

lemma one_val_point_c_decomposable_nonempty:
  assumes "c \<in> carrier (SA m)"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "one_val_point_c_decomposable m c Fs A C"
  shows "\<exists>S. S \<noteq> {} \<and> is_cell_decomp m S C \<and> S \<subseteq> c_cells_at_one_val_point m c Fs A"
proof(cases "C = {}")
  case True
  obtain f where f_def: "f \<in> Fs"
    using assms by auto 
  obtain \<C> where \<C>_def: "\<C> = Cond m {} c f f  closed_interval"
    by blast
  have 0: "is_cell_condition \<C>"
    unfolding \<C>_def apply(rule is_cell_conditionI')
  apply (simp add: empty_is_semialgebraic)
  apply (simp add: assms)
  using assms f_def assms f_def is_convex_condition_def by auto
  have 1: "\<C> \<in> c_cells_at_one_val_point m c Fs A"
    using 0 assms f_def
    unfolding \<C>_def c_cells_at_one_val_point_def mem_Collect_eq arity.simps center.simps
 u_bound.simps l_bound.simps boundary_condition.simps condition_to_set.simps cell_def
    by auto 
  have 2: "{} = condition_to_set \<C>"
    unfolding \<C>_def condition_to_set.simps cell_def by blast 
  have 3: "{\<C>} \<noteq> {} \<and> is_cell_decomp m {\<C>} C \<and> {\<C>} \<subseteq> c_cells_at_one_val_point m c Fs A"
    apply(rule conjI)
     apply blast 
    apply(rule conjI)
    apply(rule is_cell_decompI)
         apply blast apply(rule is_partitionI)
         apply(rule disjointI) apply blast unfolding True \<C>_def using 2  \<C>_def apply blast
    using arity.simps \<C>_def 0 apply blast 
      apply blast apply blast apply(rule subsetI) using 1 unfolding \<C>_def by blast    
  then show ?thesis by blast 
next
  case False
  obtain S where S_def: "is_cell_decomp m S C \<and> S \<subseteq> c_cells_at_one_val_point m c Fs A"
    using False assms  unfolding one_val_point_c_decomposable_def by blast 
  then have "S \<noteq> {}"
    using False  S_def is_cell_decompE is_partitionE 
    by (metis ccSup_empty image_empty)
  then show ?thesis using S_def by blast 
qed

lemma one_val_point_c_decomposable_diff:
  assumes "c \<in> carrier (SA m)"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "one_val_point_c_decomposable m c Fs A C"
  assumes "one_val_point_c_decomposable m c Fs A B"
  shows "one_val_point_c_decomposable m c Fs A (C - B)"
  using one_val_point_c_decomposable_diff0 assms one_val_point_c_decomposable_nonempty
  by metis 

lemma one_val_point_decomposables_is_gen_boolean_algebra:
  assumes "c \<in> carrier (SA m)"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "C \<in> one_val_point_decomposables m c Fs C"
  shows "gen_boolean_algebra C (condition_to_set ` (c_cells_at_one_val_point m c Fs C)) =  (one_val_point_decomposables m c Fs C) "
proof
  show "gen_boolean_algebra C (condition_to_set ` c_cells_at_one_val_point m c Fs C) \<subseteq> one_val_point_decomposables m c Fs C"
  proof fix x assume A: "x \<in> gen_boolean_algebra C (condition_to_set ` c_cells_at_one_val_point m c Fs C)"
    show "x \<in> one_val_point_decomposables m c Fs C"
      apply(rule boolean_algebra_alt_induct[of x C "(condition_to_set ` (c_cells_at_one_val_point m c Fs C))"])
      using A apply blast 
      using assms apply blast 
    proof- 
      show "\<And>A. A \<in> condition_to_set ` c_cells_at_one_val_point m c Fs C \<Longrightarrow> A \<inter> C \<in> one_val_point_decomposables m c Fs C"
      proof-  fix A assume AA: "A \<in> condition_to_set ` c_cells_at_one_val_point m c Fs C"
        then have "A \<subseteq> C"
          unfolding c_cells_at_one_val_point_def by blast 
        thus "A \<inter> C \<in> one_val_point_decomposables m c Fs C" 
          using c_cells_at_one_val_point_is_c_decomposable AA 
          by (metis image_iff inf_absorb1)
      qed
      show "\<And>A Ca.
       A \<in> gen_boolean_algebra C (condition_to_set ` c_cells_at_one_val_point m c Fs C) \<Longrightarrow>
       Ca \<in> gen_boolean_algebra C (condition_to_set ` c_cells_at_one_val_point m c Fs C) \<Longrightarrow>
       A \<in> one_val_point_decomposables m c Fs C \<Longrightarrow>
       Ca \<in> one_val_point_decomposables m c Fs C \<Longrightarrow> A \<inter> Ca = {} \<Longrightarrow> A \<union> Ca \<in> one_val_point_decomposables m c Fs C"
        using one_val_point_decomposables_disjoint_union by metis
      show " \<And>A Ca.
       A \<in> gen_boolean_algebra C (condition_to_set ` c_cells_at_one_val_point m c Fs C) \<Longrightarrow>
       Ca \<in> gen_boolean_algebra C (condition_to_set ` c_cells_at_one_val_point m c Fs C) \<Longrightarrow>
       A \<in> one_val_point_decomposables m c Fs C \<Longrightarrow> Ca \<in> one_val_point_decomposables m c Fs C \<Longrightarrow> A - Ca \<in> one_val_point_decomposables m c Fs C"
        using one_val_point_c_decomposable_diff[of c m Fs C] assms 
        unfolding one_val_point_decomposables_def mem_Collect_eq by blast 
    qed
  qed
  show "one_val_point_decomposables m c Fs C \<subseteq> gen_boolean_algebra C (condition_to_set ` c_cells_at_one_val_point m c Fs C)"
  proof fix x assume A: "x \<in> one_val_point_decomposables m c Fs C"
    show " x \<in> gen_boolean_algebra C (condition_to_set ` c_cells_at_one_val_point m c Fs C)"
    proof-
      obtain S where S_def: "S \<noteq> {} \<and> is_cell_decomp m S x \<and> S \<subseteq> c_cells_at_one_val_point m c Fs C"
        using A assms one_val_point_c_decomposable_nonempty[of c m Fs C x] 
        unfolding one_val_point_decomposables_def mem_Collect_eq by blast         
      have 0: "x = (\<Union> Y \<in> S. condition_to_set Y )"
        using S_def 
        by (metis is_cell_decompE(2) is_partitionE(2))
      have 1: "\<And>Y. Y \<in> S \<Longrightarrow> Y \<in> c_cells_at_one_val_point m c Fs C"
        using S_def by blast 
      show ?thesis 
        unfolding 0 apply(rule gen_boolean_algebra_finite_union[of ])
         apply(rule gen_boolean_algebra_generators) using S_def unfolding c_cells_at_one_val_point_def mem_Collect_eq 
        using 1 apply blast 
        using 0 1 S_def is_cell_decompE(1) unfolding  c_cells_at_one_val_point_def   
        apply blast
        using S_def is_cell_decompE by blast 
    qed
  qed
qed

lemma c_cells_at_one_val_point_union0:
  assumes "\<C> = (Cond m A c f f closed_interval)"
  assumes "\<C>' = (Cond m C c g g closed_interval)"
  assumes "is_cell_condition \<C>"
  assumes "is_cell_condition \<C>'"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "f \<in> Fs"
  assumes "g \<in> Fs"
  shows "one_val_point_c_decomposable m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (condition_to_set \<C> \<union> condition_to_set \<C>')"
proof-
  have 0: "\<C> \<in> c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    using assms 
    unfolding c_cells_at_one_val_point_def mem_Collect_eq assms arity.simps
              center.simps u_bound.simps l_bound.simps boundary_condition.simps condition_to_set.simps cell_def 
    by blast 
  have 1: "\<C>' \<in> c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    using assms 
    unfolding c_cells_at_one_val_point_def mem_Collect_eq assms arity.simps
              center.simps u_bound.simps l_bound.simps boundary_condition.simps condition_to_set.simps cell_def 
    by blast 
  have 2: "one_val_point_c_decomposable m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (condition_to_set \<C>)"
    using assms 0 c_cells_at_one_val_point_is_c_decomposable 
    unfolding one_val_point_decomposables_def mem_Collect_eq   by blast 
  have 3: "one_val_point_c_decomposable m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (condition_to_set \<C>')"
    using assms 1 c_cells_at_one_val_point_is_c_decomposable 
    unfolding one_val_point_decomposables_def mem_Collect_eq   by blast 
  have 4: "condition_to_set \<C> \<union> condition_to_set \<C>' = 
      (condition_to_set \<C> - condition_to_set \<C>') \<union> (condition_to_set \<C>' - condition_to_set \<C>) \<union> (condition_to_set \<C> \<inter> condition_to_set \<C>')"
    by blast 
  have 5: "(condition_to_set \<C> - condition_to_set \<C>') \<union> (condition_to_set \<C>' - condition_to_set \<C>) \<in> one_val_point_decomposables m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    apply(rule one_val_point_decomposables_disjoint_union)
    unfolding one_val_point_decomposables_def mem_Collect_eq 
    apply(rule one_val_point_c_decomposable_minus_one_val_point_c_cell_one_val_point_c_decomposable)
    using assms unfolding assms using is_cell_conditionE apply blast
    using 2 unfolding one_val_point_decomposables_def mem_Collect_eq assms apply blast 
    using 1 unfolding one_val_point_decomposables_def mem_Collect_eq assms apply blast
    using assms apply blast using assms apply blast
    apply(rule one_val_point_c_decomposable_minus_one_val_point_c_cell_one_val_point_c_decomposable)
    using assms unfolding assms using is_cell_conditionE apply blast
    using 3 0 assms one_val_point_decomposables_def mem_Collect_eq assms by auto 
  have 6: "(condition_to_set \<C> \<inter> condition_to_set \<C>')  \<in> one_val_point_decomposables m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    unfolding assms finite_closed_interval_cell_intersection
    apply(rule c_cells_at_one_val_point_is_c_decomposable )
    unfolding c_cells_at_one_val_point_def mem_Collect_eq arity.simps center.simps u_bound.simps l_bound.simps boundary_condition.simps 
    apply(rule conjI)
    unfolding condition_to_set.simps cell_def apply blast 
    apply(rule conjI)
     apply(rule is_cell_conditionI')
         apply(rule intersection_is_semialg)
    apply(rule intersection_is_semialg)
    using assms unfolding assms using is_cell_conditionE apply blast 
    using assms unfolding assms using is_cell_conditionE apply blast 
    using assms unfolding assms 
    using is_cell_conditionE(3)[of m A c f f closed_interval] is_cell_conditionE(3)[of m C c g g closed_interval]
          semialg_val_eq_set_is_semialg apply blast
     using assms unfolding assms using is_cell_conditionE apply blast 
    using assms unfolding assms using is_cell_conditionE apply blast 
    using assms unfolding assms using is_cell_conditionE apply blast 
    using assms unfolding assms using is_cell_conditionE apply meson 
    using assms by auto 
  have 7: "(condition_to_set \<C> - condition_to_set \<C>') \<union> (condition_to_set \<C>' - condition_to_set \<C>) \<union> (condition_to_set \<C> \<inter> condition_to_set \<C>') \<in> 
one_val_point_decomposables m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    apply(rule one_val_point_decomposables_disjoint_union)
    using 5 apply blast using 6 apply blast by blast 
  thus ?thesis unfolding one_val_point_decomposables_def mem_Collect_eq 4 by blast
qed

lemma c_cells_at_one_val_point_union:
  assumes "c \<in> carrier (SA m)"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "\<C> \<in> c_cells_at_one_val_point m c Fs C"
  assumes "\<C>' \<in> c_cells_at_one_val_point m c Fs C"
  shows "one_val_point_c_decomposable m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (condition_to_set \<C> \<union> condition_to_set \<C>')"
proof- 
  obtain A f where Af_def: "f \<in> Fs" "\<C> = (Cond m A c f f closed_interval)"
    using assms condition_decomp'  unfolding c_cells_at_one_val_point_def mem_Collect_eq 
    by metis
  obtain C g where Bg_def: "g \<in> Fs" "\<C>' = (Cond m C c g g closed_interval)"
    using assms condition_decomp'  unfolding c_cells_at_one_val_point_def mem_Collect_eq 
    by metis
  show ?thesis 
    apply(rule c_cells_at_one_val_point_union0[of _ _ A _ f _ C g])
    unfolding Af_def Bg_def apply blast apply blast 
    using assms unfolding Af_def c_cells_at_one_val_point_def mem_Collect_eq apply blast  
    using assms Af_def Bg_def unfolding Bg_def c_cells_at_one_val_point_def mem_Collect_eq by auto  
qed

lemma c_cells_at_one_val_point_intersection:
  assumes "c \<in> carrier (SA m)"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes "\<C> \<in> c_cells_at_one_val_point m c Fs C"
  assumes "\<C>' \<in> c_cells_at_one_val_point m c Fs C"
  shows "one_val_point_c_decomposable m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (condition_to_set \<C> \<inter> condition_to_set \<C>')"
proof- 
  obtain A f where Af_def:"f \<in> Fs" "\<C> = (Cond m A c f f closed_interval)"
    using assms condition_decomp'  unfolding c_cells_at_one_val_point_def mem_Collect_eq 
    by metis
  obtain C g where Bg_def:"g \<in> Fs" "\<C>' = (Cond m C c g g closed_interval)"
    using assms condition_decomp'  unfolding c_cells_at_one_val_point_def mem_Collect_eq 
    by metis
  have " (condition_to_set \<C> \<inter> condition_to_set \<C>') \<in> one_val_point_decomposables m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))" 
    unfolding Af_def Bg_def finite_closed_interval_cell_intersection
    apply(rule c_cells_at_one_val_point_is_c_decomposable ) 
    unfolding c_cells_at_one_val_point_def mem_Collect_eq arity.simps center.simps u_bound.simps l_bound.simps boundary_condition.simps 
              condition_to_set.simps cell_def 
    apply(rule conjI)
    apply blast 
    apply(rule conjI)
    apply(rule is_cell_conditionI')
     apply(rule intersection_is_semialg)
    apply(rule intersection_is_semialg)
    using assms unfolding assms c_cells_at_one_val_point_def mem_Collect_eq  Af_def Bg_def using is_cell_conditionE apply blast 
    using assms unfolding assms c_cells_at_one_val_point_def mem_Collect_eq  Af_def Bg_def using is_cell_conditionE apply blast 
    using assms is_cell_conditionE(3)[of m A c f f closed_interval] is_cell_conditionE(3)[of m C c g g closed_interval]
          semialg_val_eq_set_is_semialg unfolding assms c_cells_at_one_val_point_def mem_Collect_eq  Af_def Bg_def apply blast
    using assms unfolding assms using is_cell_conditionE apply blast
    using assms Af_def is_convex_condition_def by auto
  then show ?thesis  unfolding one_val_point_decomposables_def mem_Collect_eq by blast 
qed

lemma one_val_point_decomposables_is_cell_algebra:
  assumes "c \<in> carrier (SA m)"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  shows "one_val_point_decomposables m c Fs C = cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs C)"
proof
  obtain f where f_def: "f \<in> Fs"
    using assms by auto 
  show " one_val_point_decomposables m c Fs C \<subseteq> cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs C)"
  proof fix x assume A: "x \<in> one_val_point_decomposables m c Fs C"
    then obtain S where S_def: "is_cell_decomp m S x \<and> S \<subseteq> c_cells_at_one_val_point m c Fs C"
      unfolding one_val_point_decomposables_def mem_Collect_eq one_val_point_c_decomposable_def
      by blast 
    have 0: "x = \<Union> (condition_to_set ` S)"
      using S_def is_cell_decompE(2)[of m S x] is_partitionE[of "condition_to_set ` S " x] by blast 
    show "x \<in> cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs C)"
      unfolding 0 
      apply(rule cell_algebra_finite_disjoint_union)
      apply(rule subsetI)
      using cell_algebra.generator[of _ "condition_to_set `c_cells_at_one_val_point m c Fs C"] S_def 
      apply blast
      using S_def is_cell_decompE apply blast 
      apply(rule disjointI) using S_def is_cell_decompE disjointE 
      by (metis is_partitionE(1))
  qed
  show "cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs C) \<subseteq> one_val_point_decomposables m c Fs C"
  proof fix x assume A: "x \<in> cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs C)"
    show "x \<in> one_val_point_decomposables m c Fs C"
      apply(rule cell_algebra.induct[of x "(condition_to_set ` c_cells_at_one_val_point m c Fs C)"])
      using A apply blast 
      using empty_one_val_point_c_decomposable[of c m f Fs C] f_def assms
            one_val_point_decomposables_def 
          apply auto[1]
      using assms c_cells_at_one_val_point_is_c_decomposable[of _ m c Fs C] unfolding image_iff apply blast   
      using one_val_point_decomposables_disjoint_union[of _ m c Fs C] unfolding image_iff by blast 
  qed
qed

lemma finite_union_one_val_point_c_decomposable:
  assumes "c \<in> carrier (SA m)"
  assumes "finite S"
  assumes "Fs \<noteq> {}"
  assumes "Fs \<subseteq> carrier (SA m)"
  assumes " S \<subseteq> condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
  shows "one_val_point_c_decomposable m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) (\<Union> S)"
proof-
  have 00: "\<And>s. s \<in> S \<Longrightarrow> one_val_point_c_decomposable m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) s"
  proof- 
    fix s assume A: "s \<in> S"
    obtain \<C> where \<C>_def: "\<C> \<in> c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))" 
                          "s = condition_to_set \<C>"
      using A assms by auto 
    show "one_val_point_c_decomposable m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) s" 
      using \<C>_def assms basic_trans_rules(31) image_iff inf.idem 
            c_cells_at_one_val_point_intersection[of _ _ _ \<C> _ \<C>]
      unfolding \<C>_def by auto 
  qed
  have 0: "cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))) = one_val_point_decomposables m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    using 00 assms one_val_point_decomposables_is_cell_algebra by metis 
  have "(\<Union> S) \<in> cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)))"
    apply(rule cell_algebra_finite_union)
  proof- 
    fix A B assume A: " A \<in> condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))" "B \<in> condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
    obtain \<C> where \<C>_def: "\<C> \<in>  c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) \<and> A = condition_to_set \<C>"
      using A by blast 
    have \<C>: "A = condition_to_set \<C>"
      using \<C>_def by blast 
    obtain \<C>' where \<C>'_def: "\<C>' \<in>  c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) \<and> B = condition_to_set \<C>'"
      using A by blast 
    have \<C>': "B = condition_to_set \<C>'"
      using \<C>'_def by blast 
    show "A \<inter> B \<in> cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)))"
      unfolding \<C> \<C>' 0  one_val_point_decomposables_def mem_Collect_eq 
      apply(rule c_cells_at_one_val_point_intersection[of _ _ _ _ "carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"])
      using assms \<C>_def \<C>'_def  by auto 
    show "\<And>A C. A \<in> condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) \<Longrightarrow>
           C \<in> condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)) \<Longrightarrow>
           A - C \<in> cell_algebra (condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)))"
      unfolding one_val_point_decomposables_def mem_Collect_eq 0
      apply(rule one_val_point_c_decomposable_diff)
      using assms apply blast 
      using assms apply blast 
      using assms apply blast 
      using c_cells_at_one_val_point_is_c_decomposable[of _ m c _ "carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"]
      unfolding one_val_point_decomposables_def mem_Collect_eq apply blast 
      using c_cells_at_one_val_point_is_c_decomposable[of _ m c _  "carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>)"]
      unfolding one_val_point_decomposables_def mem_Collect_eq by blast
  next 
    show "finite S \<and> S \<subseteq> condition_to_set ` c_cells_at_one_val_point m c Fs (carrier (Q\<^sub>p\<^bsup>Suc m\<^esup>))"
      using assms by blast 
  qed
  thus ?thesis unfolding 0  unfolding one_val_point_decomposables_def mem_Collect_eq  by blast 
qed
end

end 